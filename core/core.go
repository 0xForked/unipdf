//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ddc "bufio";_eaf "bytes";_f "compress/lzw";_ca "compress/zlib";_dbc "crypto/md5";_egf "crypto/rand";_g "encoding/hex";_a "errors";_ac "fmt";_af "github.com/unidoc/unipdf/v3/common";_edg "github.com/unidoc/unipdf/v3/core/security";_fb "github.com/unidoc/unipdf/v3/core/security/crypt";_bb "github.com/unidoc/unipdf/v3/internal/ccittfax";_dcad "github.com/unidoc/unipdf/v3/internal/imageutil";_dca "github.com/unidoc/unipdf/v3/internal/jbig2";_bbb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ece "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ef "github.com/unidoc/unipdf/v3/internal/jbig2/document";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ec "github.com/unidoc/unipdf/v3/internal/strutils";_eac "golang.org/x/image/tiff/lzw";_eb "image";_eg "image/color";_ed "image/jpeg";_e "io";_ea "os";_d "reflect";_db "regexp";_dc "sort";_c "strconv";_dd "strings";_ba "time";);

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_eagab :=MakeArray ();for _ ,_eefd :=range vals {_eagab .Append (MakeInteger (_eefd ));};return _eagab ;};func (_ce *PdfParser )lookupByNumberWrapper (_gfb int ,_dbce bool )(PdfObject ,bool ,error ){_dgd ,_eba ,_aa :=_ce .lookupByNumber (_gfb ,_dbce );if _aa !=nil {return nil ,_eba ,_aa ;};if !_eba &&_ce ._fdab !=nil &&!_ce ._fdab .isDecrypted (_dgd ){_be :=_ce ._fdab .Decrypt (_dgd ,0,0);if _be !=nil {return nil ,_eba ,_be ;};};return _dgd ,_eba ,nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_ffec *PdfParser )GetCrypter ()*PdfCrypt {return _ffec ._fdab };

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_ggbc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ggbc .Predictor !=1{return nil ,_ac .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _ggbc .EarlyChange ==1{return nil ,_ac .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ggc _eaf .Buffer ;_abc :=_f .NewWriter (&_ggc ,_f .MSB ,8);_abc .Write (data );_abc .Close ();return _ggc .Bytes (),nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};const (_gce =0;_fgab =1;_dfag =2;_afdaf =3;_gfd =4;);

// GetFilterName returns the name of the encoding filter.
func (_ggfd *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_cdfdf *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bbfb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _ddgc :=_cdfdf .AddPageImage (img ,&_cdfdf .DefaultPageSettings );_ddgc !=nil {return nil ,_fg .Wrap (_ddgc ,_bbfb ,"");};return _cdfdf .Encode ();};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_af .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bcadcf ,_bbbgb :=NewEncoderFromStream (streamObj );if _bbbgb !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bbbgb );return nil ,_bbbgb ;};_af .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_bcadcf );_cage ,_bbbgb :=_bcadcf .DecodeStream (streamObj );if _bbbgb !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bbbgb );return nil ,_bbbgb ;};return _cage ,nil ;};type xrefType int ;

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fed *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_gbf ,_ ,_cc :=_fed .lookupByNumberWrapper (objNumber ,true );return _gbf ,_cc ;};

// UpdateParams updates the parameter values of the encoder.
func (_dcfd *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_fab []StreamEncoder };const _fgce =10;func _bgf (_aag *_edg .StdEncryptDict ,_age *PdfObjectDictionary ){_age .Set ("\u0052",MakeInteger (int64 (_aag .R )));_age .Set ("\u0050",MakeInteger (int64 (_aag .P )));_age .Set ("\u004f",MakeStringFromBytes (_aag .O ));_age .Set ("\u0055",MakeStringFromBytes (_aag .U ));if _aag .R >=5{_age .Set ("\u004f\u0045",MakeStringFromBytes (_aag .OE ));_age .Set ("\u0055\u0045",MakeStringFromBytes (_aag .UE ));_age .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_aag .EncryptMetadata ));if _aag .R > 5{_age .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_aag .Perms ));};};};func (_deb *PdfCrypt )authenticate (_eef []byte )(bool ,error ){_deb ._cd =false ;_ccd :=_deb .securityHandler ();_gdc ,_bda ,_dfca :=_ccd .Authenticate (&_deb ._cabf ,_eef );if _dfca !=nil {return false ,_dfca ;}else if _bda ==0||len (_gdc )==0{return false ,nil ;};_deb ._cd =true ;_deb ._bdb =_gdc ;return true ,nil ;};func (_ceabc *PdfParser )parseHexString ()(*PdfObjectString ,error ){_ceabc ._ecagb .ReadByte ();var _bffg _eaf .Buffer ;for {_ebeb ,_ceaf :=_ceabc ._ecagb .Peek (1);if _ceaf !=nil {return MakeString (""),_ceaf ;};if _ebeb [0]=='>'{_ceabc ._ecagb .ReadByte ();break ;};_beaf ,_ :=_ceabc ._ecagb .ReadByte ();if !IsWhiteSpace (_beaf ){_bffg .WriteByte (_beaf );};};if _bffg .Len ()%2==1{_bffg .WriteRune ('0');};_eefcb ,_ :=_g .DecodeString (_bffg .String ());return MakeHexString (string (_eefcb )),nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_faee *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_geb :=_eaf .NewReader (data );var _ecfg []byte ;var _acab []byte ;_dddc ,_daad :=_geb .ReadByte ();if _daad ==_e .EOF {return []byte {},nil ;}else if _daad !=nil {return nil ,_daad ;};_bede :=1;for {_gbgg ,_edd :=_geb .ReadByte ();if _edd ==_e .EOF {break ;}else if _edd !=nil {return nil ,_edd ;};if _gbgg ==_dddc {if len (_acab )> 0{_acab =_acab [:len (_acab )-1];if len (_acab )> 0{_ecfg =append (_ecfg ,byte (len (_acab )-1));_ecfg =append (_ecfg ,_acab ...);};_bede =1;_acab =[]byte {};};_bede ++;if _bede >=127{_ecfg =append (_ecfg ,byte (257-_bede ),_dddc );_bede =0;};}else {if _bede > 0{if _bede ==1{_acab =[]byte {_dddc };}else {_ecfg =append (_ecfg ,byte (257-_bede ),_dddc );};_bede =0;};_acab =append (_acab ,_gbgg );if len (_acab )>=127{_ecfg =append (_ecfg ,byte (len (_acab )-1));_ecfg =append (_ecfg ,_acab ...);_acab =[]byte {};};};_dddc =_gbgg ;};if len (_acab )> 0{_ecfg =append (_ecfg ,byte (len (_acab )-1));_ecfg =append (_ecfg ,_acab ...);}else if _bede > 0{_ecfg =append (_ecfg ,byte (257-_bede ),_dddc );};_ecfg =append (_ecfg ,128);return _ecfg ,nil ;};func (_gba *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_acdg :=MakeDict ();_acdg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_acdg .Set ("\u0056",MakeInteger (int64 (_gba ._bbbb .V )));_acdg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gba ._bbbb .Length )));return _acdg ;};func _bbe (_cae XrefTable ){_af .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_af .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ggg :=0;for _ ,_bgg :=range _cae .ObjectMap {_af .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_ggg +1,_bgg .ObjectNumber ,_bgg .Generation ,_bgg .Offset );_ggg ++;};};func (_acgdc *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _ffcdf =20;_eggaa ,_ :=_acgdc ._ecagb .Peek (_ffcdf );for _fefd :=0;_fefd < 2;_fefd ++{if _acgdc ._cgcdf ==0{_acgdc ._cgcdf =_acgdc .GetFileOffset ();};if _agcc .Match (_eggaa ){_af .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_af .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_eggaa ));return _acgdc .parseXrefStream (nil );};if _ffed .Match (_eggaa ){_af .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _acgdc .parseXrefTable ();};_dffgb :=_acgdc .GetFileOffset ();if _acgdc ._cgcdf ==0{_acgdc ._cgcdf =_dffgb ;};_acgdc .SetFileOffset (_dffgb -_ffcdf );defer _acgdc .SetFileOffset (_dffgb );_ccaf ,_ :=_acgdc ._ecagb .Peek (_ffcdf );_eggaa =append (_ccaf ,_eggaa ...);};_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _befd :=_acgdc .repairSeekXrefMarker ();_befd !=nil {_af .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_befd );return nil ,_befd ;};return _acgdc .parseXrefTable ();};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_beff *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_beff ._deedf ){return _a .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_beff ._deedf [i ]=obj ;return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gfdc *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};func _fdd (_ecac *_fb .FilterDict ,_cgbd *PdfObjectDictionary )error {if _cbf ,_dac :=_cgbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dac {if _ff :=string (*_cbf );_ff !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_af .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ff );};};_aeb ,_gae :=_cgbd .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_gae {return _ac .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_ecac .CFM =string (*_aeb );if _dcf ,_fdc :=_cgbd .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_fdc {_ecac .AuthEvent =_edg .AuthEvent (*_dcf );}else {_ecac .AuthEvent =_edg .EventDocOpen ;};if _edc ,_bbde :=_cgbd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_bbde {_ecac .Length =int (*_edc );};return nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_cfa *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_af .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_af .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cfa .Predictor );_dabe ,_dbgf :=_cfa .DecodeBytes (streamObj .Stream );if _dbgf !=nil {return nil ,_dbgf ;};_af .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_af .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_dabe ),_dabe );if _cfa .Predictor > 1{if _cfa .Predictor ==2{_af .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eabd :=int (_cfa .Columns )*_cfa .Colors ;if _eabd < 1{return []byte {},nil ;};_aagg :=len (_dabe )/_eabd ;if len (_dabe )%_eabd !=0{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dabe ),_eabd );};if _eabd %_cfa .Colors !=0{return nil ,_ac .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_eabd ,_cfa .Colors );};if _eabd > len (_dabe ){_af .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eabd ,len (_dabe ));return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_af .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dabe ),_dabe );_feg :=_eaf .NewBuffer (nil );for _gdcc :=0;_gdcc < _aagg ;_gdcc ++{_cegg :=_dabe [_eabd *_gdcc :_eabd *(_gdcc +1)];for _ffad :=_cfa .Colors ;_ffad < _eabd ;_ffad ++{_cegg [_ffad ]=byte (int (_cegg [_ffad ]+_cegg [_ffad -_cfa .Colors ])%256);};_feg .Write (_cegg );};_bcea :=_feg .Bytes ();_af .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bcea ),_bcea );return _bcea ,nil ;}else if _cfa .Predictor >=10&&_cfa .Predictor <=15{_af .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ced :=int (_cfa .Columns *_cfa .Colors +1);if _ced < 1{return []byte {},nil ;};_agcd :=len (_dabe )/_ced ;if len (_dabe )%_ced !=0{return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dabe ),_ced );};if _ced > len (_dabe ){_af .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ced ,len (_dabe ));return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dbba :=_eaf .NewBuffer (nil );_af .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cfa .Columns );_af .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dabe ),_ced ,_agcd );_bfcd :=make ([]byte ,_ced );for _edb :=0;_edb < _ced ;_edb ++{_bfcd [_edb ]=0;};for _ebba :=0;_ebba < _agcd ;_ebba ++{_fgd :=_dabe [_ced *_ebba :_ced *(_ebba +1)];_affd :=_fgd [0];switch _affd {case 0:case 1:for _bbc :=2;_bbc < _ced ;_bbc ++{_fgd [_bbc ]=byte (int (_fgd [_bbc ]+_fgd [_bbc -1])%256);};case 2:for _dfad :=1;_dfad < _ced ;_dfad ++{_fgd [_dfad ]=byte (int (_fgd [_dfad ]+_bfcd [_dfad ])%256);};default:_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_affd );return nil ,_ac .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_affd );};for _ddeb :=0;_ddeb < _ced ;_ddeb ++{_bfcd [_ddeb ]=_fgd [_ddeb ];};_dbba .Write (_fgd [1:]);};_bedb :=_dbba .Bytes ();return _bedb ,nil ;}else {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cfa .Predictor );return nil ,_ac .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cfa .Predictor );};};return _dabe ,nil ;};func _affe (_fdcbd _dcad .Image )*JBIG2Image {_bcag :=_fdcbd .Base ();return &JBIG2Image {Data :_bcag .Data ,Width :_bcag .Width ,Height :_bcag .Height ,HasPadding :true };};

// String returns a string describing `null`.
func (_ccdc *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_fbf *FlateEncoder )cleanImageData (_adca []byte )([]byte ,error ){if _fbf ._gece ==nil {return _adca ,nil ;};if _fbf ._gece .BitsPerComponent >=8{return _adca ,nil ;};_fefe :=_fbf ._gece .BitsPerComponent *_fbf ._gece .Width *_fbf ._gece .ColorComponents *_fbf ._gece .Height /8;_adca =_adca [:_fefe ];var _cde error ;_adca ,_cde =_dcad .AddDataPadding (_fbf ._gece .Width ,_fbf ._gece .Height ,_fbf ._gece .BitsPerComponent ,_fbf ._gece .ColorComponents ,_adca );if _cde !=nil {return nil ,_cde ;};return _adca ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_edde *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func (_gcb *PdfParser )lookupObjectViaOS (_bbf int ,_ab int )(PdfObject ,error ){var _de *_eaf .Reader ;var _ecd objectStream ;var _bbd bool ;_ecd ,_bbd =_gcb ._dgf [_bbf ];if !_bbd {_egb ,_ad :=_gcb .LookupByNumber (_bbf );if _ad !=nil {_af .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_bbf );return nil ,_ad ;};_gd ,_ae :=_egb .(*PdfObjectStream );if !_ae {return nil ,_a .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _gcb ._fdab !=nil &&!_gcb ._fdab .isDecrypted (_gd ){return nil ,_a .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_bf :=_gd .PdfObjectDictionary ;_af .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bf .String ());_df ,_ae :=_bf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ae {_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_a .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _dd .ToLower (string (*_df ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_a .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ae :=_bf .Get ("\u004e").(*PdfObjectInteger );if !_ae {return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gb ,_ae :=_bf .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ae {return nil ,_a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_af .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_df ,*N );_ecef ,_ad :=DecodeStream (_gd );if _ad !=nil {return nil ,_ad ;};_af .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ecef );_fbe :=_gcb .GetFileOffset ();defer func (){_gcb .SetFileOffset (_fbe )}();_de =_eaf .NewReader (_ecef );_gcb ._ecagb =_ddc .NewReader (_de );_af .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_afc :=map[int ]int64 {};for _fe :=0;_fe < int (*N );_fe ++{_gcb .skipSpaces ();_dg ,_bg :=_gcb .parseNumber ();if _bg !=nil {return nil ,_bg ;};_eca ,_gcba :=_dg .(*PdfObjectInteger );if !_gcba {return nil ,_a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_gcb .skipSpaces ();_dg ,_bg =_gcb .parseNumber ();if _bg !=nil {return nil ,_bg ;};_gbg ,_gcba :=_dg .(*PdfObjectInteger );if !_gcba {return nil ,_a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_af .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eca ,*_gbg );_afc [int (*_eca )]=int64 (*_gb +*_gbg );};_ecd =objectStream {N :int (*N ),_ead :_ecef ,_gc :_afc };_gcb ._dgf [_bbf ]=_ecd ;}else {_ede :=_gcb .GetFileOffset ();defer func (){_gcb .SetFileOffset (_ede )}();_de =_eaf .NewReader (_ecd ._ead );_gcb ._ecagb =_ddc .NewReader (_de );};_cg :=_ecd ._gc [_ab ];_af .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ab ,_cg );_de .Seek (_cg ,_ea .SEEK_SET );_gcb ._ecagb =_ddc .NewReader (_de );_dga ,_ :=_gcb ._ecagb .Peek (100);_af .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dga ));_da ,_ebf :=_gcb .parseObject ();if _ebf !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ebf );return nil ,_ebf ;};if _da ==nil {return nil ,_a .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_eafe :=PdfIndirectObject {};_eafe .ObjectNumber =int64 (_ab );_eafe .PdfObject =_da ;return &_eafe ,nil ;};

// DecodeStream implements ASCII hex decoding.
func (_gdge *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gdge .DecodeBytes (streamObj .Stream );};func (_gfea *PdfCrypt )isEncrypted (_eace PdfObject )bool {_ ,_defa :=_gfea ._afd [_eace ];if _defa {_af .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_af .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_aegb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _aegb ._abga };

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_aagf *FlateEncoder )SetPredictor (columns int ){_aagf .Predictor =11;_aagf .Columns =columns };func _cggd (_bbbce string )(int ,int ,error ){_acbg :=_agcc .FindStringSubmatch (_bbbce );if len (_acbg )< 3{return 0,0,_a .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bacd ,_ :=_c .Atoi (_acbg [1]);_abgcb ,_ :=_c .Atoi (_acbg [2]);return _bacd ,_abgcb ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func _gcaae ()string {return _af .Version };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_dddb *JBIG2Encoder )DecodeImages (encoded []byte )([]_eb .Image ,error ){const _egedd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_cgea ,_efdf :=_ece .Decode (encoded ,_ece .Parameters {},_dddb .Globals .ToDocumentGlobals ());if _efdf !=nil {return nil ,_fg .Wrap (_efdf ,_egedd ,"");};_bbea ,_efdf :=_cgea .PageNumber ();if _efdf !=nil {return nil ,_fg .Wrap (_efdf ,_egedd ,"");};_aaff :=[]_eb .Image {};var _fefg _eb .Image ;for _geed :=1;_geed <=_bbea ;_geed ++{_fefg ,_efdf =_cgea .DecodePageImage (_geed );if _efdf !=nil {return nil ,_fg .Wrapf (_efdf ,_egedd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_geed );};_aaff =append (_aaff ,_fefg );};return _aaff ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// String returns a descriptive information string about the encryption method used.
func (_ebbf *PdfCrypt )String ()string {if _ebbf ==nil {return "";};_dgaf :=_ebbf ._bbbb .Filter +"\u0020\u002d\u0020";if _ebbf ._bbbb .V ==0{_dgaf +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _ebbf ._bbbb .V ==1{_dgaf +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ebbf ._bbbb .V ==2{_dgaf +=_ac .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ebbf ._bbbb .Length );}else if _ebbf ._bbbb .V ==3{_dgaf +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _ebbf ._bbbb .V >=4{_dgaf +=_ac .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ebbf ._ebb ,_ebbf ._eab );_dgaf +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _gfbc ,_cceb :=range _ebbf ._aea {_dgaf +=_ac .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_gfbc ,_cceb .Name (),_cceb .KeyLength ());};};_ada :=_ebbf .GetAccessPermissions ();_dgaf +=_ac .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_ada );return _dgaf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_egc *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_ccg :=MakeDict ();_ccg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egc .GetFilterName ()));return _ccg ;};func _bgcb (_bebd PdfObject ,_daeb int ,_ebece map[PdfObject ]struct{})error {_af .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_daeb );if _ ,_dfaeb :=_ebece [_bebd ];_dfaeb {_af .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ebece [_bebd ]=struct{}{};switch _gdfee :=_bebd .(type ){case *PdfIndirectObject :_dddad :=_gdfee ;_af .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_dddad );_af .Log .Trace ("\u002d\u0020\u0025\u0073",_dddad .PdfObject );return _bgcb (_dddad .PdfObject ,_daeb +1,_ebece );case *PdfObjectStream :_aeffg :=_gdfee ;return _bgcb (_aeffg .PdfObjectDictionary ,_daeb +1,_ebece );case *PdfObjectDictionary :_ccde :=_gdfee ;_af .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_ccde );for _ ,_eeae :=range _ccde .Keys (){_aage :=_ccde .Get (_eeae );if _cedb ,_fbed :=_aage .(*PdfObjectReference );_fbed {_egaf :=_cedb .Resolve ();_ccde .Set (_eeae ,_egaf );_fdcfc :=_bgcb (_egaf ,_daeb +1,_ebece );if _fdcfc !=nil {return _fdcfc ;};}else {_bcccc :=_bgcb (_aage ,_daeb +1,_ebece );if _bcccc !=nil {return _bcccc ;};};};return nil ;case *PdfObjectArray :_adfc :=_gdfee ;_af .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_adfc );for _aaca ,_acge :=range _adfc .Elements (){if _gbfc ,_ccag :=_acge .(*PdfObjectReference );_ccag {_gdabf :=_gbfc .Resolve ();_adfc .Set (_aaca ,_gdabf );_bcdbc :=_bgcb (_gdabf ,_daeb +1,_ebece );if _bcdbc !=nil {return _bcdbc ;};}else {_gacc :=_bgcb (_acge ,_daeb +1,_ebece );if _gacc !=nil {return _gacc ;};};};return nil ;case *PdfObjectReference :_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _a .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_ecec *MultiEncoder )AddEncoder (encoder StreamEncoder ){_ecec ._fab =append (_ecec ._fab ,encoder );};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_deeg *PdfObjectInteger ,_eaec bool ){_deeg ,_eaec =TraceToDirectObject (obj ).(*PdfObjectInteger );return _deeg ,_eaec ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bdcac :=MultiEncoder {};_bdcac ._fab =[]StreamEncoder {};return &_bdcac ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cgeg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_dabb *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dabb .DecodeBytes (streamObj .Stream );};

// Len returns the number of elements in the streams.
func (_dgbagg *PdfObjectStreams )Len ()int {if _dgbagg ==nil {return 0;};return len (_dgbagg ._afdf );};func (_cbdg *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cbdg ._fefb {return nil ,_ac .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_cbdg ._fefb =true ;_cbdg ._eagbg .Seek (0,_ea .SEEK_SET );_cbdg ._ecagb =_ddc .NewReader (_cbdg ._eagbg );_faba :=20;_eefa :=make ([]byte ,_faba );_adcab :=XrefTable {};_adcab .ObjectMap =make (map[int ]XrefObject );for {_fede ,_gdee :=_cbdg ._ecagb .ReadByte ();if _gdee !=nil {if _gdee ==_e .EOF {break ;}else {return nil ,_gdee ;};};if _fede =='j'&&_eefa [_faba -1]=='b'&&_eefa [_faba -2]=='o'&&IsWhiteSpace (_eefa [_faba -3]){_afdb :=_faba -4;for IsWhiteSpace (_eefa [_afdb ])&&_afdb > 0{_afdb --;};if _afdb ==0||!IsDecimalDigit (_eefa [_afdb ]){continue ;};for IsDecimalDigit (_eefa [_afdb ])&&_afdb > 0{_afdb --;};if _afdb ==0||!IsWhiteSpace (_eefa [_afdb ]){continue ;};for IsWhiteSpace (_eefa [_afdb ])&&_afdb > 0{_afdb --;};if _afdb ==0||!IsDecimalDigit (_eefa [_afdb ]){continue ;};for IsDecimalDigit (_eefa [_afdb ])&&_afdb > 0{_afdb --;};if _afdb ==0{continue ;};_dbda :=_cbdg .GetFileOffset ()-int64 (_faba -_afdb );_aefff :=append (_eefa [_afdb +1:],_fede );_afgb ,_adcb ,_dgff :=_cggd (string (_aefff ));if _dgff !=nil {_af .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_dgff );return nil ,_dgff ;};if _fcfce ,_gcad :=_adcab .ObjectMap [_afgb ];!_gcad ||_fcfce .Generation < _adcb {_babd :=XrefObject {};_babd .XType =XrefTypeTableEntry ;_babd .ObjectNumber =int (_afgb );_babd .Generation =int (_adcb );_babd .Offset =_dbda ;_adcab .ObjectMap [_afgb ]=_babd ;};};_eefa =append (_eefa [1:_faba ],_fede );};return &_adcab ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_cgef *PdfParser )GetXrefOffset ()int64 {return _cgef ._cgcdf };const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// WriteString outputs the object as it is to be written to file.
func (_adee *PdfObjectStream )WriteString ()string {var _cdfab _dd .Builder ;_cdfab .WriteString (_c .FormatInt (_adee .ObjectNumber ,10));_cdfab .WriteString ("\u0020\u0030\u0020\u0052");return _cdfab .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bcb *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func _fecb (_cgdf *PdfObjectDictionary )(_cdegf *_dcad .ImageBase ){var (_bdcd *PdfObjectInteger ;_cdga bool ;);if _bdcd ,_cdga =_cgdf .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_cdga {_cdegf =&_dcad .ImageBase {Width :int (*_bdcd )};}else {return nil ;};if _bdcd ,_cdga =_cgdf .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_cdga {_cdegf .Height =int (*_bdcd );};if _bdcd ,_cdga =_cgdf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_cdga {_cdegf .BitsPerComponent =int (*_bdcd );};if _bdcd ,_cdga =_cgdf .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_cdga {_cdegf .ColorComponents =int (*_bdcd );};return _cdegf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_affc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_affc ._fab )==0{return nil ;};if len (_affc ._fab )==1{return _affc ._fab [0].MakeDecodeParams ();};_eded :=MakeArray ();for _ ,_afaa :=range _affc ._fab {_abgfc :=_afaa .MakeDecodeParams ();if _abgfc ==nil {_eded .Append (MakeNull ());}else {_eded .Append (_abgfc );};};return _eded ;};

// UpdateParams updates the parameter values of the encoder.
func (_eaba *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_ecag ,_bgb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bgb ==nil {_eaba .Predictor =int (_ecag );};_bff ,_bgb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bgb ==nil {_eaba .BitsPerComponent =int (_bff );};_cff ,_bgb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bgb ==nil {_eaba .Columns =int (_cff );};_ffcg ,_bgb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bgb ==nil {_eaba .Colors =int (_ffcg );};_aed ,_bgb :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bgb ==nil {_eaba .EarlyChange =int (_aed );};};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_ddf :=&DCTEncoder {};_ddf .ColorComponents =3;_ddf .BitsPerComponent =8;_ddf .Quality =DefaultJPEGQuality ;return _ddf ;};

// WriteString outputs the object as it is to be written to file.
func (_dgad *PdfObjectBool )WriteString ()string {if *_dgad {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_begf *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gdgc :=MakeDict ();_gdgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_begf .GetFilterName ()));_aggg :=_begf .MakeDecodeParams ();if _aggg !=nil {_gdgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aggg );};_gdgc .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_begf .EarlyChange )));return _gdgc ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ffcd *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ffcd ._eagbg .Seek (offset ,_e .SeekStart );_ffcd ._ecagb =_ddc .NewReader (_ffcd ._eagbg );};func (_efcb *PdfParser )resolveReference (_ecdg *PdfObjectReference )(PdfObject ,bool ,error ){_ccaca ,_cgfc :=_efcb .ObjCache [int (_ecdg .ObjectNumber )];if _cgfc {return _ccaca ,true ,nil ;};_egfb ,_dcdf :=_efcb .LookupByReference (*_ecdg );if _dcdf !=nil {return nil ,false ,_dcdf ;};_efcb .ObjCache [int (_ecdg .ObjectNumber )]=_egfb ;return _egfb ,false ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cgf *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_bfcg ,_ecab :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecab ==nil {_cgf .ColorComponents =int (_bfcg );};_fgcg ,_ecab :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecab ==nil {_cgf .BitsPerComponent =int (_fgcg );};_afcg ,_ecab :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecab ==nil {_cgf .Width =int (_afcg );};_feac ,_ecab :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ecab ==nil {_cgf .Height =int (_feac );};_efce ,_ecab :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _ecab ==nil {_cgf .Quality =int (_efce );};};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_dcafa map[PdfObjectName ]PdfObject ;_beda []PdfObjectName ;_adfg *PdfParser ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_fbag *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_af .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gac :=_eaf .NewReader (encoded );_ebfd ,_dfab :=_ca .NewReader (_gac );if _dfab !=nil {_af .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_dfab );_af .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_dfab ;};defer _ebfd .Close ();var _eee _eaf .Buffer ;_eee .ReadFrom (_ebfd );return _eee .Bytes (),nil ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_agge *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_aggef :=data ;var _adf error ;for _eagdd :=len (_agge ._fab )-1;_eagdd >=0;_eagdd --{_ededc :=_agge ._fab [_eagdd ];_aggef ,_adf =_ededc .EncodeBytes (_aggef );if _adf !=nil {return nil ,_adf ;};};return _aggef ,nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fgff *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_bggdb *PdfParser )IsEncrypted ()(bool ,error ){if _bggdb ._fdab !=nil {return true ,nil ;}else if _bggdb ._abga ==nil {return false ,nil ;};_af .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_bddc :=_bggdb ._abga .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bddc ==nil {return false ,nil ;};_af .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_afdcf *PdfObjectDictionary ;);switch _fbfg :=_bddc .(type ){case *PdfObjectDictionary :_afdcf =_fbfg ;case *PdfObjectReference :_af .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_fbfg );_badbd ,_cdcgg :=_bggdb .LookupByReference (*_fbfg );_af .Log .Trace ("\u0031\u003a\u0020%\u0071",_badbd );if _cdcgg !=nil {return false ,_cdcgg ;};_bfgcg ,_dccc :=_badbd .(*PdfIndirectObject );if !_dccc {_af .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_ffbd ,_dccc :=_bfgcg .PdfObject .(*PdfObjectDictionary );_af .Log .Trace ("\u0032\u003a\u0020%\u0071",_ffbd );if !_dccc {return false ,_a .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_afdcf =_ffbd ;case *PdfObjectNull :_af .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ac .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_fbfg );};_agba ,_decc :=PdfCryptNewDecrypt (_bggdb ,_afdcf ,_bggdb ._abga );if _decc !=nil {return false ,_decc ;};for _ ,_bdfg :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_fgee :=_bggdb ._abga .Get (PdfObjectName (_bdfg ));if _fgee ==nil {continue ;};switch _fagdbf :=_fgee .(type ){case *PdfObjectReference :_agba ._dfg [int (_fagdbf .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_agba ._gggb [_fagdbf ]=true ;_agba ._dfg [int (_fagdbf .ObjectNumber )]=struct{}{};};};_bggdb ._fdab =_agba ;_af .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_agba );return true ,nil ;};func (_ccee *PdfParser )parseObject ()(PdfObject ,error ){_af .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ccee .skipSpaces ();for {_ddff ,_gaeb :=_ccee ._ecagb .Peek (2);if _gaeb !=nil {if _gaeb !=_e .EOF ||len (_ddff )==0{return nil ,_gaeb ;};if len (_ddff )==1{_ddff =append (_ddff ,' ');};};_af .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ddff ));if _ddff [0]=='/'{_debc ,_bdad :=_ccee .parseName ();_af .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_debc );return &_debc ,_bdad ;}else if _ddff [0]=='('{_af .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_deed ,_cece :=_ccee .parseString ();return _deed ,_cece ;}else if _ddff [0]=='['{_af .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_gbbb ,_afe :=_ccee .parseArray ();return _gbbb ,_afe ;}else if (_ddff [0]=='<')&&(_ddff [1]=='<'){_af .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_cfde ,_ggad :=_ccee .ParseDict ();return _cfde ,_ggad ;}else if _ddff [0]=='<'{_af .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_dgdb ,_efde :=_ccee .parseHexString ();return _dgdb ,_efde ;}else if _ddff [0]=='%'{_ccee .readComment ();_ccee .skipSpaces ();}else {_af .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ddff ,_ =_ccee ._ecagb .Peek (15);_fge :=string (_ddff );_af .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_fge );if (len (_fge )> 3)&&(_fge [:4]=="\u006e\u0075\u006c\u006c"){_ebag ,_adfbe :=_ccee .parseNull ();return &_ebag ,_adfbe ;}else if (len (_fge )> 4)&&(_fge [:5]=="\u0066\u0061\u006cs\u0065"){_acfe ,_cfee :=_ccee .parseBool ();return &_acfe ,_cfee ;}else if (len (_fge )> 3)&&(_fge [:4]=="\u0074\u0072\u0075\u0065"){_gbgfec ,_bcadc :=_ccee .parseBool ();return &_gbgfec ,_bcadc ;};_ffaf :=_ggbd .FindStringSubmatch (string (_fge ));if len (_ffaf )> 1{_ddff ,_ =_ccee ._ecagb .ReadBytes ('R');_af .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ddff [:]));_ggcf ,_bgfag :=_bggc (string (_ddff ));_ggcf ._gfdce =_ccee ;return &_ggcf ,_bgfag ;};_dbee :=_dedd .FindStringSubmatch (string (_fge ));if len (_dbee )> 1{_af .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cgge ,_fdfa :=_ccee .parseNumber ();return _cgge ,_fdfa ;};_dbee =_gede .FindStringSubmatch (string (_fge ));if len (_dbee )> 1{_af .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_af .Log .Trace ("\u0025\u0020\u0073",_dbee );_afac ,_adaaf :=_ccee .parseNumber ();return _afac ,_adaaf ;};_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_fge );return nil ,_a .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};func (_gdfed *offsetReader )Read (p []byte )(_fbbg int ,_geab error ){return _gdfed ._geea .Read (p )};

// GetFilterName returns the name of the encoding filter.
func (_dgcf *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_cdcg *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dbaf *PdfObjectDictionary ;_cdef ,_edefa :=_cdcg .readTextLine ();if _edefa !=nil {return nil ,_edefa ;};_af .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cdef );_gagb :=-1;_gfa :=0;_acaa :=false ;_dddbc :="";for {_cdcg .skipSpaces ();_ ,_agf :=_cdcg ._ecagb .Peek (1);if _agf !=nil {return nil ,_agf ;};_cdef ,_agf =_cdcg .readTextLine ();if _agf !=nil {return nil ,_agf ;};_fcb :=_edcg .FindStringSubmatch (_cdef );if len (_fcb )==0{_cgcdff :=len (_dddbc )> 0;_dddbc +=_cdef +"\u000a";if _cgcdff {_fcb =_edcg .FindStringSubmatch (_dddbc );};};if len (_fcb )==3{_fgcgb ,_ :=_c .Atoi (_fcb [1]);_eebb ,_ :=_c .Atoi (_fcb [2]);_gagb =_fgcgb ;_gfa =_eebb ;_acaa =true ;_dddbc ="";_af .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gagb ,_gfa );continue ;};_edbac :=_becd .FindStringSubmatch (_cdef );if len (_edbac )==4{if _acaa ==false {_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_a .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_aafa ,_ :=_c .ParseInt (_edbac [1],10,64);_gafc ,_ :=_c .Atoi (_edbac [2]);_bcdf :=_edbac [3];_dddbc ="";if _dd .ToLower (_bcdf )=="\u006e"&&_aafa > 1{_fffb ,_deedb :=_cdcg ._bdda .ObjectMap [_gagb ];if !_deedb ||_gafc > _fffb .Generation {_ffgb :=XrefObject {ObjectNumber :_gagb ,XType :XrefTypeTableEntry ,Offset :_aafa ,Generation :_gafc };_cdcg ._bdda .ObjectMap [_gagb ]=_ffgb ;};};_gagb ++;continue ;};if (len (_cdef )> 6)&&(_cdef [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_af .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_cdef );if len (_cdef )> 9{_gfgg :=_cdcg .GetFileOffset ();_cdcg .SetFileOffset (_gfgg -int64 (len (_cdef ))+7);};_cdcg .skipSpaces ();_cdcg .skipComments ();_af .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_af .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_cdef );_dbaf ,_agf =_cdcg .ParseDict ();_af .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _agf !=nil {_af .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_agf );return nil ,_agf ;};break ;};if _cdef =="\u0025\u0025\u0045O\u0046"{_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_a .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_af .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_cdef );};_af .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _cdcg ._dffg ==nil {_ceddc :=XrefTypeTableEntry ;_cdcg ._dffg =&_ceddc ;};return _dbaf ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_aeag *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_gffg *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_e .SeekStart {offset +=_gffg ._gged ;};_ceab ,_defac :=_gffg ._geea .Seek (offset ,whence );if _defac !=nil {return _ceab ,_defac ;};if whence ==_e .SeekCurrent {_ceab -=_gffg ._gged ;};if _ceab < 0{return 0,_a .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _ceab ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ddc .Reader )(PdfObject ,error ){_ffgf :=false ;_cfbd :=true ;var _fdba _eaf .Buffer ;for {if _af .Log .IsLogLevel (_af .LogLevelTrace ){_af .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fdba .String ());};_fgef ,_fbbgc :=buf .Peek (1);if _fbbgc ==_e .EOF {break ;};if _fbbgc !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_fbbgc );return nil ,_fbbgc ;};if _cfbd &&(_fgef [0]=='-'||_fgef [0]=='+'){_afge ,_ :=buf .ReadByte ();_fdba .WriteByte (_afge );_cfbd =false ;}else if IsDecimalDigit (_fgef [0]){_egbf ,_ :=buf .ReadByte ();_fdba .WriteByte (_egbf );}else if _fgef [0]=='.'{_bfcgd ,_ :=buf .ReadByte ();_fdba .WriteByte (_bfcgd );_ffgf =true ;}else if _fgef [0]=='e'||_fgef [0]=='E'{_eabf ,_ :=buf .ReadByte ();_fdba .WriteByte (_eabf );_ffgf =true ;_cfbd =true ;}else {break ;};};var _fagdbe PdfObject ;if _ffgf {_bggb ,_egfcg :=_c .ParseFloat (_fdba .String (),64);if _egfcg !=nil {_af .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fdba .String (),_egfcg );_bggb =0.0;_egfcg =nil ;};_afdgc :=PdfObjectFloat (_bggb );_fagdbe =&_afdgc ;}else {_abge ,_ccbc :=_c .ParseInt (_fdba .String (),10,64);if _ccbc !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fdba .String (),_ccbc );_abge =0;_ccbc =nil ;};_aebcc :=PdfObjectInteger (_abge );_fagdbe =&_aebcc ;};return _fagdbe ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egga *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_cbfd *PdfParser )parseString ()(*PdfObjectString ,error ){_cbfd ._ecagb .ReadByte ();var _abdf _eaf .Buffer ;_fggf :=1;for {_bag ,_fdge :=_cbfd ._ecagb .Peek (1);if _fdge !=nil {return MakeString (_abdf .String ()),_fdge ;};if _bag [0]=='\\'{_cbfd ._ecagb .ReadByte ();_cbece ,_ffb :=_cbfd ._ecagb .ReadByte ();if _ffb !=nil {return MakeString (_abdf .String ()),_ffb ;};if IsOctalDigit (_cbece ){_eeaa ,_ccdbg :=_cbfd ._ecagb .Peek (2);if _ccdbg !=nil {return MakeString (_abdf .String ()),_ccdbg ;};var _ebcaa []byte ;_ebcaa =append (_ebcaa ,_cbece );for _ ,_gcg :=range _eeaa {if IsOctalDigit (_gcg ){_ebcaa =append (_ebcaa ,_gcg );}else {break ;};};_cbfd ._ecagb .Discard (len (_ebcaa )-1);_af .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_ebcaa );_cdfda ,_ccdbg :=_c .ParseUint (string (_ebcaa ),8,32);if _ccdbg !=nil {return MakeString (_abdf .String ()),_ccdbg ;};_abdf .WriteByte (byte (_cdfda ));continue ;};switch _cbece {case 'n':_abdf .WriteRune ('\n');case 'r':_abdf .WriteRune ('\r');case 't':_abdf .WriteRune ('\t');case 'b':_abdf .WriteRune ('\b');case 'f':_abdf .WriteRune ('\f');case '(':_abdf .WriteRune ('(');case ')':_abdf .WriteRune (')');case '\\':_abdf .WriteRune ('\\');};continue ;}else if _bag [0]=='('{_fggf ++;}else if _bag [0]==')'{_fggf --;if _fggf ==0{_cbfd ._ecagb .ReadByte ();break ;};};_eaced ,_ :=_cbfd ._ecagb .ReadByte ();_abdf .WriteByte (_eaced );};return MakeString (_abdf .String ()),nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_egeeg *PdfParser )GetXrefType ()*xrefType {return _egeeg ._dffg };

// GetFilterName returns the name of the encoding filter.
func (_ddg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// GetFilterName returns the name of the encoding filter.
func (_ffd *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// UpdateParams updates the parameter values of the encoder.
func (_fdff *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _ecbc ,_dgga :=GetNumberAsInt64 (params .Get ("\u004b"));_dgga ==nil {_fdff .K =int (_ecbc );};if _dfe ,_gaf :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gaf ==nil {_fdff .Columns =int (_dfe );}else if _dfe ,_gaf =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_gaf ==nil {_fdff .Columns =int (_dfe );};if _ceb ,_eaad :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eaad ==nil {_fdff .BlackIs1 =_ceb > 0;}else {if _cgad ,_abade :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_abade {_fdff .BlackIs1 =_cgad ;}else {if _gbc ,_geba :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_geba {_faa ,_fcdc :=_gbc .ToIntegerArray ();if _fcdc ==nil {_fdff .BlackIs1 =_faa [0]==1&&_faa [1]==0;};};};};if _ggbg ,_ffdd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ffdd ==nil {_fdff .EncodedByteAlign =_ggbg > 0;}else {if _fgfa ,_fgg :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fgg {_fdff .EncodedByteAlign =_fgfa ;};};if _eedb ,_beee :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_beee ==nil {_fdff .EndOfLine =_eedb > 0;}else {if _cacf ,_cefc :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cefc {_fdff .EndOfLine =_cacf ;};};if _abgbd ,_bffd :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_bffd ==nil {_fdff .Rows =int (_abgbd );}else if _abgbd ,_bffd =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bffd ==nil {_fdff .Rows =int (_abgbd );};if _dgbe ,_cdfd :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cdfd ==nil {_fdff .EndOfBlock =_dgbe > 0;}else {if _acac ,_ggage :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ggage {_fdff .EndOfBlock =_acac ;};};if _egge ,_abbg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_abbg !=nil {_fdff .DamagedRowsBeforeError =int (_egge );};};

// Clear resets the dictionary to an empty state.
func (_baaf *PdfObjectDictionary )Clear (){_baaf ._beda =[]PdfObjectName {};_baaf ._dcafa =map[PdfObjectName ]PdfObject {};};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_eagbf string ;_geef bool ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_efgf *PdfObjectString )Decoded ()string {if _efgf ==nil {return "";};_fcfd :=[]byte (_efgf ._eagbf );if len (_fcfd )>=2&&_fcfd [0]==0xFE&&_fcfd [1]==0xFF{return _ec .UTF16ToString (_fcfd [2:]);};return _ec .PDFDocEncodingToString (_fcfd );};

// WriteString outputs the object as it is to be written to file.
func (_fgdgc *PdfIndirectObject )WriteString ()string {var _gega _dd .Builder ;_gega .WriteString (_c .FormatInt (_fgdgc .ObjectNumber ,10));_gega .WriteString ("\u0020\u0030\u0020\u0052");return _gega .String ();};func (_ebfc *PdfCrypt )makeKey (_cbfg string ,_afdg ,_eda uint32 ,_gggc []byte )([]byte ,error ){_ddd ,_dcc :=_ebfc ._aea [_cbfg ];if !_dcc {return nil ,_ac .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cbfg );};return _ddd .MakeKey (_afdg ,_eda ,_gggc );};func (_dccd *PdfParser )readTextLine ()(string ,error ){var _caaa _eaf .Buffer ;for {_becc ,_ceed :=_dccd ._ecagb .Peek (1);if _ceed !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ceed .Error ());return _caaa .String (),_ceed ;};if (_becc [0]!='\r')&&(_becc [0]!='\n'){_aabg ,_ :=_dccd ._ecagb .ReadByte ();_caaa .WriteByte (_aabg );}else {break ;};};return _caaa .String (),nil ;};

// DecodeStream implements ASCII85 stream decoding.
func (_bgbe *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bgbe .DecodeBytes (streamObj .Stream );};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gaa *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gaa .isEncrypted (obj ){return nil ;};switch _fce :=obj .(type ){case *PdfIndirectObject :_gaa ._afd [_fce ]=true ;_af .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fce .ObjectNumber ,_fce .GenerationNumber );_abg :=_fce .ObjectNumber ;_bcd :=_fce .GenerationNumber ;_ded :=_gaa .Encrypt (_fce .PdfObject ,_abg ,_bcd );if _ded !=nil {return _ded ;};return nil ;case *PdfObjectStream :_gaa ._afd [_fce ]=true ;_gbgfe :=_fce .PdfObjectDictionary ;if _aacd ,_cfg :=_gbgfe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cfg &&*_aacd =="\u0058\u0052\u0065\u0066"{return nil ;};_egd :=_fce .ObjectNumber ;_adad :=_fce .GenerationNumber ;_af .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_egd ,_adad );_egbg :=_fbc ;if _gaa ._bbbb .V >=4{_egbg =_gaa ._ebb ;_af .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gaa ._ebb );if _dccb ,_bfe :=_gbgfe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bfe {if _dcaf ,_cbbd :=GetName (_dccb .Get (0));_cbbd {if *_dcaf =="\u0043\u0072\u0079p\u0074"{_egbg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bdc ,_bdcb :=_gbgfe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_bdcb {if _daa ,_dcd :=_bdc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_dcd {if _ ,_bcc :=_gaa ._aea [string (*_daa )];_bcc {_af .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_daa );_egbg =string (*_daa );};};};};};};_af .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_egbg );if _egbg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bafd :=_gaa .Encrypt (_fce .PdfObjectDictionary ,_egd ,_adad );if _bafd !=nil {return _bafd ;};_gdca ,_bafd :=_gaa .makeKey (_egbg ,uint32 (_egd ),uint32 (_adad ),_gaa ._bdb );if _bafd !=nil {return _bafd ;};_fce .Stream ,_bafd =_gaa .encryptBytes (_fce .Stream ,_egbg ,_gdca );if _bafd !=nil {return _bafd ;};_gbgfe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fce .Stream ))));return nil ;case *PdfObjectString :_af .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ebec :=_fbc ;if _gaa ._bbbb .V >=4{_af .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gaa ._eab );if _gaa ._eab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ebec =_gaa ._eab ;};_fcge ,_fbaa :=_gaa .makeKey (_ebec ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gaa ._bdb );if _fbaa !=nil {return _fbaa ;};_dgc :=_fce .Str ();_bbg :=make ([]byte ,len (_dgc ));for _gfgd :=0;_gfgd < len (_dgc );_gfgd ++{_bbg [_gfgd ]=_dgc [_gfgd ];};_af .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bbg ,_bbg );_bbg ,_fbaa =_gaa .encryptBytes (_bbg ,_ebec ,_fcge );if _fbaa !=nil {return _fbaa ;};_fce ._eagbf =string (_bbg );return nil ;case *PdfObjectArray :for _ ,_eegc :=range _fce .Elements (){_dgcg :=_gaa .Encrypt (_eegc ,parentObjNum ,parentGenNum );if _dgcg !=nil {return _dgcg ;};};return nil ;case *PdfObjectDictionary :_adbf :=false ;if _egdd :=_fce .Get ("\u0054\u0079\u0070\u0065");_egdd !=nil {_dee ,_dgde :=_egdd .(*PdfObjectName );if _dgde &&*_dee =="\u0053\u0069\u0067"{_adbf =true ;};};for _ ,_bdca :=range _fce .Keys (){_bggd :=_fce .Get (_bdca );if _adbf &&string (_bdca )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bdca )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bdca )!="\u0050\u0072\u0065\u0076"&&string (_bdca )!="\u004c\u0061\u0073\u0074"{_afda :=_gaa .Encrypt (_bggd ,parentObjNum ,parentGenNum );if _afda !=nil {return _afda ;};};};return nil ;};return nil ;};func (_ccga *PdfParser )readComment ()(string ,error ){var _cfgb _eaf .Buffer ;_ ,_bggfe :=_ccga .skipSpaces ();if _bggfe !=nil {return _cfgb .String (),_bggfe ;};_dacc :=true ;for {_eaddf ,_aeba :=_ccga ._ecagb .Peek (1);if _aeba !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_aeba .Error ());return _cfgb .String (),_aeba ;};if _dacc &&_eaddf [0]!='%'{return _cfgb .String (),_a .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_dacc =false ;if (_eaddf [0]!='\r')&&(_eaddf [0]!='\n'){_ggdg ,_ :=_ccga ._ecagb .ReadByte ();_cfgb .WriteByte (_ggdg );}else {break ;};};return _cfgb .String (),nil ;};var _ggbd =_db .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// WriteString outputs the object as it is to be written to file.
func (_gagc *PdfObjectStreams )WriteString ()string {var _gegg _dd .Builder ;_gegg .WriteString (_c .FormatInt (_gagc .ObjectNumber ,10));_gegg .WriteString ("\u0020\u0030\u0020\u0052");return _gegg .String ();};func (_ege *PdfParser )lookupByNumber (_fba int ,_fga bool )(PdfObject ,bool ,error ){_efc ,_bae :=_ege .ObjCache [_fba ];if _bae {_af .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fba );return _efc ,false ,nil ;};_gga ,_bae :=_ege ._bdda .ObjectMap [_fba ];if !_bae {_af .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _ee PdfObjectNull ;return &_ee ,false ,nil ;};_af .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fba );if _gga .XType ==XrefTypeTableEntry {_af .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_gga .ObjectNumber );_af .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_gga .Generation );_af .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_gga .Offset );_ege ._eagbg .Seek (_gga .Offset ,_ea .SEEK_SET );_ege ._ecagb =_ddc .NewReader (_ege ._eagbg );_acd ,_cgg :=_ege .ParseIndirectObject ();if _cgg !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cgg );if _fga {_af .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ccf ,_cee :=_ege .repairRebuildXrefsTopDown ();if _cee !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_cee );return nil ,false ,_cee ;};_ege ._bdda =*_ccf ;return _ege .lookupByNumber (_fba ,false );};return nil ,false ,_cgg ;};if _fga {_ag ,_ ,_ :=_bec (_acd );if int (_ag )!=_fba {_af .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_bee :=_ege .rebuildXrefTable ();if _bee !=nil {return nil ,false ,_bee ;};_ege .ObjCache =objectCache {};return _ege .lookupByNumberWrapper (_fba ,false );};};_af .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ege .ObjCache [_fba ]=_acd ;return _acd ,false ,nil ;}else if _gga .XType ==XrefTypeObjectStream {_af .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_af .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_af .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_gga .OsObjNumber ,_gga .OsObjIndex );if _gga .OsObjNumber ==_fba {_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_a .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_cgb :=_ege ._bdda .ObjectMap [_gga .OsObjNumber ];_cgb {_ebd ,_ccc :=_ege .lookupObjectViaOS (_gga .OsObjNumber ,_fba );if _ccc !=nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_ccc );return nil ,true ,_ccc ;};_af .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ege .ObjCache [_fba ]=_ebd ;if _ege ._fdab !=nil {_ege ._fdab ._gggb [_ebd ]=true ;};return _ebd ,true ,nil ;};_af .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_a .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_a .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_agbf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_agbf .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_agfc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_bgbeb ,_eebd :=_agfc ._dcafa [key ];if !_eebd {return nil ;};return _bgbeb ;};func _bbgfg (_eabeg int )int {if _eabeg < 0{return -_eabeg ;};return _eabeg ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_afgg :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _afgg ==nil {return NewRawEncoder (),nil ;};if _ ,_fbcgd :=_afgg .(*PdfObjectNull );_fbcgd {return NewRawEncoder (),nil ;};_fcbd ,_bfaea :=_afgg .(*PdfObjectName );if !_bfaea {_abcb ,_gefd :=_afgg .(*PdfObjectArray );if !_gefd {return nil ,_ac .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _abcb .Len ()==0{return NewRawEncoder (),nil ;};if _abcb .Len ()!=1{_gfecg ,_bedf :=_acb (streamObj );if _bedf !=nil {_af .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bedf );return nil ,_bedf ;};_af .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_gfecg );return _gfecg ,nil ;};_afgg =_abcb .Get (0);_fcbd ,_gefd =_afgg .(*PdfObjectName );if !_gefd {return nil ,_ac .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_fcbd {case StreamEncodingFilterNameFlate :return _gag (streamObj ,nil );case StreamEncodingFilterNameLZW :return _ecdf (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bdf (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _affg (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _dgdg (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _acfc (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ac .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_fcbd );};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cafe :=PdfObjectInteger (val );return &_cafe };

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_ffgg *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_af .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_baac :=MakeDict ();_baac ._adfg =_ffgg ;_cccbd ,_ :=_ffgg ._ecagb .ReadByte ();if _cccbd !='<'{return nil ,_a .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_cccbd ,_ =_ffgg ._ecagb .ReadByte ();if _cccbd !='<'{return nil ,_a .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_ffgg .skipSpaces ();_ffgg .skipComments ();_ggeg ,_aceb :=_ffgg ._ecagb .Peek (2);if _aceb !=nil {return nil ,_aceb ;};_af .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ggeg ),string (_ggeg ));if (_ggeg [0]=='>')&&(_ggeg [1]=='>'){_af .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_ffgg ._ecagb .ReadByte ();_ffgg ._ecagb .ReadByte ();break ;};_af .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_egcf ,_aceb :=_ffgg .parseName ();_af .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_egcf );if _aceb !=nil {_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_aceb );return nil ,_aceb ;};if len (_egcf )> 4&&_egcf [len (_egcf )-4:]=="\u006e\u0075\u006c\u006c"{_cfcgc :=_egcf [0:len (_egcf )-4];_af .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_egcf );_af .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_cfcgc );_ffgg .skipSpaces ();_dgdgc ,_ :=_ffgg ._ecagb .Peek (1);if _dgdgc [0]=='/'{_baac .Set (_cfcgc ,MakeNull ());continue ;};};_ffgg .skipSpaces ();_fgeg ,_aceb :=_ffgg .parseObject ();if _aceb !=nil {return nil ,_aceb ;};_baac .Set (_egcf ,_fgeg );if _af .Log .IsLogLevel (_af .LogLevelTrace ){_af .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_egcf ,_fgeg .String ());};};_af .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _baac ,nil ;};func _affg (_egdfe *PdfObjectStream ,_geg *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_bbgbf *JBIG2Image )ToGoImage ()(_eb .Image ,error ){const _fdfed ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _bbgbf .Data ==nil {return nil ,_fg .Error (_fdfed ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bbgbf .Width ==0||_bbgbf .Height ==0{return nil ,_fg .Error (_fdfed ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_afde ,_agcg :=_dcad .NewImage (_bbgbf .Width ,_bbgbf .Height ,1,1,_bbgbf .Data ,nil ,nil );if _agcg !=nil {return nil ,_agcg ;};return _afde ,nil ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgff *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _egcd []int64 ;for _ ,_aee :=range _bgff .Elements (){if _ceace ,_bbfa :=_aee .(*PdfObjectInteger );_bbfa {_egcd =append (_egcd ,int64 (*_ceace ));}else {return nil ,ErrTypeError ;};};return _egcd ,nil ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_bagg int ,_ceaa bool ){_gdbc ,_ceaa :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _ceaa &&_gdbc !=nil {return int (*_gdbc ),true ;};return 0,false ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_gcbce *PdfObjectReference )GetParser ()*PdfParser {return _gcbce ._gfdce };func (_aae *PdfCrypt )isDecrypted (_gea PdfObject )bool {_ ,_gfbd :=_aae ._gggb [_gea ];if _gfbd {_af .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _dgb :=_gea .(type ){case *PdfObjectStream :if _aae ._cabf .R !=5{if _dbf ,_ccef :=_dgb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ccef &&*_dbf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_gfbd =_aae ._dfg [int (_dgb .ObjectNumber )];_gfbd {return true ;};switch _eefc :=_dgb .PdfObject .(type ){case *PdfObjectDictionary :_fa :=true ;for _ ,_geff :=range _gef {if _eefc .Get (_geff )==nil {_fa =false ;break ;};};if _fa {return true ;};};};_af .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_bgce *PdfParser )inspect ()(map[string ]int ,error ){_af .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_af .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_agab :=map[string ]int {};_fggbd :=0;_cfgda :=0;var _gbef []int ;for _bffc :=range _bgce ._bdda .ObjectMap {_gbef =append (_gbef ,_bffc );};_dc .Ints (_gbef );_bdbc :=0;for _ ,_agdfg :=range _gbef {_afce :=_bgce ._bdda .ObjectMap [_agdfg ];if _afce .ObjectNumber ==0{continue ;};_fggbd ++;_af .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_af .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_afce .ObjectNumber );_cacd ,_aacgfc :=_bgce .LookupByNumber (_afce .ObjectNumber );if _aacgfc !=nil {_af .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_afce .ObjectNumber ,_aacgfc );_cfgda ++;continue ;};_af .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_cacd );_gebd ,_afecd :=_cacd .(*PdfIndirectObject );if _afecd {_af .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_afce .ObjectNumber ,_gebd );_cbecec ,_gaga :=_gebd .PdfObject .(*PdfObjectDictionary );if _gaga {if _ceaaf ,_cdeb :=_cbecec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cdeb {_ebfae :=string (*_ceaaf );_af .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ebfae );_ ,_dabad :=_agab [_ebfae ];if _dabad {_agab [_ebfae ]++;}else {_agab [_ebfae ]=1;};}else if _dabeb ,_ggfdb :=_cbecec .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ggfdb {_fadb :=string (*_dabeb );_af .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_fadb );_ ,_bacfb :=_agab [_fadb ];if _bacfb {_agab [_fadb ]++;}else {_agab [_fadb ]=1;};};if _dbae ,_ccfdf :=_cbecec .Get ("\u0053").(*PdfObjectName );_ccfdf &&*_dbae =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gaaf :=_agab ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _gaaf {_agab ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_agab ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bddec ,_fbda :=_cacd .(*PdfObjectStream );_fbda {if _eaeaf ,_ddef :=_bddec .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ddef {_af .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_eaeaf );_aagfc :=string (*_eaeaf );if _ ,_cfcgcd :=_agab [_aagfc ];_cfcgcd {_agab [_aagfc ]++;}else {_agab [_aagfc ]=1;};};}else {_ecfc ,_cgaa :=_cacd .(*PdfObjectDictionary );if _cgaa {_deca ,_cebgd :=_ecfc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _cebgd {_efeb :=string (*_deca );_af .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_efeb );_agab [_efeb ]++;};};_af .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_afce .ObjectNumber ,_cacd );};_bdbc ++;};_af .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_af .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_af .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_fggbd );_af .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_cfgda );for _cgeeg ,_egfdd :=range _agab {_af .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_cgeeg ,_egfdd );};_af .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_bgce ._bdda .ObjectMap )< 1{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ac .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_ebge ,_ffdc :=_agab ["\u0046\u006f\u006e\u0074"];if !_ffdc ||_ebge < 2{_af .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_af .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _agab ,nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ggeb *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _dca .DecodeBytes (encoded ,_ece .Parameters {},_ggeb .Globals );};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _eb .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _bgeb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_fg .Error (_bgeb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_gdab uint8 ;_dfagd _dcad .Image ;_ggdd error ;);if bwThreshold ==JB2ImageAutoThreshold {_dfagd ,_ggdd =_dcad .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_fg .Error (_bgeb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_gdab =uint8 (255*bwThreshold );_dfagd ,_ggdd =_dcad .MonochromeThresholdConverter (_gdab ).Convert (i );};if _ggdd !=nil {return nil ,_ggdd ;};return _affe (_dfagd ),nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_dacd :=PdfObjectBool (val );return &_dacd };func (_daadc *PdfParser )repairSeekXrefMarker ()error {_deef ,_cgbc :=_daadc ._eagbg .Seek (0,_ea .SEEK_END );if _cgbc !=nil {return _cgbc ;};_acfce :=_db .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _bbgf int64 ;var _fdfc int64 =1000;for _bbgf < _deef {if _deef <=(_fdfc +_bbgf ){_fdfc =_deef -_bbgf ;};_ ,_fbcgb :=_daadc ._eagbg .Seek (-_bbgf -_fdfc ,_ea .SEEK_END );if _fbcgb !=nil {return _fbcgb ;};_gffa :=make ([]byte ,_fdfc );_daadc ._eagbg .Read (_gffa );_af .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_gffa ));_ggbad :=_acfce .FindAllStringIndex (string (_gffa ),-1);if _ggbad !=nil {_acbgf :=_ggbad [len (_ggbad )-1];_af .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ggbad );_daadc ._eagbg .Seek (-_bbgf -_fdfc +int64 (_acbgf [0]),_ea .SEEK_END );_daadc ._ecagb =_ddc .NewReader (_daadc ._eagbg );for {_faac ,_ccbg :=_daadc ._ecagb .Peek (1);if _ccbg !=nil {return _ccbg ;};_af .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_faac [0],_faac [0]);if !IsWhiteSpace (_faac [0]){break ;};_daadc ._ecagb .Discard (1);};return nil ;};_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_bbgf +=_fdfc ;};_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _a .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};func (_ddce *PdfCrypt )loadCryptFilters (_bac *PdfObjectDictionary )error {_ddce ._aea =cryptFilters {};_ceg :=_bac .Get ("\u0043\u0046");_ceg =TraceToDirectObject (_ceg );if _egee ,_dba :=_ceg .(*PdfObjectReference );_dba {_eed ,_dfd :=_ddce ._ddb .LookupByReference (*_egee );if _dfd !=nil {_af .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _dfd ;};_ceg =TraceToDirectObject (_eed );};_dfce ,_adb :=_ceg .(*PdfObjectDictionary );if !_adb {_af .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ceg );return _a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_dacg :=range _dfce .Keys (){_aba :=_dfce .Get (_dacg );if _edf ,_abae :=_aba .(*PdfObjectReference );_abae {_eeg ,_dcg :=_ddce ._ddb .LookupByReference (*_edf );if _dcg !=nil {_af .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _dcg ;};_aba =TraceToDirectObject (_eeg );};_adba ,_aacg :=_aba .(*PdfObjectDictionary );if !_aacg {return _ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_dacg ,_aba );};if _dacg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _eff _fb .FilterDict ;if _fgb :=_fdd (&_eff ,_adba );_fgb !=nil {return _fgb ;};_cef ,_efd :=_fb .NewFilter (_eff );if _efd !=nil {return _efd ;};_ddce ._aea [string (_dacg )]=_cef ;};_ddce ._aea ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_fb .NewIdentity ();_ddce ._eab ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _caa ,_bad :=_bac .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_bad {if _ ,_eag :=_ddce ._aea [string (*_caa )];!_eag {return _ac .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_caa );};_ddce ._eab =string (*_caa );};_ddce ._ebb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _deff ,_ccb :=_bac .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_ccb {if _ ,_ge :=_ddce ._aea [string (*_deff )];!_ge {return _ac .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_deff );};_ddce ._ebb =string (*_deff );};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fddcg *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);type objectStream struct{N int ;_ead []byte ;_gc map[int ]int64 ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_abeg :=MakeArray ();for _ ,_gafa :=range vals {_abeg .Append (MakeFloat (_gafa ));};return _abeg ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_cebb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _cebb ;};const _acgd =32<<(^uint (0)>>63);

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bfbad *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _eaef _eaf .Buffer ;_agc :=_eaf .NewReader (encoded );var _aade _e .ReadCloser ;if _bfbad .EarlyChange ==1{_aade =_eac .NewReader (_agc ,_eac .MSB ,8);}else {_aade =_f .NewReader (_agc ,_f .MSB ,8);};defer _aade .Close ();_ ,_agbe :=_eaef .ReadFrom (_aade );if _agbe !=nil {return nil ,_agbe ;};return _eaef .Bytes (),nil ;};func _gbdf (_fgac ,_ddfd PdfObject ,_ecda int )bool {if _ecda > _fgce {_af .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fgce );return false ;};if _fgac ==nil &&_ddfd ==nil {return true ;}else if _fgac ==nil ||_ddfd ==nil {return false ;};if _d .TypeOf (_fgac )!=_d .TypeOf (_ddfd ){return false ;};switch _eceeg :=_fgac .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_eceeg ==*(_ddfd .(*PdfObjectName ));case *PdfObjectString :return *_eceeg ==*(_ddfd .(*PdfObjectString ));case *PdfObjectInteger :return *_eceeg ==*(_ddfd .(*PdfObjectInteger ));case *PdfObjectBool :return *_eceeg ==*(_ddfd .(*PdfObjectBool ));case *PdfObjectFloat :return *_eceeg ==*(_ddfd .(*PdfObjectFloat ));case *PdfIndirectObject :return _gbdf (TraceToDirectObject (_fgac ),TraceToDirectObject (_ddfd ),_ecda +1);case *PdfObjectArray :_bebg :=_ddfd .(*PdfObjectArray );if len ((*_eceeg )._deedf )!=len ((*_bebg )._deedf ){return false ;};for _bcdff ,_eabea :=range (*_eceeg )._deedf {if !_gbdf (_eabea ,(*_bebg )._deedf [_bcdff ],_ecda +1){return false ;};};return true ;case *PdfObjectDictionary :_dcddfd :=_ddfd .(*PdfObjectDictionary );_gaee ,_eeec :=(*_eceeg )._dcafa ,(*_dcddfd )._dcafa ;if len (_gaee )!=len (_eeec ){return false ;};for _ccda ,_cbegb :=range _gaee {_abcd ,_fdgfc :=_eeec [_ccda ];if !_fdgfc ||!_gbdf (_cbegb ,_abcd ,_ecda +1){return false ;};};return true ;case *PdfObjectStream :_fcae :=_ddfd .(*PdfObjectStream );return _gbdf ((*_eceeg ).PdfObjectDictionary ,(*_fcae ).PdfObjectDictionary ,_ecda +1);default:_af .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_fgac );};return false ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_dcac *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcac .DecodeBytes (streamObj .Stream );};

// Remove removes an element specified by key.
func (_dcbg *PdfObjectDictionary )Remove (key PdfObjectName ){_gafb :=-1;for _caba ,_cgee :=range _dcbg ._beda {if _cgee ==key {_gafb =_caba ;break ;};};if _gafb >=0{_dcbg ._beda =append (_dcbg ._beda [:_gafb ],_dcbg ._beda [_gafb +1:]...);delete (_dcbg ._dcafa ,key );};};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_ceae float64 ,_dcgaf bool ){_fbca ,_dcgaf :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _dcgaf {return float64 (*_fbca ),true ;};return 0,false ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Validate validates the page settings for the JBIG2 encoder.
func (_fegg JBIG2EncoderSettings )Validate ()error {const _baff ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _fegg .Threshold < 0||_fegg .Threshold > 1.0{return _fg .Errorf (_baff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_fegg .Threshold );};if _fegg .ResolutionX < 0{return _fg .Errorf (_baff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fegg .ResolutionX );};if _fegg .ResolutionY < 0{return _fg .Errorf (_baff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fegg .ResolutionY );};if _fegg .DefaultPixelValue !=0&&_fegg .DefaultPixelValue !=1{return _fg .Errorf (_baff ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_fegg .DefaultPixelValue );};if _fegg .Compression !=JB2Generic {return _fg .Errorf (_baff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbced *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _fdgg []int ;for _ ,_ebef :=range _dbced .Elements (){if _abgcg ,_afbd :=_ebef .(*PdfObjectInteger );_afbd {_fdgg =append (_fdgg ,int (*_abgcg ));}else {return nil ,ErrTypeError ;};};return _fdgg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_becb *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};var _ffed =_db .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");var (ErrUnsupportedEncodingParameters =_a .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_a .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_a .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_a .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_a .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_a .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_a .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func _bggc (_eaeb string )(PdfObjectReference ,error ){_gcab :=PdfObjectReference {};_aced :=_ggbd .FindStringSubmatch (string (_eaeb ));if len (_aced )< 3{_af .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _gcab ,_a .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_caef ,_ :=_c .Atoi (_aced [1]);_agdf ,_ :=_c .Atoi (_aced [2]);_gcab .ObjectNumber =int64 (_caef );_gcab .GenerationNumber =int64 (_agdf );return _gcab ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_eacea *PdfObjectDictionary )Keys ()[]PdfObjectName {if _eacea ==nil {return nil ;};return _eacea ._beda ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};const _fbc ="\u0053\u0074\u0064C\u0046";

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_gaca *_ef .Document ;

// Globals are the JBIG2 global segments.
Globals _dca .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func _gbge (_gdde _e .ReadSeeker ,_ffe int64 )(*offsetReader ,error ){_ddaa :=&offsetReader {_geea :_gdde ,_gged :_ffe };_ ,_aecg :=_ddaa .Seek (0,_e .SeekStart );return _ddaa ,_aecg ;};func (_agb *PdfCrypt )saveCryptFilters (_eggd *PdfObjectDictionary )error {if _agb ._bbbb .V < 4{return _a .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_gec :=MakeDict ();_eggd .Set ("\u0043\u0046",_gec );for _dec ,_dab :=range _agb ._aea {if _dec =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bgge :=_edef (_dab ,"");_gec .Set (PdfObjectName (_dec ),_bgge );};_eggd .Set ("\u0053\u0074\u0072\u0046",MakeName (_agb ._eab ));_eggd .Set ("\u0053\u0074\u006d\u0046",MakeName (_agb ._ebb ));return nil ;};func (_cfgbb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_cfgbb ._ecagb )};func (_dfbc *PdfObjectInteger )String ()string {return _ac .Sprintf ("\u0025\u0064",*_dfbc )};type objectCache map[int ]PdfObject ;

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_gfdce *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bcgag *LZWEncoder )MakeDecodeParams ()PdfObject {if _bcgag .Predictor > 1{_ffc :=MakeDict ();_ffc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bcgag .Predictor )));if _bcgag .BitsPerComponent !=8{_ffc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bcgag .BitsPerComponent )));};if _bcgag .Columns !=1{_ffc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bcgag .Columns )));};if _bcgag .Colors !=1{_ffc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bcgag .Colors )));};return _ffc ;};return nil ;};func _ffbde (_ggcg PdfObject )(*float64 ,error ){switch _gcgb :=_ggcg .(type ){case *PdfObjectFloat :_gaac :=float64 (*_gcgb );return &_gaac ,nil ;case *PdfObjectInteger :_aadfc :=float64 (*_gcgb );return &_aadfc ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_bfgf *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_ddfa :=n ;_ebbc :=0;_bcee :=0;for _ddfa > 0{_abeeb ,_eddd :=_bfgf ._ecagb .Read (p [_ebbc :]);if _eddd !=nil {_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_abeeb ,_bcee ,_eddd .Error ());return _ebbc ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bcee ++;_ebbc +=_abeeb ;_ddfa -=_abeeb ;};return _ebbc ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_egfd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};func (_feag *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_gfec :=_feag ._ecagb .Discard (4);return PdfObjectNull {},_gfec ;};

// Clear resets the array to an empty state.
func (_agaa *PdfObjectArray )Clear (){_agaa ._deedf =[]PdfObject {}};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_ebbcb *PdfObjectReference )Resolve ()PdfObject {if _ebbcb ._gfdce ==nil {return MakeNull ();};_agfg ,_ ,_ccceg :=_ebbcb ._gfdce .resolveReference (_ebbcb );if _ccceg !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_ccceg );return MakeNull ();};if _agfg ==nil {_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _agfg ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_eafed *PdfParser )skipComments ()error {if _ ,_cgfd :=_eafed .skipSpaces ();_cgfd !=nil {return _cgfd ;};_bbbbb :=true ;for {_aefb ,_cfcg :=_eafed ._ecagb .Peek (1);if _cfcg !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cfcg .Error ());return _cfcg ;};if _bbbbb &&_aefb [0]!='%'{return nil ;};_bbbbb =false ;if (_aefb [0]!='\r')&&(_aefb [0]!='\n'){_eafed ._ecagb .ReadByte ();}else {break ;};};return _eafed .skipComments ();};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_gbfa *PdfParser )Inspect ()(map[string ]int ,error ){return _gbfa .inspect ()};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _e .ReadSeeker )(*PdfParser ,error ){_agce :=&PdfParser {_eagbg :rs ,ObjCache :make (objectCache ),_gfbfa :map[int64 ]bool {}};_ecfd ,_aadf ,_daff :=_agce .parsePdfVersion ();if _daff !=nil {_af .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_daff );return nil ,_daff ;};_agce ._gadfa .Major =_ecfd ;_agce ._gadfa .Minor =_aadf ;if _agce ._abga ,_daff =_agce .loadXrefs ();_daff !=nil {_af .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_daff );return nil ,_daff ;};_af .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_agce ._abga );if len (_agce ._bdda .ObjectMap )==0{return nil ,_ac .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _agce ,nil ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fgfc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ceccf error ){const _bgegb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _fgfc ==nil {return _fg .Error (_bgegb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fgfc .DefaultPageSettings ;};if _fgfc ._gaca ==nil {_fgfc ._gaca =_ef .InitEncodeDocument (settings .FileMode );};if _ceccf =settings .Validate ();_ceccf !=nil {return _fg .Wrap (_ceccf ,_bgegb ,"");};_aafc ,_ceccf :=img .toBitmap ();if _ceccf !=nil {return _fg .Wrap (_ceccf ,_bgegb ,"");};switch settings .Compression {case JB2Generic :if _ceccf =_fgfc ._gaca .AddGenericPage (_aafc ,settings .DuplicatedLinesRemoval );_ceccf !=nil {return _fg .Wrap (_ceccf ,_bgegb ,"");};case JB2SymbolCorrelation :return _fg .Error (_bgegb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _fg .Error (_bgegb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _fg .Error (_bgegb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_baee string ,_ccgg bool ){_abff ,_ccgg :=TraceToDirectObject (obj ).(*PdfObjectName );if _ccgg {return string (*_abff ),true ;};return ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_edgb :=&ASCIIHexEncoder {};return _edgb };func (_aacf *PdfParser )parseArray ()(*PdfObjectArray ,error ){_dgbdb :=MakeArray ();_aacf ._ecagb .ReadByte ();for {_aacf .skipSpaces ();_edbgd ,_gfeg :=_aacf ._ecagb .Peek (1);if _gfeg !=nil {return _dgbdb ,_gfeg ;};if _edbgd [0]==']'{_aacf ._ecagb .ReadByte ();break ;};_ecdd ,_gfeg :=_aacf .parseObject ();if _gfeg !=nil {return _dgbdb ,_gfeg ;};_dgbdb .Append (_ecdd );};return _dgbdb ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_ccegc :=MakeArray ();for _ ,_gacg :=range vals {_ccegc .Append (MakeInteger (int64 (_gacg )));};return _ccegc ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecfe *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bccc :=MakeDict ();_bccc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ecfe .GetFilterName ()));_ace :=_ecfe .MakeDecodeParams ();if _ace !=nil {_bccc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ace );};return _bccc ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ccfb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ccfb .PdfObjectDictionary =encoder .MakeStreamDict ();_dcaa ,_aaef :=encoder .EncodeBytes (contents );if _aaef !=nil {return nil ,_aaef ;};_ccfb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dcaa ))));_ccfb .Stream =_dcaa ;return _ccfb ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_ggeda *PdfObjectStreams ,_eecd bool ){_ggeda ,_eecd =obj .(*PdfObjectStreams );return _ggeda ,_eecd ;};func _bdf (_bgfa *PdfObjectStream ,_aeg *MultiEncoder )(*DCTEncoder ,error ){_ggba :=NewDCTEncoder ();_dfdb :=_bgfa .PdfObjectDictionary ;if _dfdb ==nil {return _ggba ,nil ;};_badg :=_bgfa .Stream ;if _aeg !=nil {_ggca ,_bgeg :=_aeg .DecodeBytes (_badg );if _bgeg !=nil {return nil ,_bgeg ;};_badg =_ggca ;};_fddg :=_eaf .NewReader (_badg );_egebb ,_dfcecc :=_ed .DecodeConfig (_fddg );if _dfcecc !=nil {_af .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dfcecc );return nil ,_dfcecc ;};switch _egebb .ColorModel {case _eg .RGBAModel :_ggba .BitsPerComponent =8;_ggba .ColorComponents =3;case _eg .RGBA64Model :_ggba .BitsPerComponent =16;_ggba .ColorComponents =3;case _eg .GrayModel :_ggba .BitsPerComponent =8;_ggba .ColorComponents =1;case _eg .Gray16Model :_ggba .BitsPerComponent =16;_ggba .ColorComponents =1;case _eg .CMYKModel :_ggba .BitsPerComponent =8;_ggba .ColorComponents =4;case _eg .YCbCrModel :_ggba .BitsPerComponent =8;_ggba .ColorComponents =3;default:return nil ,_a .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_ggba .Width =_egebb .Width ;_ggba .Height =_egebb .Height ;_af .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ggba );_ggba .Quality =DefaultJPEGQuality ;return _ggba ,nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_aafg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_gdbf ,_gaff :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gaff ==nil {_aafg .BitsPerComponent =int (_gdbf );};_dfdff ,_gaff :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gaff ==nil {_aafg .Width =int (_dfdff );};_bggff ,_gaff :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gaff ==nil {_aafg .Height =int (_bggff );};_eec ,_gaff :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gaff ==nil {_aafg .ColorComponents =int (_eec );};};func _acf (_dda *_edg .StdEncryptDict ,_gcf *PdfObjectDictionary )error {R ,_ggb :=_gcf .Get ("\u0052").(*PdfObjectInteger );if !_ggb {return _a .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_dda .R =int (*R );O ,_ggb :=_gcf .GetString ("\u004f");if !_ggb {return _a .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _dda .R ==5||_dda .R ==6{if len (O )< 48{return _ac .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ac .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_dda .O =[]byte (O );U ,_ggb :=_gcf .GetString ("\u0055");if !_ggb {return _a .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _dda .R ==5||_dda .R ==6{if len (U )< 48{return _ac .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_af .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_dda .U =[]byte (U );if _dda .R >=5{OE ,_cdd :=_gcf .GetString ("\u004f\u0045");if !_cdd {return _a .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ac .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_dda .OE =[]byte (OE );UE ,_cdd :=_gcf .GetString ("\u0055\u0045");if !_cdd {return _a .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ac .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_dda .UE =[]byte (UE );};P ,_ggb :=_gcf .Get ("\u0050").(*PdfObjectInteger );if !_ggb {return _a .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_dda .P =_edg .Permissions (*P );if _dda .R ==6{Perms ,_ga :=_gcf .GetString ("\u0050\u0065\u0072m\u0073");if !_ga {return _a .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ac .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_dda .Perms =[]byte (Perms );};if _cf ,_egg :=_gcf .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_egg {_dda .EncryptMetadata =bool (*_cf );}else {_dda .EncryptMetadata =true ;};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecc *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func (_gfad *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_gfad ._bdda .ObjectMap =make (map[int ]XrefObject );_gfad ._dgf =make (objectStreams );_ceead ,_bafa :=_gfad ._eagbg .Seek (0,_e .SeekEnd );if _bafa !=nil {return nil ,_bafa ;};_af .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ceead );_gfad ._cbbda =_ceead ;_bafa =_gfad .seekToEOFMarker (_ceead );if _bafa !=nil {_af .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bafa );return nil ,_bafa ;};_fadg ,_bafa :=_gfad ._eagbg .Seek (0,_e .SeekCurrent );if _bafa !=nil {return nil ,_bafa ;};var _bdbf int64 =64;_fbg :=_fadg -_bdbf ;if _fbg < 0{_fbg =0;};_ ,_bafa =_gfad ._eagbg .Seek (_fbg ,_e .SeekStart );if _bafa !=nil {return nil ,_bafa ;};_gfaa :=make ([]byte ,_bdbf );_ ,_bafa =_gfad ._eagbg .Read (_gfaa );if _bafa !=nil {_af .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bafa );return nil ,_bafa ;};_edege :=_cgcd .FindStringSubmatch (string (_gfaa ));if len (_edege )< 2{_af .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_a .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_edege )> 2{_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_gfaa );return nil ,_a .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_egbde ,_ :=_c .ParseInt (_edege [1],10,64);_af .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_egbde );if _egbde > _ceead {_af .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_af .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_egbde ,_bafa =_gfad .repairLocateXref ();if _bafa !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_bafa ;};};_gfad ._eagbg .Seek (int64 (_egbde ),_e .SeekStart );_gfad ._ecagb =_ddc .NewReader (_gfad ._eagbg );_bbgd ,_bafa :=_gfad .parseXref ();if _bafa !=nil {return nil ,_bafa ;};_faed :=_bbgd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _faed !=nil {_daef ,_fbad :=_faed .(*PdfObjectInteger );if !_fbad {return nil ,_a .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bafa =_gfad .parseXrefStream (_daef );if _bafa !=nil {return nil ,_bafa ;};};var _ddfb []int64 ;_ebdg :=func (_gbfd int64 ,_cadc []int64 )bool {for _ ,_bgabg :=range _cadc {if _bgabg ==_gbfd {return true ;};};return false ;};_faed =_bbgd .Get ("\u0050\u0072\u0065\u0076");for _faed !=nil {_fcdcf ,_fgcgg :=_faed .(*PdfObjectInteger );if !_fgcgg {_af .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_faed );return _bbgd ,nil ;};_ccce :=*_fcdcf ;_af .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_ccce );_gfad ._eagbg .Seek (int64 (_ccce ),_ea .SEEK_SET );_gfad ._ecagb =_ddc .NewReader (_gfad ._eagbg );_fcfc ,_gffb :=_gfad .parseXref ();if _gffb !=nil {_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_af .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_faed =_fcfc .Get ("\u0050\u0072\u0065\u0076");if _faed !=nil {_eage :=*(_faed .(*PdfObjectInteger ));if _ebdg (int64 (_eage ),_ddfb ){_af .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_ddfb =append (_ddfb ,int64 (_eage ));};};return _bbgd ,nil ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _bgcb (o ,0,traversed );};

// String returns a string representation of `name`.
func (_face *PdfObjectName )String ()string {return string (*_face )};func (_ebe *PdfCrypt )checkAccessRights (_dfcec []byte )(bool ,_edg .Permissions ,error ){_dbd :=_ebe .securityHandler ();_acde ,_gfe ,_dge :=_dbd .Authenticate (&_ebe ._cabf ,_dfcec );if _dge !=nil {return false ,0,_dge ;}else if _gfe ==0||len (_acde )==0{return false ,0,nil ;};return true ,_gfe ,nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gdegc *PdfObjectFloat ,_begc bool ){_gdegc ,_begc =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gdegc ,_begc ;};

// String returns a string describing `ind`.
func (_bgebb *PdfIndirectObject )String ()string {return _ac .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bgebb ).ObjectNumber );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_efdfb *PdfParser )GetFileOffset ()int64 {_bgda ,_ :=_efdfb ._eagbg .Seek (0,_e .SeekCurrent );_bgda -=int64 (_efdfb ._ecagb .Buffered ());return _bgda ;};func _acfc (_gagg *PdfObjectStream ,_dgbb *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _eagb ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_gbde :=&JBIG2Encoder {};_bgfb :=_gagg .PdfObjectDictionary ;if _bgfb ==nil {return _gbde ,nil ;};if _dgbb ==nil {_addg :=_bgfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _addg !=nil {switch _aefg :=_addg .(type ){case *PdfObjectDictionary :_dgbb =_aefg ;case *PdfObjectArray :if _aefg .Len ()==1{if _dcdd ,_egca :=GetDict (_aefg .Get (0));_egca {_dgbb =_dcdd ;};};default:_af .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_addg );return nil ,_fg .Errorf (_eagb ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_aefg );};};};if _dgbb ==nil {return _gbde ,nil ;};_gbde .UpdateParams (_dgbb );_cddc :=_dgbb .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _cddc ==nil {return _gbde ,nil ;};var _ggagf error ;_baag ,_dede :=_cddc .(*PdfObjectStream );if !_dede {_ggagf =_fg .Error (_eagb ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ggagf );return nil ,_ggagf ;};_gbde .Globals ,_ggagf =_dca .DecodeGlobals (_baag .Stream );if _ggagf !=nil {_ggagf =_fg .Wrap (_ggagf ,_eagb ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ggagf );return nil ,_ggagf ;};return _gbde ,nil ;};func _gag (_eadd *PdfObjectStream ,_feff *PdfObjectDictionary )(*FlateEncoder ,error ){_gda :=NewFlateEncoder ();_efgc :=_eadd .PdfObjectDictionary ;if _efgc ==nil {return _gda ,nil ;};_gda ._gece =_fecb (_efgc );if _feff ==nil {_ddag :=TraceToDirectObject (_efgc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _ffgc :=_ddag .(type ){case *PdfObjectArray :_cdg :=_ffgc ;if _cdg .Len ()!=1{_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_cdg .Len ());return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddag =TraceToDirectObject (_cdg .Get (0));case *PdfObjectDictionary :_feff =_ffgc ;case *PdfObjectNull ,nil :default:_af .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_ddag );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _feff ==nil {return _gda ,nil ;};_af .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_feff .String ());_eede :=_feff .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _eede ==nil {_af .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_bde ,_dbe :=_eede .(*PdfObjectInteger );if !_dbe {_af .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_eede );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gda .Predictor =int (*_bde );};_eede =_feff .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _eede !=nil {_abaf ,_cgac :=_eede .(*PdfObjectInteger );if !_cgac {_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ac .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gda .BitsPerComponent =int (*_abaf );};if _gda .Predictor > 1{_gda .Columns =1;_eede =_feff .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _eede !=nil {_fgbd ,_aabf :=_eede .(*PdfObjectInteger );if !_aabf {return nil ,_ac .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gda .Columns =int (*_fgbd );};_gda .Colors =1;_eede =_feff .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _eede !=nil {_daf ,_bgab :=_eede .(*PdfObjectInteger );if !_bgab {return nil ,_ac .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_gda .Colors =int (*_daf );};};return _gda ,nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_abe *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gcaa _eaf .Buffer ;for _ ,_cffa :=range data {_gcaa .WriteString (_ac .Sprintf ("\u0025\u002e\u0032X\u0020",_cffa ));};_gcaa .WriteByte ('>');return _gcaa .Bytes (),nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func _ddgcb (_bace PdfObject ,_edbeg int )PdfObject {if _edbeg > _fgce {_af .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fgce );return MakeNull ();};switch _gfecb :=_bace .(type ){case *PdfIndirectObject :_bace =_ddgcb ((*_gfecb ).PdfObject ,_edbeg +1);case *PdfObjectArray :for _ggegac ,_ccggd :=range (*_gfecb )._deedf {(*_gfecb )._deedf [_ggegac ]=_ddgcb (_ccggd ,_edbeg +1);};case *PdfObjectDictionary :for _ffff ,_efcbf :=range (*_gfecb )._dcafa {(*_gfecb )._dcafa [_ffff ]=_ddgcb (_efcbf ,_edbeg +1);};_dc .Slice ((*_gfecb )._beda ,func (_bcge ,_afab int )bool {return (*_gfecb )._beda [_bcge ]< (*_gfecb )._beda [_afab ]});};return _bace ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_babb *PdfParser )GetObjectNums ()[]int {var _gfgcb []int ;for _ ,_dfaeg :=range _babb ._bdda .ObjectMap {_gfgcb =append (_gfgcb ,_dfaeg .ObjectNumber );};_dc .Ints (_gfgcb );return _gfgcb ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_bgef *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bgef ._afdf ){return _a .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bgef ._afdf [i ]=obj ;return nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_cbbe *PdfObjectStreams )Elements ()[]PdfObject {if _cbbe ==nil {return nil ;};return _cbbe ._afdf ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_accb :=&PdfIndirectObject {};_accb .PdfObject =obj ;return _accb ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_eefcf *PdfObjectString )Bytes ()[]byte {return []byte (_eefcf ._eagbf )};

// WriteString outputs the object as it is to be written to file.
func (_bbbg *PdfObjectArray )WriteString ()string {var _fdgf _dd .Builder ;_fdgf .WriteString ("\u005b");for _fcgg ,_gecg :=range _bbbg .Elements (){_fdgf .WriteString (_gecg .WriteString ());if _fcgg < (_bbbg .Len ()-1){_fdgf .WriteString ("\u0020");};};_fdgf .WriteString ("\u005d");return _fdgf .String ();};

// Elements returns a slice of the PdfObject elements in the array.
func (_dcgf *PdfObjectArray )Elements ()[]PdfObject {if _dcgf ==nil {return nil ;};return _dcgf ._deedf ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ccafa *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _acec []float64 ;for _ ,_efbd :=range _ccafa .Elements (){_abbb ,_eedf :=GetNumberAsFloat (TraceToDirectObject (_efbd ));if _eedf !=nil {return nil ,_ac .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_acec =append (_acec ,_abbb );};return _acec ,nil ;};type cryptFilters map[string ]_fb .Filter ;func (_edff *PdfObjectFloat )String ()string {return _ac .Sprintf ("\u0025\u0066",*_edff )};

// String returns a string describing `d`.
func (_bfag *PdfObjectDictionary )String ()string {var _gabb _dd .Builder ;_gabb .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_fagc :=range _bfag ._beda {_fecd :=_bfag ._dcafa [_fagc ];_gabb .WriteString ("\u0022"+_fagc .String ()+"\u0022\u003a\u0020");_gabb .WriteString (_fecd .String ());_gabb .WriteString ("\u002c\u0020");};_gabb .WriteString ("\u0029");return _gabb .String ();};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_eeba bool ,_feeb bool ){_adeg ,_feeb :=TraceToDirectObject (obj ).(*PdfObjectBool );if _feeb {return bool (*_adeg ),true ;};return false ,false ;};

// WriteString outputs the object as it is to be written to file.
func (_bacf *PdfObjectFloat )WriteString ()string {return _c .FormatFloat (float64 (*_bacf ),'f',-1,64);};

// GetFilterName returns the name of the encoding filter.
func (_gfcf *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_efcfbc *PdfObjectString ,_bbcea bool ){_efcfbc ,_bbcea =TraceToDirectObject (obj ).(*PdfObjectString );return _efcfbc ,_bbcea ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_gadfa Version ;_eagbg _e .ReadSeeker ;_ecagb *_ddc .Reader ;_cbbda int64 ;_bdda XrefTable ;_cgcdf int64 ;_dffg *xrefType ;_dgf objectStreams ;_abga *PdfObjectDictionary ;_fdab *PdfCrypt ;_fefb bool ;ObjCache objectCache ;_gfbfa map[int64 ]bool ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_cbba *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbba .DecodeBytes (streamObj .Stream );};

// String returns a string describing `array`.
func (_ebfa *PdfObjectArray )String ()string {_agbc :="\u005b";for _ffcb ,_bdbfg :=range _ebfa .Elements (){_agbc +=_bdbfg .String ();if _ffcb < (_ebfa .Len ()-1){_agbc +="\u002c\u0020";};};_agbc +="\u005d";return _agbc ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_gbdg *PdfParser )IsAuthenticated ()bool {return _gbdg ._fdab ._cd };

// Len returns the number of elements in the array.
func (_dacf *PdfObjectArray )Len ()int {if _dacf ==nil {return 0;};return len (_dacf ._deedf );};const JB2ImageAutoThreshold =-1.0;

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_gaca :_ef .InitEncodeDocument (false )}};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gf []XrefObject ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_fbbb []byte ,_edbe bool ){_geaaa ,_edbe :=TraceToDirectObject (obj ).(*PdfObjectString );if _edbe {return _geaaa .Bytes (),true ;};return ;};func (_abaa *PdfParser )parsePdfVersion ()(int ,int ,error ){var _cbbde int64 =20;_fdbf :=make ([]byte ,_cbbde );_abaa ._eagbg .Seek (0,_ea .SEEK_SET );_abaa ._eagbg .Read (_fdbf );var _ggaf error ;var _aebb ,_dfda int ;if _abfa :=_eebc .FindStringSubmatch (string (_fdbf ));len (_abfa )< 3{if _aebb ,_dfda ,_ggaf =_abaa .seekPdfVersionTopDown ();_ggaf !=nil {_af .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_ggaf ;};_abaa ._eagbg ,_ggaf =_gbge (_abaa ._eagbg ,_abaa .GetFileOffset ()-8);if _ggaf !=nil {return 0,0,_ggaf ;};}else {if _aebb ,_ggaf =_c .Atoi (_abfa [1]);_ggaf !=nil {return 0,0,_ggaf ;};if _dfda ,_ggaf =_c .Atoi (_abfa [2]);_ggaf !=nil {return 0,0,_ggaf ;};_abaa .SetFileOffset (0);};_abaa ._ecagb =_ddc .NewReader (_abaa ._eagbg );_af .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_aebb ,_dfda );return _aebb ,_dfda ,nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_bfae *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _bcdc _eaf .Buffer ;for _fbbc :=0;_fbbc < len (data );_fbbc +=4{_cbea :=data [_fbbc ];_bfce :=1;_fegf :=byte (0);if _fbbc +1< len (data ){_fegf =data [_fbbc +1];_bfce ++;};_ecce :=byte (0);if _fbbc +2< len (data ){_ecce =data [_fbbc +2];_bfce ++;};_ddba :=byte (0);if _fbbc +3< len (data ){_ddba =data [_fbbc +3];_bfce ++;};_cbg :=(uint32 (_cbea )<<24)|(uint32 (_fegf )<<16)|(uint32 (_ecce )<<8)|uint32 (_ddba );if _cbg ==0{_bcdc .WriteByte ('z');}else {_bfdd :=_bfae .base256Tobase85 (_cbg );for _ ,_cfea :=range _bfdd [:_bfce +1]{_bcdc .WriteByte (_cfea +'!');};};};_bcdc .WriteString ("\u007e\u003e");return _bcdc .Bytes (),nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_eaa :=&LZWEncoder {};_eaa .Predictor =1;_eaa .BitsPerComponent =8;_eaa .Colors =1;_eaa .Columns =1;_eaa .EarlyChange =1;return _eaa ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_degea *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _bcdb :=val .(type ){case *PdfObjectName :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectDictionary :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectStream :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectString :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectNull :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectInteger :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectArray :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectBool :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectFloat :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfObjectReference :if _bcdb !=nil {_degea .Set (key ,val );};case *PdfIndirectObject :if _bcdb !=nil {_degea .Set (key ,val );};default:_af .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_dded :=PdfObjectString {_eagbf :s };return &_dded };func (_ffa *PdfCrypt )encryptBytes (_effe []byte ,_ebbg string ,_bgag []byte )([]byte ,error ){_af .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_gadf ,_cdb :=_ffa ._aea [_ebbg ];if !_cdb {return nil ,_ac .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ebbg );};return _gadf .EncryptBytes (_effe ,_bgag );};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_cbc *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ebda [][]byte ;for _edfa :=0;_edfa < len (data );_edfa +=_cbc .Columns {_gfgc :=make ([]byte ,_cbc .Columns );_edbg :=0;for _bfgg :=0;_bfgg < _cbc .Columns ;_bfgg ++{if data [_edfa +_bfgg ]==255{_gfgc [_edbg ]=1;}else {_gfgc [_edbg ]=0;};_edbg ++;};_ebda =append (_ebda ,_gfgc );};_aega :=&_bb .Encoder {K :_cbc .K ,Columns :_cbc .Columns ,EndOfLine :_cbc .EndOfLine ,EndOfBlock :_cbc .EndOfBlock ,BlackIs1 :_cbc .BlackIs1 ,DamagedRowsBeforeError :_cbc .DamagedRowsBeforeError ,Rows :_cbc .Rows ,EncodedByteAlign :_cbc .EncodedByteAlign };return _aega .Encode (_ebda ),nil ;};func _ecdf (_dbcf *PdfObjectStream ,_degc *PdfObjectDictionary )(*LZWEncoder ,error ){_cda :=NewLZWEncoder ();_adcd :=_dbcf .PdfObjectDictionary ;if _adcd ==nil {return _cda ,nil ;};if _degc ==nil {_egeed :=TraceToDirectObject (_adcd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _egeed !=nil {if _abgb ,_eggc :=_egeed .(*PdfObjectDictionary );_eggc {_degc =_abgb ;}else if _ccefg ,_bgc :=_egeed .(*PdfObjectArray );_bgc {if _ccefg .Len ()==1{if _acc ,_bfg :=GetDict (_ccefg .Get (0));_bfg {_degc =_acc ;};};};if _degc ==nil {_af .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_egeed );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fag :=_adcd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fag !=nil {_aaa ,_baca :=_fag .(*PdfObjectInteger );if !_baca {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fag );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_aaa !=0&&*_aaa !=1{return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_cda .EarlyChange =int (*_aaa );}else {_cda .EarlyChange =1;};if _degc ==nil {return _cda ,nil ;};_fag =_degc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fag !=nil {_ggf ,_bbaa :=_fag .(*PdfObjectInteger );if !_bbaa {_af .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fag );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_cda .Predictor =int (*_ggf );};_fag =_degc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fag !=nil {_edaa ,_ageb :=_fag .(*PdfObjectInteger );if !_ageb {_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ac .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_cda .BitsPerComponent =int (*_edaa );};if _cda .Predictor > 1{_cda .Columns =1;_fag =_degc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fag !=nil {_fbba ,_gde :=_fag .(*PdfObjectInteger );if !_gde {return nil ,_ac .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cda .Columns =int (*_fbba );};_cda .Colors =1;_fag =_degc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fag !=nil {_gaab ,_bce :=_fag .(*PdfObjectInteger );if !_bce {return nil ,_ac .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_cda .Colors =int (*_gaab );};};_af .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_degc .String ());return _cda ,nil ;};var _eebc =_db .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_begd *JBIG2Encoder )Encode ()(_bcfe []byte ,_gddc error ){const _ceddd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _begd ._gaca ==nil {return nil ,_fg .Errorf (_ceddd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_begd ._gaca .FullHeaders =_begd .DefaultPageSettings .FileMode ;_bcfe ,_gddc =_begd ._gaca .Encode ();if _gddc !=nil {return nil ,_fg .Wrap (_gddc ,_ceddd ,"");};return _bcfe ,nil ;};func (_fgaf *PdfParser )repairLocateXref ()(int64 ,error ){_cadce :=int64 (1000);_fgaf ._eagbg .Seek (-_cadce ,_ea .SEEK_CUR );_cefg ,_ggab :=_fgaf ._eagbg .Seek (0,_ea .SEEK_CUR );if _ggab !=nil {return 0,_ggab ;};_fdcc :=make ([]byte ,_cadce );_fgaf ._eagbg .Read (_fdcc );_cgba :=_cggea .FindAllStringIndex (string (_fdcc ),-1);if len (_cgba )< 1{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_a .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_dccaa :=int64 (_cgba [len (_cgba )-1][0]);_cfgdg :=_cefg +_dccaa ;return _cfgdg ,nil ;};

// Append appends PdfObject(s) to the streams.
func (_decb *PdfObjectStreams )Append (objects ...PdfObject ){if _decb ==nil {_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _decb ._afdf ==nil {_decb ._afdf =[]PdfObject {};};for _ ,_gcgc :=range objects {_decb ._afdf =append (_decb ._afdf ,_gcgc );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_cceg *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_edga :=MakeDict ();_edga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cceg .GetFilterName ()));return _edga ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_gcc *MultiEncoder )GetFilterArray ()*PdfObjectArray {_gcbc :=make ([]PdfObject ,len (_gcc ._fab ));for _cbgf ,_beec :=range _gcc ._fab {_gcbc [_cbgf ]=MakeName (_beec .GetFilterName ());};return MakeArray (_gcbc ...);};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bdd *PdfCrypt )GetAccessPermissions ()_edg .Permissions {return _bdd ._cabf .P };

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _ccbac :=obj .(type ){case *PdfObjectFloat :_af .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_ccbac ),nil ;case *PdfObjectInteger :return int64 (*_ccbac ),nil ;};return 0,ErrNotANumber ;};func (_edeg *PdfParser )skipSpaces ()(int ,error ){_gdba :=0;for {_cfed ,_aebc :=_edeg ._ecagb .ReadByte ();if _aebc !=nil {return 0,_aebc ;};if IsWhiteSpace (_cfed ){_gdba ++;}else {_edeg ._ecagb .UnreadByte ();break ;};};return _gdba ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_baec :=&FlateEncoder {};_baec .Predictor =1;_baec .BitsPerComponent =8;_baec .Colors =1;_baec .Columns =1;return _baec ;};

// PdfVersion returns version of the PDF file.
func (_gacaf *PdfParser )PdfVersion ()Version {return _gacaf ._gadfa };func (_daeg *PdfParser )parseName ()(PdfObjectName ,error ){var _dcfc _eaf .Buffer ;_fdgd :=false ;for {_fdga ,_dagc :=_daeg ._ecagb .Peek (1);if _dagc ==_e .EOF {break ;};if _dagc !=nil {return PdfObjectName (_dcfc .String ()),_dagc ;};if !_fdgd {if _fdga [0]=='/'{_fdgd =true ;_daeg ._ecagb .ReadByte ();}else if _fdga [0]=='%'{_daeg .readComment ();_daeg .skipSpaces ();}else {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_fdga ,_fdga );return PdfObjectName (_dcfc .String ()),_ac .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_fdga [0]);};}else {if IsWhiteSpace (_fdga [0]){break ;}else if (_fdga [0]=='/')||(_fdga [0]=='[')||(_fdga [0]=='(')||(_fdga [0]==']')||(_fdga [0]=='<')||(_fdga [0]=='>'){break ;}else if _fdga [0]=='#'{_fdcf ,_acbc :=_daeg ._ecagb .Peek (3);if _acbc !=nil {return PdfObjectName (_dcfc .String ()),_acbc ;};_agbd ,_acbc :=_g .DecodeString (string (_fdcf [1:3]));if _acbc !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_dcfc .WriteByte ('#');_daeg ._ecagb .Discard (1);continue ;};_daeg ._ecagb .Discard (3);_dcfc .Write (_agbd );}else {_bcad ,_ :=_daeg ._ecagb .ReadByte ();_dcfc .WriteByte (_bcad );};};};return PdfObjectName (_dcfc .String ()),nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fad :=&ASCII85Encoder {};return _fad };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_cfb *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_edba :=encoded ;var _eggf error ;for _ ,_ggde :=range _cfb ._fab {_af .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ggde ,_ggde );_edba ,_eggf =_ggde .DecodeBytes (_edba );if _eggf !=nil {return nil ,_eggf ;};};return _edba ,nil ;};func (_faca *PdfParser )rebuildXrefTable ()error {_bdag :=XrefTable {};_bdag .ObjectMap =map[int ]XrefObject {};for _caeff ,_eedde :=range _faca ._bdda .ObjectMap {_ddbb ,_ ,_efec :=_faca .lookupByNumberWrapper (_caeff ,false );if _efec !=nil {_af .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_efec );_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_fefeg ,_faedc :=_faca .repairRebuildXrefsTopDown ();if _faedc !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_faedc );return _faedc ;};_faca ._bdda =*_fefeg ;_af .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_fgeea ,_eeccb ,_efec :=_bec (_ddbb );if _efec !=nil {return _efec ;};_eedde .ObjectNumber =int (_fgeea );_eedde .Generation =int (_eeccb );_bdag .ObjectMap [int (_fgeea )]=_eedde ;};_faca ._bdda =_bdag ;_af .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bbe (_faca ._bdda );return nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_efgcc *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_dbdg :=_efgcc ._dcafa [key ];if !_dbdg {_efgcc ._beda =append (_efgcc ._beda ,key );};_efgcc ._dcafa [key ]=val ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_dgbag *PdfObjectString )Str ()string {return _dgbag ._eagbf };

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fde :=PdfObjectName (s );return &_fde };

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _bdcag ,_efcfb :=obj .(*PdfObjectReference );_efcfb {obj =_bdcag .Resolve ();};_fcbb ,_egfc :=obj .(*PdfIndirectObject );_faae :=0;for _egfc {obj =_fcbb .PdfObject ;_fcbb ,_egfc =GetIndirect (obj );_faae ++;if _faae > _fgce {_af .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_fgce );return nil ;};};return obj ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func _dgdg (_ccfd *PdfObjectStream ,_fbd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_efff :=NewCCITTFaxEncoder ();_bgd :=_ccfd .PdfObjectDictionary ;if _bgd ==nil {return _efff ,nil ;};if _fbd ==nil {_gbggg :=TraceToDirectObject (_bgd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gbggg !=nil {switch _dfae :=_gbggg .(type ){case *PdfObjectDictionary :_fbd =_dfae ;break ;case *PdfObjectArray :if _dfae .Len ()==1{if _fgdg ,_ccdf :=GetDict (_dfae .Get (0));_ccdf {_fbd =_fgdg ;};};default:_af .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gbggg );return nil ,_a .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fbd ==nil {_af .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gbggg );return nil ,_a .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _afg ,_cecc :=GetNumberAsInt64 (_fbd .Get ("\u004b"));_cecc ==nil {_efff .K =int (_afg );};if _fbce ,_fbcb :=GetNumberAsInt64 (_fbd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_fbcb ==nil {_efff .Columns =int (_fbce );}else {_efff .Columns =1728;};if _cfgd ,_bbbbf :=GetNumberAsInt64 (_fbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bbbbf ==nil {_efff .BlackIs1 =_cfgd > 0;}else {if _geec ,_gdea :=GetBoolVal (_fbd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdea {_efff .BlackIs1 =_geec ;}else {if _bgaa ,_cffb :=GetArray (_fbd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cffb {_feffa ,_bdbd :=_bgaa .ToIntegerArray ();if _bdbd ==nil {_efff .BlackIs1 =_feffa [0]==1&&_feffa [1]==0;};};};};if _dbbdb ,_adaf :=GetNumberAsInt64 (_fbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_adaf ==nil {_efff .EncodedByteAlign =_dbbdb > 0;}else {if _cdf ,_abgf :=GetBoolVal (_fbd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_abgf {_efff .EncodedByteAlign =_cdf ;};};if _ggd ,_gfcd :=GetNumberAsInt64 (_fbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gfcd ==nil {_efff .EndOfLine =_ggd > 0;}else {if _dgcb ,_fbcbg :=GetBoolVal (_fbd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fbcbg {_efff .EndOfLine =_dgcb ;};};if _gdb ,_cgegf :=GetNumberAsInt64 (_fbd .Get ("\u0052\u006f\u0077\u0073"));_cgegf ==nil {_efff .Rows =int (_gdb );};_efff .EndOfBlock =true ;if _efceb ,_aec :=GetNumberAsInt64 (_fbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aec ==nil {_efff .EndOfBlock =_efceb > 0;}else {if _eebg ,_fdcbf :=GetBoolVal (_fbd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fdcbf {_efff .EndOfBlock =_eebg ;};};if _gacf ,_aeff :=GetNumberAsInt64 (_fbd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_aeff !=nil {_efff .DamagedRowsBeforeError =int (_gacf );};_af .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fbd .String ());return _efff ,nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_dcfe *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_faaf :=PdfIndirectObject {};_faaf ._gfdce =_dcfe ;_af .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_aecf ,_dcca :=_dcfe ._ecagb .Peek (20);if _dcca !=nil {if _dcca !=_e .EOF {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_faaf ,_dcca ;};};_af .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_aecf ));_aebbe :=_agcc .FindStringSubmatchIndex (string (_aecf ));if len (_aebbe )< 6{if _dcca ==_e .EOF {return nil ,_dcca ;};_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_aecf ));return &_faaf ,_a .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dcfe ._ecagb .Discard (_aebbe [0]);_af .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_aebbe );_bdec :=_aebbe [1]-_aebbe [0];_dbaa :=make ([]byte ,_bdec );_ ,_dcca =_dcfe .ReadAtLeast (_dbaa ,_bdec );if _dcca !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dcca );return nil ,_dcca ;};_af .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dbaa );_geabg :=_agcc .FindStringSubmatch (string (_dbaa ));if len (_geabg )< 3{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dbaa ));return &_faaf ,_a .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bade ,_ :=_c .Atoi (_geabg [1]);_fdfag ,_ :=_c .Atoi (_geabg [2]);_faaf .ObjectNumber =int64 (_bade );_faaf .GenerationNumber =int64 (_fdfag );for {_fecc ,_gdabg :=_dcfe ._ecagb .Peek (2);if _gdabg !=nil {return &_faaf ,_gdabg ;};_af .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fecc ),string (_fecc ));if IsWhiteSpace (_fecc [0]){_dcfe .skipSpaces ();}else if _fecc [0]=='%'{_dcfe .skipComments ();}else if (_fecc [0]=='<')&&(_fecc [1]=='<'){_af .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_faaf .PdfObject ,_gdabg =_dcfe .ParseDict ();_af .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_gdabg );if _gdabg !=nil {return &_faaf ,_gdabg ;};_af .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_fecc [0]=='/')||(_fecc [0]=='(')||(_fecc [0]=='[')||(_fecc [0]=='<'){_faaf .PdfObject ,_gdabg =_dcfe .parseObject ();if _gdabg !=nil {return &_faaf ,_gdabg ;};_af .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _fecc [0]==']'{_af .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_dcfe ._ecagb .Discard (1);}else {if _fecc [0]=='e'{_cceea ,_daba :=_dcfe .readTextLine ();if _daba !=nil {return nil ,_daba ;};if len (_cceea )>=6&&_cceea [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _fecc [0]=='s'{_fecc ,_ =_dcfe ._ecagb .Peek (10);if string (_fecc [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_egdc :=6;if len (_fecc )> 6{if IsWhiteSpace (_fecc [_egdc ])&&_fecc [_egdc ]!='\r'&&_fecc [_egdc ]!='\n'{_af .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_egdc ++;};if _fecc [_egdc ]=='\r'{_egdc ++;if _fecc [_egdc ]=='\n'{_egdc ++;};}else if _fecc [_egdc ]=='\n'{_egdc ++;};};_dcfe ._ecagb .Discard (_egdc );_fdad ,_abef :=_faaf .PdfObject .(*PdfObjectDictionary );if !_abef {return nil ,_a .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_af .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_fdad );_efac ,_bfgc :=_dcfe .traceStreamLength (_fdad .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bfgc !=nil {_af .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bfgc );return nil ,_bfgc ;};_af .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_efac );_acfd ,_bdga :=_efac .(*PdfObjectInteger );if !_bdga {return nil ,_a .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_fdcd :=*_acfd ;if _fdcd < 0{return nil ,_a .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_fcbf :=_dcfe .GetFileOffset ();_cffd :=_dcfe .xrefNextObjectOffset (_fcbf );if _fcbf +int64 (_fdcd )> _cffd &&_cffd > _fcbf {_af .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_fcbf +int64 (_fdcd ));_af .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_cffd );_fcdg :=_cffd -_fcbf -17;if _fcdg < 0{return nil ,_a .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_af .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fcdg );_fdcd =PdfObjectInteger (_fcdg );_fdad .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fcdg ));};if int64 (_fdcd )> _dcfe ._cbbda {_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_a .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_abdg :=make ([]byte ,_fdcd );_ ,_bfgc =_dcfe .ReadAtLeast (_abdg ,int (_fdcd ));if _bfgc !=nil {_af .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_abdg ),_abdg );_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfgc );return nil ,_bfgc ;};_gebf :=PdfObjectStream {};_gebf .Stream =_abdg ;_gebf .PdfObjectDictionary =_faaf .PdfObject .(*PdfObjectDictionary );_gebf .ObjectNumber =_faaf .ObjectNumber ;_gebf .GenerationNumber =_faaf .GenerationNumber ;_gebf .PdfObjectReference ._gfdce =_dcfe ;_dcfe .skipSpaces ();_dcfe ._ecagb .Discard (9);_dcfe .skipSpaces ();return &_gebf ,nil ;};};_faaf .PdfObject ,_gdabg =_dcfe .parseObject ();if _faaf .PdfObject ==nil {_af .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_faaf .PdfObject =MakeNull ();};return &_faaf ,_gdabg ;};};if _faaf .PdfObject ==nil {_af .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_faaf .PdfObject =MakeNull ();};_af .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_faaf ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gaag *PdfObjectName )WriteString ()string {var _ggeff _eaf .Buffer ;if len (*_gaag )> 127{_af .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_gaag );};_ggeff .WriteString ("\u002f");for _acff :=0;_acff < len (*_gaag );_acff ++{_dacdc :=(*_gaag )[_acff ];if !IsPrintable (_dacdc )||_dacdc =='#'||IsDelimiter (_dacdc ){_ggeff .WriteString (_ac .Sprintf ("\u0023\u0025\u002e2\u0078",_dacdc ));}else {_ggeff .WriteByte (_dacdc );};};return _ggeff .String ();};var _agcc =_db .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_bacc *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_bbee ,_gecf :=_dcad .NewImage (_bacc .Width ,_bacc .Height ,_bacc .BitsPerComponent ,_bacc .ColorComponents ,data ,nil ,nil );if _gecf !=nil {return nil ,_gecf ;};_aef :=_ed .Options {};_aef .Quality =_bacc .Quality ;var _acaf _eaf .Buffer ;if _gecf =_ed .Encode (&_acaf ,_bbee ,&_aef );_gecf !=nil {return nil ,_gecf ;};return _acaf .Bytes (),nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};type offsetReader struct{_geea _e .ReadSeeker ;_gged int64 ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_afga :=PdfObjectFloat (val );return &_afga };

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_deedf []PdfObject };

// GetFilterName returns the name of the encoding filter.
func (_dfabd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };var _gef =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_faab :=&PdfObjectStreams {};_faab ._afdf =[]PdfObject {};for _ ,_acgfc :=range objects {_faab ._afdf =append (_faab ._afdf ,_acgfc );};return _faab ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gefa string ,_cfgg bool ){_ggdee ,_cfgg :=TraceToDirectObject (obj ).(*PdfObjectString );if _cfgg {return _ggdee .Str (),true ;};return ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_fda *PdfObjectDictionary );EncodeBytes (_gbga []byte )([]byte ,error );DecodeBytes (_dcfg []byte )([]byte ,error );DecodeStream (_dad *PdfObjectStream )([]byte ,error );};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_egda *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _edbf []float64 ;for _ ,_gggd :=range _egda .Elements (){switch _caed :=_gggd .(type ){case *PdfObjectInteger :_edbf =append (_edbf ,float64 (*_caed ));case *PdfObjectFloat :_edbf =append (_edbf ,float64 (*_caed ));default:return nil ,ErrTypeError ;};};return _edbf ,nil ;};

// Append appends PdfObject(s) to the array.
func (_efabd *PdfObjectArray )Append (objects ...PdfObject ){if _efabd ==nil {_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _efabd ._deedf ==nil {_efabd ._deedf =[]PdfObject {};};for _ ,_fcdgf :=range objects {_efabd ._deedf =append (_efabd ._deedf ,_fcdgf );};};func (_beb *FlateEncoder )postDecodePredict (_gbebb []byte )([]byte ,error ){if _beb .Predictor > 1{if _beb .Predictor ==2{_af .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_af .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_beb .Colors );_bed :=int (_beb .Columns )*_beb .Colors ;if _bed < 1{return []byte {},nil ;};_bedc :=len (_gbebb )/_bed ;if len (_gbebb )%_bed !=0{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gbebb ),_bed );};if _bed %_beb .Colors !=0{return nil ,_ac .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_bed ,_beb .Colors );};if _bed > len (_gbebb ){_af .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bed ,len (_gbebb ));return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_af .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gbebb ),_gbebb );_gadd :=_eaf .NewBuffer (nil );for _abgc :=0;_abgc < _bedc ;_abgc ++{_dbg :=_gbebb [_bed *_abgc :_bed *(_abgc +1)];for _dbfd :=_beb .Colors ;_dbfd < _bed ;_dbfd ++{_dbg [_dbfd ]+=_dbg [_dbfd -_beb .Colors ];};_gadd .Write (_dbg );};_gdg :=_gadd .Bytes ();_af .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gdg ),_gdg );return _gdg ,nil ;}else if _beb .Predictor >=10&&_beb .Predictor <=15{_af .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dbbd :=int (_beb .Columns *_beb .Colors +1);_agdd :=len (_gbebb )/_dbbd ;if len (_gbebb )%_dbbd !=0{return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gbebb ),_dbbd );};if _dbbd > len (_gbebb ){_af .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dbbd ,len (_gbebb ));return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_acgf :=_eaf .NewBuffer (nil );_af .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_beb .Columns );_af .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gbebb ),_dbbd ,_agdd );_gfbf :=make ([]byte ,_dbbd );for _gfda :=0;_gfda < _dbbd ;_gfda ++{_gfbf [_gfda ]=0;};_fae :=_beb .Colors ;for _fdag :=0;_fdag < _agdd ;_fdag ++{_cccb :=_gbebb [_dbbd *_fdag :_dbbd *(_fdag +1)];_adbab :=_cccb [0];switch _adbab {case _gce :case _fgab :for _gcfb :=1+_fae ;_gcfb < _dbbd ;_gcfb ++{_cccb [_gcfb ]+=_cccb [_gcfb -_fae ];};case _dfag :for _baba :=1;_baba < _dbbd ;_baba ++{_cccb [_baba ]+=_gfbf [_baba ];};case _afdaf :for _cgde :=1;_cgde < _fae +1;_cgde ++{_cccb [_cgde ]+=_gfbf [_cgde ]/2;};for _dfb :=_fae +1;_dfb < _dbbd ;_dfb ++{_cccb [_dfb ]+=byte ((int (_cccb [_dfb -_fae ])+int (_gfbf [_dfb ]))/2);};case _gfd :for _agg :=1;_agg < _dbbd ;_agg ++{var _ccebd ,_cccd ,_dcae byte ;_cccd =_gfbf [_agg ];if _agg >=_fae +1{_ccebd =_cccb [_agg -_fae ];_dcae =_gfbf [_agg -_fae ];};_cccb [_agg ]+=_bbce (_ccebd ,_cccd ,_dcae );};default:_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_adbab ,_fdag );return nil ,_ac .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_adbab );};copy (_gfbf ,_cccb );_acgf .Write (_cccb [1:]);};_dgbd :=_acgf .Bytes ();return _dgbd ,nil ;}else {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_beb .Predictor );return nil ,_ac .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_beb .Predictor );};};return _gbebb ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eccf *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbbba :=MakeDict ();_bbbba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_eccf .GetFilterArray ());for _ ,_aebe :=range _eccf ._fab {_caf :=_aebe .MakeStreamDict ();for _ ,_fagb :=range _caf .Keys (){_degbb :=_caf .Get (_fagb );if _fagb !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_fagb !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_bbbba .Set (_fagb ,_degbb );};};};_bffde :=_eccf .MakeDecodeParams ();if _bffde !=nil {_bbbba .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bffde );};return _bbbba ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfb *FlateEncoder )MakeDecodeParams ()PdfObject {if _bfb .Predictor > 1{_fcga :=MakeDict ();_fcga .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bfb .Predictor )));if _bfb .BitsPerComponent !=8{_fcga .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bfb .BitsPerComponent )));};if _bfb .Columns !=1{_fcga .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bfb .Columns )));};if _bfb .Colors !=1{_fcga .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bfb .Colors )));};return _fcga ;};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_geae *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_aga :=MakeDict ();_aga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_geae .GetFilterName ()));_degd :=_geae .MakeDecodeParams ();if _degd !=nil {_aga .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_degd );};return _aga ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_daea *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cfdf *PdfObjectStream ,_ddga bool ){obj =ResolveReference (obj );_cfdf ,_ddga =obj .(*PdfObjectStream );return _cfdf ,_ddga ;};

// GetXrefTable returns the PDFs xref table.
func (_fdcg *PdfParser )GetXrefTable ()XrefTable {return _fdcg ._bdda };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_afcb :=_eaf .NewReader ([]byte (txt ));_cdeg :=&PdfParser {ObjCache :objectCache {},_eagbg :_afcb ,_ecagb :_ddc .NewReader (_afcb ),_cbbda :int64 (len (txt )),_gfbfa :map[int64 ]bool {}};_cdeg ._bdda .ObjectMap =make (map[int ]XrefObject );return _cdeg ;};

// String returns a string describing `streams`.
func (_ecba *PdfObjectStreams )String ()string {return _ac .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ecba .ObjectNumber );};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cgdg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_af .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_af .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cgdg .Predictor );if _cgdg .BitsPerComponent !=8{return nil ,_ac .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cgdg .BitsPerComponent );};_ecbe ,_dcce :=_cgdg .DecodeBytes (streamObj .Stream );if _dcce !=nil {return nil ,_dcce ;};_ecbe ,_dcce =_cgdg .postDecodePredict (_ecbe );if _dcce !=nil {return nil ,_dcce ;};return _cgdg .cleanImageData (_ecbe );};

// UpdateParams updates the parameter values of the encoder.
func (_gaec *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _gbdf (obj1 ,obj2 ,0)};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_af .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fcda ,_aabga :=NewEncoderFromStream (streamObj );if _aabga !=nil {_af .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_aabga );return _aabga ;};if _baccf ,_faaff :=_fcda .(*LZWEncoder );_faaff {_baccf .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_af .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_fcda );_bcdfgc ,_aabga :=_fcda .EncodeBytes (streamObj .Stream );if _aabga !=nil {_af .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_aabga );return _aabga ;};streamObj .Stream =_bcdfgc ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bcdfgc ))));return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ecb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_efdc ,_ebc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ebc ==nil {_ecb .Predictor =int (_efdc );};_befe ,_ebc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ebc ==nil {_ecb .BitsPerComponent =int (_befe );};_acg ,_ebc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ebc ==nil {_ecb .Columns =int (_acg );};_add ,_ebc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ebc ==nil {_ecb .Colors =int (_add );};};func _fcf (_dgg int )cryptFilters {return cryptFilters {_fbc :_fb .NewFilterV2 (_dgg )}};func _edef (_defc _fb .Filter ,_adc _edg .AuthEvent )*PdfObjectDictionary {if _adc ==""{_adc =_edg .EventDocOpen ;};_dfa :=MakeDict ();_dfa .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_dfa .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_adc )));_dfa .Set ("\u0043\u0046\u004d",MakeName (_defc .Name ()));_dfa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_defc .KeyLength ())));return _dfa ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func (_fcg *PdfCrypt )decryptBytes (_cggf []byte ,_cca string ,_fdcb []byte )([]byte ,error ){_af .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_aeac ,_efe :=_fcg ._aea [_cca ];if !_efe {return nil ,_ac .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cca );};return _aeac .DecryptBytes (_cggf ,_fdcb );};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cfc *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cfc .Predictor !=1&&_cfc .Predictor !=11{_af .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _cfc .Predictor ==11{_aaec :=int (_cfc .Columns );_badb :=len (data )/_aaec ;if len (data )%_aaec !=0{_af .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_a .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_fdfe :=_eaf .NewBuffer (nil );_aad :=make ([]byte ,_aaec );for _fddf :=0;_fddf < _badb ;_fddf ++{_dbde :=data [_aaec *_fddf :_aaec *(_fddf +1)];_aad [0]=_dbde [0];for _dege :=1;_dege < _aaec ;_dege ++{_aad [_dege ]=byte (int (_dbde [_dege ]-_dbde [_dege -1])%256);};_fdfe .WriteByte (1);_fdfe .Write (_aad );};data =_fdfe .Bytes ();};var _bfba _eaf .Buffer ;_cgdgd :=_ca .NewWriter (&_bfba );_cgdgd .Write (data );_cgdgd .Close ();return _bfba .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bfded *PdfObjectReference )WriteString ()string {var _agae _dd .Builder ;_agae .WriteString (_c .FormatInt (_bfded .ObjectNumber ,10));_agae .WriteString ("\u0020");_agae .WriteString (_c .FormatInt (_bfded .GenerationNumber ,10));_agae .WriteString ("\u0020\u0052");return _agae .String ();};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _fb .Filter ,userPass ,ownerPass []byte ,perm _edg .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_cab :=&PdfCrypt {_afd :make (map[PdfObject ]bool ),_aea :make (cryptFilters ),_cabf :_edg .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _def Version ;if cf !=nil {_cb :=cf .PDFVersion ();_def .Major ,_def .Minor =_cb [0],_cb [1];V ,R :=cf .HandlerVersion ();_cab ._bbbb .V =V ;_cab ._cabf .R =R ;_cab ._bbbb .Length =cf .KeyLength ()*8;};const (_fdb =_fbc ;);_cab ._aea [_fdb ]=cf ;if _cab ._bbbb .V >=4{_cab ._ebb =_fdb ;_cab ._eab =_fdb ;};_aab :=_cab .newEncryptDict ();_fdg :=_dbc .Sum ([]byte (_ba .Now ().Format (_ba .RFC850 )));_efg :=string (_fdg [:]);_cgc :=make ([]byte ,100);_egf .Read (_cgc );_fdg =_dbc .Sum (_cgc );_baa :=string (_fdg [:]);_af .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_cgc );_af .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_efg );_cab ._baf =string (_efg );_gbe :=_cab .generateParams (userPass ,ownerPass );if _gbe !=nil {return nil ,nil ,_gbe ;};_bgf (&_cab ._cabf ,_aab );if _cab ._bbbb .V >=4{if _fc :=_cab .saveCryptFilters (_aab );_fc !=nil {return nil ,nil ,_fc ;};};return _cab ,&EncryptInfo {Version :_def ,Encrypt :_aab ,ID0 :_efg ,ID1 :_baa },nil ;};

// String returns a string representation of the *PdfObjectString.
func (_adfbd *PdfObjectString )String ()string {return _adfbd ._eagbf };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dfeb *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_ddec :=_dfeb .GetFileOffset ();_ ,_fagf :=_dfeb ._eagbg .Seek (offset ,_e .SeekStart );if _fagf !=nil {return nil ,_fagf ;};_bdfa :=make ([]byte ,len );_ ,_fagf =_e .ReadAtLeast (_dfeb ._eagbg ,_bdfa ,int (len ));if _fagf !=nil {return nil ,_fagf ;};_dfeb .SetFileOffset (_ddec );return _bdfa ,nil ;};func (_cdgd *ASCII85Encoder )base256Tobase85 (_fcfa uint32 )[5]byte {_abba :=[5]byte {0,0,0,0,0};_bdfb :=_fcfa ;for _eagf :=0;_eagf < 5;_eagf ++{_ddae :=uint32 (1);for _gbfbg :=0;_gbfbg < 4-_eagf ;_gbfbg ++{_ddae *=85;};_gee :=_bdfb /_ddae ;_bdfb =_bdfb %_ddae ;_abba [_eagf ]=byte (_gee );};return _abba ;};var _cgcd =_db .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// WriteString outputs the object as it is to be written to file.
func (_ebfb *PdfObjectString )WriteString ()string {var _cbgac _eaf .Buffer ;if _ebfb ._geef {_fdbe :=_g .EncodeToString (_ebfb .Bytes ());_cbgac .WriteString ("\u003c");_cbgac .WriteString (_fdbe );_cbgac .WriteString ("\u003e");return _cbgac .String ();};_gdfd :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_cbgac .WriteString ("\u0028");for _fca :=0;_fca < len (_ebfb ._eagbf );_fca ++{_eebe :=_ebfb ._eagbf [_fca ];if _dbfdg ,_febc :=_gdfd [_eebe ];_febc {_cbgac .WriteString (_dbfdg );}else {_cbgac .WriteByte (_eebe );};};_cbgac .WriteString ("\u0029");return _cbgac .String ();};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_dfdbc :=&PdfObjectDictionary {};_dfdbc ._dcafa =map[PdfObjectName ]PdfObject {};_dfdbc ._beda =[]PdfObjectName {};return _dfdbc ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_fbab *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cgcgb ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _fbab .ColorComponents !=1||_fbab .BitsPerComponent !=1{return nil ,_fg .Errorf (_cgcgb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_gagd *_bbb .Bitmap ;_eeed error ;);_gceg :=(_fbab .Width *_fbab .Height )==len (data );if _gceg {_gagd ,_eeed =_bbb .NewWithUnpaddedData (_fbab .Width ,_fbab .Height ,data );}else {_gagd ,_eeed =_bbb .NewWithData (_fbab .Width ,_fbab .Height ,data );};if _eeed !=nil {return nil ,_eeed ;};_fabg :=_fbab .DefaultPageSettings ;if _eeed =_fabg .Validate ();_eeed !=nil {return nil ,_fg .Wrap (_eeed ,_cgcgb ,"");};switch _fabg .Compression {case JB2Generic :if _eeed =_fbab ._gaca .AddGenericPage (_gagd ,_fabg .DuplicatedLinesRemoval );_eeed !=nil {return nil ,_fg .Wrap (_eeed ,_cgcgb ,"");};case JB2SymbolCorrelation :return nil ,_fg .Error (_cgcgb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_fg .Error (_cgcgb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_fg .Error (_cgcgb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _fbab .Encode ();};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_gfed :=&PdfObjectArray {};_gfed ._deedf =[]PdfObject {};for _ ,_affeg :=range objects {_gfed ._deedf =append (_gfed ._deedf ,_affeg );};return _gfed ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_ffca *PdfParser )seekToEOFMarker (_ecgbc int64 )error {var _ega int64 ;var _dgdd int64 =2048;for _ega < _ecgbc -4{if _ecgbc <=(_dgdd +_ega ){_dgdd =_ecgbc -_ega ;};_ ,_eceee :=_ffca ._eagbg .Seek (-_ega -_dgdd ,_e .SeekEnd );if _eceee !=nil {return _eceee ;};_cgbdc :=make ([]byte ,_dgdd );_ffca ._eagbg .Read (_cgbdc );_af .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_cgbdc ));_cecd :=_geaa .FindAllStringIndex (string (_cgbdc ),-1);if _cecd !=nil {_dcddf :=_cecd [len (_cecd )-1];_af .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cecd );_ffca ._eagbg .Seek (-_ega -_dgdd +int64 (_dcddf [0]),_e .SeekEnd );return nil ;};_af .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ega +=_dgdd -4;};_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _a .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_ddda *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ffgd :=_eaf .NewReader (encoded );var _decd []byte ;for {_dff ,_gaed :=_ffgd .ReadByte ();if _gaed !=nil {return nil ,_gaed ;};if _dff > 128{_gbfbb ,_gge :=_ffgd .ReadByte ();if _gge !=nil {return nil ,_gge ;};for _dbed :=0;_dbed < 257-int (_dff );_dbed ++{_decd =append (_decd ,_gbfbb );};}else if _dff < 128{for _eagg :=0;_eagg < int (_dff )+1;_eagg ++{_ddac ,_cedd :=_ffgd .ReadByte ();if _cedd !=nil {return nil ,_cedd ;};_decd =append (_decd ,_ddac );};}else {break ;};};return _decd ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_acgfg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cdcb :=range another .Keys (){_efdd :=another .Get (_cdcb );_acgfg .Set (_cdcb ,_efdd );};};return _acgfg ;};type objectStreams map[int ]objectStream ;

// WriteString outputs the object as it is to be written to file.
func (_dagb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_fbga *PdfParser )CheckAccessRights (password []byte )(bool ,_edg .Permissions ,error ){if _fbga ._fdab ==nil {return true ,_edg .PermOwner ,nil ;};return _fbga ._fdab .checkAccessRights (password );};

// LookupByReference looks up a PdfObject by a reference.
func (_dfc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_af .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dfc .LookupByNumber (int (ref .ObjectNumber ));};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bbbb encryptDict ;_cabf _edg .StdEncryptDict ;_baf string ;_bdb []byte ;_gggb map[PdfObject ]bool ;_afd map[PdfObject ]bool ;_cd bool ;_aea cryptFilters ;_ebb string ;_eab string ;_ddb *PdfParser ;_dfg map[int ]struct{};};func (_eedg *JBIG2Encoder )encodeImage (_bfgd _eb .Image )([]byte ,error ){const _ddbd ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_gebad ,_gbd :=GoImageToJBIG2 (_bfgd ,JB2ImageAutoThreshold );if _gbd !=nil {return nil ,_fg .Wrap (_gbd ,_ddbd ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _gbd =_eedg .AddPageImage (_gebad ,&_eedg .DefaultPageSettings );_gbd !=nil {return nil ,_fg .Wrap (_gbd ,_ddbd ,"");};return _eedg .Encode ();};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_gece *_dcad .ImageBase ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_dcfde *PdfObjectDictionary ,_agdb bool ){_dcfde ,_agdb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _dcfde ,_agdb ;};

// GetFilterName returns the name of the encoding filter.
func (_faeg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// SetImage sets the image base for given flate encoder.
func (_ged *FlateEncoder )SetImage (img *_dcad .ImageBase ){_ged ._gece =img };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_ccdb *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _ccdb .isDecrypted (obj ){return nil ;};switch _bbbf :=obj .(type ){case *PdfIndirectObject :_ccdb ._gggb [_bbbf ]=true ;_af .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bbbf .ObjectNumber ,_bbbf .GenerationNumber );_fac :=_bbbf .ObjectNumber ;_bfde :=_bbbf .GenerationNumber ;_fbb :=_ccdb .Decrypt (_bbbf .PdfObject ,_fac ,_bfde );if _fbb !=nil {return _fbb ;};return nil ;case *PdfObjectStream :_ccdb ._gggb [_bbbf ]=true ;_dgge :=_bbbf .PdfObjectDictionary ;if _ccdb ._cabf .R !=5{if _ebfcg ,_eedd :=_dgge .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eedd &&*_ebfcg =="\u0058\u0052\u0065\u0066"{return nil ;};};_fgc :=_bbbf .ObjectNumber ;_gbb :=_bbbf .GenerationNumber ;_af .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fgc ,_gbb );_gbgf :=_fbc ;if _ccdb ._bbbb .V >=4{_gbgf =_ccdb ._ebb ;_af .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_ccdb ._ebb );if _fea ,_adcc :=_dgge .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_adcc {if _dfaa ,_gbeb :=GetName (_fea .Get (0));_gbeb {if *_dfaa =="\u0043\u0072\u0079p\u0074"{_gbgf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gcfd ,_adaa :=_dgge .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_adaa {if _egbd ,_ccba :=_gcfd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_ccba {if _ ,_bef :=_ccdb ._aea [string (*_egbd )];_bef {_af .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_egbd );_gbgf =string (*_egbd );};};};};};};_af .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gbgf );if _gbgf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_eeb :=_ccdb .Decrypt (_dgge ,_fgc ,_gbb );if _eeb !=nil {return _eeb ;};_bacg ,_eeb :=_ccdb .makeKey (_gbgf ,uint32 (_fgc ),uint32 (_gbb ),_ccdb ._bdb );if _eeb !=nil {return _eeb ;};_bbbf .Stream ,_eeb =_ccdb .decryptBytes (_bbbf .Stream ,_gbgf ,_bacg );if _eeb !=nil {return _eeb ;};_dgge .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bbbf .Stream ))));return nil ;case *PdfObjectString :_af .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fecg :=_fbc ;if _ccdb ._bbbb .V >=4{_af .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ccdb ._eab );if _ccdb ._eab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fecg =_ccdb ._eab ;};_bge ,_gdd :=_ccdb .makeKey (_fecg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_ccdb ._bdb );if _gdd !=nil {return _gdd ;};_dfdf :=_bbbf .Str ();_cag :=make ([]byte ,len (_dfdf ));for _cgd :=0;_cgd < len (_dfdf );_cgd ++{_cag [_cgd ]=_dfdf [_cgd ];};_af .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cag ,_cag );_cag ,_gdd =_ccdb .decryptBytes (_cag ,_fecg ,_bge );if _gdd !=nil {return _gdd ;};_bbbf ._eagbf =string (_cag );return nil ;case *PdfObjectArray :for _ ,_degb :=range _bbbf .Elements (){_ade :=_ccdb .Decrypt (_degb ,parentObjNum ,parentGenNum );if _ade !=nil {return _ade ;};};return nil ;case *PdfObjectDictionary :_dde :=false ;if _bdbb :=_bbbf .Get ("\u0054\u0079\u0070\u0065");_bdbb !=nil {_eaff ,_ecaf :=_bdbb .(*PdfObjectName );if _ecaf &&*_eaff =="\u0053\u0069\u0067"{_dde =true ;};};for _ ,_gddg :=range _bbbf .Keys (){_ecf :=_bbbf .Get (_gddg );if _dde &&string (_gddg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gddg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gddg )!="\u0050\u0072\u0065\u0076"&&string (_gddg )!="\u004c\u0061\u0073\u0074"{_gad :=_ccdb .Decrypt (_ecf ,parentObjNum ,parentGenNum );if _gad !=nil {return _gad ;};};};return nil ;};return nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_aca *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gdfe :=_eaf .NewReader (encoded );_gecec ,_dace :=_ed .Decode (_gdfe );if _dace !=nil {_af .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dace );return nil ,_dace ;};_ffge :=_gecec .Bounds ();var _fgbf =make ([]byte ,_ffge .Dx ()*_ffge .Dy ()*_aca .ColorComponents *_aca .BitsPerComponent /8);_efa :=0;for _cac :=_ffge .Min .Y ;_cac < _ffge .Max .Y ;_cac ++{for _gbfb :=_ffge .Min .X ;_gbfb < _ffge .Max .X ;_gbfb ++{_cfd :=_gecec .At (_gbfb ,_cac );if _aca .ColorComponents ==1{if _aca .BitsPerComponent ==16{_gfc ,_fbbd :=_cfd .(_eg .Gray16 );if !_fbbd {return nil ,_a .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fgbf [_efa ]=byte ((_gfc .Y >>8)&0xff);_efa ++;_fgbf [_efa ]=byte (_gfc .Y &0xff);_efa ++;}else {_fdce ,_gaad :=_cfd .(_eg .Gray );if !_gaad {return nil ,_a .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fgbf [_efa ]=byte (_fdce .Y &0xff);_efa ++;};}else if _aca .ColorComponents ==3{if _aca .BitsPerComponent ==16{_dgeb ,_eged :=_cfd .(_eg .RGBA64 );if !_eged {return nil ,_a .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fgbf [_efa ]=byte ((_dgeb .R >>8)&0xff);_efa ++;_fgbf [_efa ]=byte (_dgeb .R &0xff);_efa ++;_fgbf [_efa ]=byte ((_dgeb .G >>8)&0xff);_efa ++;_fgbf [_efa ]=byte (_dgeb .G &0xff);_efa ++;_fgbf [_efa ]=byte ((_dgeb .B >>8)&0xff);_efa ++;_fgbf [_efa ]=byte (_dgeb .B &0xff);_efa ++;}else {_gbff ,_cccbe :=_cfd .(_eg .RGBA );if _cccbe {_fgbf [_efa ]=_gbff .R &0xff;_efa ++;_fgbf [_efa ]=_gbff .G &0xff;_efa ++;_fgbf [_efa ]=_gbff .B &0xff;_efa ++;}else {_fcgd ,_bbaf :=_cfd .(_eg .YCbCr );if !_bbaf {return nil ,_a .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_geced ,_fgbdf ,_ggfb ,_ :=_fcgd .RGBA ();_fgbf [_efa ]=byte (_geced >>8);_efa ++;_fgbf [_efa ]=byte (_fgbdf >>8);_efa ++;_fgbf [_efa ]=byte (_ggfb >>8);_efa ++;};};}else if _aca .ColorComponents ==4{_bca ,_bdg :=_cfd .(_eg .CMYK );if !_bdg {return nil ,_a .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fgbf [_efa ]=255-_bca .C &0xff;_efa ++;_fgbf [_efa ]=255-_bca .M &0xff;_efa ++;_fgbf [_efa ]=255-_bca .Y &0xff;_efa ++;_fgbf [_efa ]=255-_bca .K &0xff;_efa ++;};};};return _fgbf ,nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_eccd *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eccd .DecodeBytes (streamObj .Stream );};var _becd =_db .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// String returns a string describing `ref`.
func (_gagbb *PdfObjectReference )String ()string {return _ac .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gagbb .ObjectNumber ,_gagbb .GenerationNumber );};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_dfbf :=PdfObjectString {_eagbf :s ,_geef :true };return &_dfbf ;};func (_ebca *JBIG2Image )toBitmap ()(_fgdc *_bbb .Bitmap ,_ggfg error ){const _fagbg ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _ebca .Data ==nil {return nil ,_fg .Error (_fagbg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _ebca .Width ==0||_ebca .Height ==0{return nil ,_fg .Error (_fagbg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _ebca .HasPadding {_fgdc ,_ggfg =_bbb .NewWithData (_ebca .Width ,_ebca .Height ,_ebca .Data );}else {_fgdc ,_ggfg =_bbb .NewWithUnpaddedData (_ebca .Width ,_ebca .Height ,_ebca .Data );};if _ggfg !=nil {return nil ,_fg .Wrap (_ggfg ,_fagbg ,"");};return _fgdc ,nil ;};var _cggea =_db .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_fb .FilterDict ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_dcda *PdfParser )Decrypt (password []byte )(bool ,error ){if _dcda ._fdab ==nil {return false ,_a .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_egbgc ,_fedg :=_dcda ._fdab .authenticate (password );if _fedg !=nil {return false ,_fedg ;};if !_egbgc {_egbgc ,_fedg =_dcda ._fdab .authenticate ([]byte (""));};return _egbgc ,_fedg ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// UpdateParams updates the parameter values of the encoder.
func (_abd *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_aaed :=range _abd ._fab {_aaed .UpdateParams (params );};};

// String returns the state of the bool as "true" or "false".
func (_ffebe *PdfObjectBool )String ()string {if *_ffebe {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_dfbe *PdfParser )xrefNextObjectOffset (_fcbc int64 )int64 {_bbeef :=int64 (0);if len (_dfbe ._bdda .ObjectMap )==0{return 0;};if len (_dfbe ._bdda ._gf )==0{_bbbc :=0;for _ ,_dgbf :=range _dfbe ._bdda .ObjectMap {if _dgbf .Offset > 0{_bbbc ++;};};if _bbbc ==0{return 0;};_dfbe ._bdda ._gf =make ([]XrefObject ,_bbbc );_gafd :=0;for _ ,_agdc :=range _dfbe ._bdda .ObjectMap {if _agdc .Offset > 0{_dfbe ._bdda ._gf [_gafd ]=_agdc ;_gafd ++;};};_dc .Slice (_dfbe ._bdda ._gf ,func (_aeda ,_ggegd int )bool {return _dfbe ._bdda ._gf [_aeda ].Offset < _dfbe ._bdda ._gf [_ggegd ].Offset });};_fbac :=_dc .Search (len (_dfbe ._bdda ._gf ),func (_cbbaa int )bool {return _dfbe ._bdda ._gf [_cbbaa ].Offset >=_fcbc });if _fbac < len (_dfbe ._bdda ._gf ){_bbeef =_dfbe ._bdda ._gf [_fbac ].Offset ;};return _bbeef ;};func _bbce (_fgcc ,_fabc ,_gab uint8 )uint8 {_ffdde :=int (_gab );_aded :=int (_fabc )-_ffdde ;_beef :=int (_fgcc )-_ffdde ;_ffdde =_bfbd (_aded +_beef );_aded =_bfbd (_aded );_beef =_bfbd (_beef );if _aded <=_beef &&_aded <=_ffdde {return _fgcc ;}else if _beef <=_ffdde {return _fabc ;};return _gab ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cdbb :=obj .(type ){case *PdfObjectFloat :return float64 (*_cdbb ),nil ;case *PdfObjectInteger :return float64 (*_cdbb ),nil ;};return 0,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_eabe *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func _bdde (_febg ,_gbed ,_ddgd int )error {if _gbed < 0||_gbed > _febg {return _a .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _ddgd < _gbed {return _a .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _ddgd > _febg {return _a .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_eaebf *PdfObjectBool ,_gdgf bool ){_eaebf ,_gdgf =TraceToDirectObject (obj ).(*PdfObjectBool );return _eaebf ,_gdgf ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_eae *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_bfd ,_bc :=obj .(*PdfObjectReference );if !_bc {return obj ,nil ;};_fee :=_eae .GetFileOffset ();defer func (){_eae .SetFileOffset (_fee )}();_ebg ,_cce :=_eae .LookupByReference (*_bfd );if _cce !=nil {return nil ,_cce ;};_bd ,_egff :=_ebg .(*PdfIndirectObject );if !_egff {return _ebg ,nil ;};_ebg =_bd .PdfObject ;_ ,_bc =_ebg .(*PdfObjectReference );if _bc {return _bd ,_a .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ebg ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_gdeg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_abb :=_eaf .NewReader (encoded );var _gff []byte ;for {_fddc ,_ecfgg :=_abb .ReadByte ();if _ecfgg !=nil {return nil ,_ecfgg ;};if _fddc =='>'{break ;};if IsWhiteSpace (_fddc ){continue ;};if (_fddc >='a'&&_fddc <='f')||(_fddc >='A'&&_fddc <='F')||(_fddc >='0'&&_fddc <='9'){_gff =append (_gff ,_fddc );}else {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_fddc );return nil ,_ac .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_fddc );};};if len (_gff )%2==1{_gff =append (_gff ,'0');};_af .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_gff );_agga :=make ([]byte ,_g .DecodedLen (len (_gff )));_ ,_aace :=_g .Decode (_agga ,_gff );if _aace !=nil {return nil ,_aace ;};return _agga ,nil ;};func (_dcfgd *PdfParser )parseBool ()(PdfObjectBool ,error ){_eecc ,_aebg :=_dcfgd ._ecagb .Peek (4);if _aebg !=nil {return PdfObjectBool (false ),_aebg ;};if (len (_eecc )>=4)&&(string (_eecc [:4])=="\u0074\u0072\u0075\u0065"){_dcfgd ._ecagb .Discard (4);return PdfObjectBool (true ),nil ;};_eecc ,_aebg =_dcfgd ._ecagb .Peek (5);if _aebg !=nil {return PdfObjectBool (false ),_aebg ;};if (len (_eecc )>=5)&&(string (_eecc [:5])=="\u0066\u0061\u006cs\u0065"){_dcfgd ._ecagb .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_a .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fcd *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bdbga []byte ;_af .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_ceac :=0;_eegg :=false ;for _ceac < len (encoded )&&!_eegg {_bfa :=[5]byte {0,0,0,0,0};_dbcb :=0;_gfgff :=0;_abad :=4;for _gfgff < 5+_dbcb {if _ceac +_gfgff ==len (encoded ){break ;};_edgd :=encoded [_ceac +_gfgff ];if IsWhiteSpace (_edgd ){_dbcb ++;_gfgff ++;continue ;}else if _edgd =='~'&&_ceac +_gfgff +1< len (encoded )&&encoded [_ceac +_gfgff +1]=='>'{_abad =(_gfgff -_dbcb )-1;if _abad < 0{_abad =0;};_eegg =true ;break ;}else if _edgd >='!'&&_edgd <='u'{_edgd -='!';}else if _edgd =='z'&&_gfgff -_dbcb ==0{_abad =4;_gfgff ++;break ;}else {_af .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_bfa [_gfgff -_dbcb ]=_edgd ;_gfgff ++;};_ceac +=_gfgff ;for _dae :=_abad +1;_dae < 5;_dae ++{_bfa [_dae ]=84;};_bdfe :=uint32 (_bfa [0])*85*85*85*85+uint32 (_bfa [1])*85*85*85+uint32 (_bfa [2])*85*85+uint32 (_bfa [3])*85+uint32 (_bfa [4]);_eea :=[]byte {byte ((_bdfe >>24)&0xff),byte ((_bdfe >>16)&0xff),byte ((_bdfe >>8)&0xff),byte (_bdfe &0xff)};_bdbga =append (_bdbga ,_eea [:_abad ]...);};_af .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_af .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bdbga );return _bdbga ,nil ;};

// String returns a string describing `stream`.
func (_ffee *PdfObjectStream )String ()string {return _ac .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ffee .ObjectNumber ,_ffee .PdfObjectDictionary );};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fgdfe *JBIG2Encoder )EncodeImage (img _eb .Image )([]byte ,error ){return _fgdfe .encodeImage (img );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_defg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ffga :=MakeDict ();_ffga .Set ("\u004b",MakeInteger (int64 (_defg .K )));_ffga .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_defg .Columns )));if _defg .BlackIs1 {_ffga .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_defg .BlackIs1 ));};if _defg .EncodedByteAlign {_ffga .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_defg .EncodedByteAlign ));};if _defg .EndOfLine &&_defg .K >=0{_ffga .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_defg .EndOfLine ));};if _defg .Rows !=0&&!_defg .EndOfBlock {_ffga .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_defg .Rows )));};if !_defg .EndOfBlock {_ffga .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_defg .EndOfBlock ));};if _defg .DamagedRowsBeforeError !=0{_ffga .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_defg .DamagedRowsBeforeError )));};return _ffga ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_bceg *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bceg .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_fbfd *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };var _geaa =_db .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_affca *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dcb ,_gggcf :=_affca ._dcafa [key ].(*PdfObjectString );if !_gggcf {return "",false ;};return _dcb .Str (),true ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_fcfcc *PdfObjectName ,_ddgf bool ){_fcfcc ,_ddgf =TraceToDirectObject (obj ).(*PdfObjectName );return _fcfcc ,_ddgf ;};func (_bba *PdfCrypt )securityHandler ()_edg .StdHandler {if _bba ._cabf .R >=5{return _edg .NewHandlerR6 ();};return _edg .NewHandlerR4 (_bba ._baf ,_bba ._bbbb .Length );};func (_bfed *PdfParser )parseXrefStream (_cebg *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _cebg !=nil {_af .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_cebg );_bfed ._eagbg .Seek (int64 (*_cebg ),_e .SeekStart );_bfed ._ecagb =_ddc .NewReader (_bfed ._eagbg );};_abeeg :=_bfed .GetFileOffset ();_befa ,_fcgc :=_bfed .ParseIndirectObject ();if _fcgc !=nil {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_af .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_befa );_fgegd ,_dfabf :=_befa .(*PdfObjectStream );if !_dfabf {_af .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_a .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_gdgcf :=_fgegd .PdfObjectDictionary ;_cbdb ,_dfabf :=_fgegd .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dfabf {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_a .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_cbdb )> 8388607{_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_cbdb );return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bggcd :=_fgegd .PdfObjectDictionary .Get ("\u0057");_cbeg ,_dfabf :=_bggcd .(*PdfObjectArray );if !_dfabf {return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eagdc :=_cbeg .Len ();if _eagdc !=3{_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_eagdc );return nil ,_a .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _fcc []int64 ;for _bced :=0;_bced < 3;_bced ++{_efb ,_efab :=GetInt (_cbeg .Get (_bced ));if !_efab {return nil ,_a .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_fcc =append (_fcc ,int64 (*_efb ));};_bgde ,_fcgc :=DecodeStream (_fgegd );if _fcgc !=nil {_af .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_fcgc );return nil ,_fcgc ;};_eaga :=int (_fcc [0]);_gbea :=int (_fcc [0]+_fcc [1]);_dcffc :=int (_fcc [0]+_fcc [1]+_fcc [2]);_dccg :=int (_fcc [0]+_fcc [1]+_fcc [2]);if _eaga < 0||_gbea < 0||_dcffc < 0{_af .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_eaga ,_gbea ,_dcffc );return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dccg ==0{_af .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _gdgcf ,nil ;};_feef :=len (_bgde )/_dccg ;_bbcf :=0;_afb :=_fgegd .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _fagd []int ;if _afb !=nil {_af .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_afb );_bbbbag ,_dce :=_afb .(*PdfObjectArray );if !_dce {_af .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_a .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _bbbbag .Len ()%2!=0{_af .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bbcf =0;_dabf ,_ffbf :=_bbbbag .ToIntegerArray ();if _ffbf !=nil {_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_ffbf );return nil ,_ffbf ;};for _bage :=0;_bage < len (_dabf );_bage +=2{_afcd :=_dabf [_bage ];_eaea :=_dabf [_bage +1];for _ddcf :=0;_ddcf < _eaea ;_ddcf ++{_fagd =append (_fagd ,_afcd +_ddcf );};_bbcf +=_eaea ;};}else {for _bcfeb :=0;_bcfeb < int (*_cbdb );_bcfeb ++{_fagd =append (_fagd ,_bcfeb );};_bbcf =int (*_cbdb );};if _feef ==_bbcf +1{_af .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_gfbb :=_bbcf -1;for _ ,_aegf :=range _fagd {if _aegf > _gfbb {_gfbb =_aegf ;};};_fagd =append (_fagd ,_gfbb +1);_bbcf ++;};if _feef !=len (_fagd ){_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_feef ,len (_fagd ));return nil ,_a .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_af .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_bbcf );_af .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_fagd );_fgegdf :=func (_dgfe []byte )int64 {var _gdaca int64 ;for _cfeef :=0;_cfeef < len (_dgfe );_cfeef ++{_gdaca +=int64 (_dgfe [_cfeef ])*(1<<uint (8*(len (_dgfe )-_cfeef -1)));};return _gdaca ;};_af .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_bgde ));_fceb :=0;for _aaaf :=0;_aaaf < len (_bgde );_aaaf +=_dccg {_bgcf :=_bdde (len (_bgde ),_aaaf ,_aaaf +_eaga );if _bgcf !=nil {_af .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bgcf );return nil ,_bgcf ;};_fcea :=_bgde [_aaaf :_aaaf +_eaga ];_bgcf =_bdde (len (_bgde ),_aaaf +_eaga ,_aaaf +_gbea );if _bgcf !=nil {_af .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bgcf );return nil ,_bgcf ;};_bbgbb :=_bgde [_aaaf +_eaga :_aaaf +_gbea ];_bgcf =_bdde (len (_bgde ),_aaaf +_gbea ,_aaaf +_dcffc );if _bgcf !=nil {_af .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_bgcf );return nil ,_bgcf ;};_ebdeb :=_bgde [_aaaf +_gbea :_aaaf +_dcffc ];_adg :=_fgegdf (_fcea );_degef :=_fgegdf (_bbgbb );_fagdd :=_fgegdf (_ebdeb );if _fcc [0]==0{_adg =1;};if _fceb >=len (_fagd ){_af .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_feb :=_fagd [_fceb ];_fceb ++;_af .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_feb ,_fcea );_af .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_feb ,_bbgbb );_af .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_feb ,_ebdeb );_af .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_feb ,_adg ,_degef ,_fagdd );if _adg ==0{_af .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _adg ==1{_af .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_bbgbb );if _degef ==_abeeg {_af .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_feb ,_fgegd .ObjectNumber );_feb =int (_fgegd .ObjectNumber );};if _afec ,_aaggb :=_bfed ._bdda .ObjectMap [_feb ];!_aaggb ||int (_fagdd )> _afec .Generation {_gaef :=XrefObject {ObjectNumber :_feb ,XType :XrefTypeTableEntry ,Offset :_degef ,Generation :int (_fagdd )};_bfed ._bdda .ObjectMap [_feb ]=_gaef ;};}else if _adg ==2{_af .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_ceee :=_bfed ._bdda .ObjectMap [_feb ];!_ceee {_dgba :=XrefObject {ObjectNumber :_feb ,XType :XrefTypeObjectStream ,OsObjNumber :int (_degef ),OsObjIndex :int (_fagdd )};_bfed ._bdda .ObjectMap [_feb ]=_dgba ;_af .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_dgba );};}else {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _bfed ._dffg ==nil {_cbce :=XrefTypeObjectStream ;_bfed ._dffg =&_cbce ;};return _gdgcf ,nil ;};var _dedd =_db .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func _bfbd (_faf int )int {_afdafa :=_faf >>(_acgd -1);return (_faf ^_afdafa )-_afdafa };

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_ccdd []float64 ,_cadd error ){for _ ,_efcf :=range objects {_dbbb ,_cbeag :=GetNumberAsFloat (_efcf );if _cbeag !=nil {return nil ,_cbeag ;};_ccdd =append (_ccdd ,_dbbb );};return _ccdd ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_afdf []PdfObject ;};var _edcg =_db .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_abgfg *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_abgfg .GetFilterName ());return data ,ErrNoJPXDecode ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bcdfg _eaf .Buffer ;_bcdfg .Write ([]byte {0xFE,0xFF});_bcdfg .WriteString (_ec .StringToUTF16 (s ));return &PdfObjectString {_eagbf :_bcdfg .String (),_geef :true };};return &PdfObjectString {_eagbf :string (_ec .StringToPDFDocEncoding (s )),_geef :false };};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_edgg :=PdfObjectNull {};return &_edgg };

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gbee *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_af .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gbee .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// WriteString outputs the object as it is to be written to file.
func (_dfee *PdfObjectInteger )WriteString ()string {return _c .FormatInt (int64 (*_dfee ),10)};func (_cdfa *PdfParser )traceStreamLength (_cbcee PdfObject )(PdfObject ,error ){_fagdb ,_cfedb :=_cbcee .(*PdfObjectReference );if _cfedb {_ffgba ,_agcdc :=_cdfa ._gfbfa [_fagdb .ObjectNumber ];if _agcdc &&_ffgba {_af .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_a .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cdfa ._gfbfa [_fagdb .ObjectNumber ]=true ;};_babf ,_ffcc :=_cdfa .Resolve (_cbcee );if _ffcc !=nil {return nil ,_ffcc ;};_af .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_babf );if _cfedb {_cdfa ._gfbfa [_fagdb .ObjectNumber ]=false ;};return _babf ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _ddgcb (obj ,0)};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// GetFilterName returns the name of the encoding filter.
func (_daca *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_agd *PdfCrypt )generateParams (_afa ,_cge []byte )error {_cdc :=_agd .securityHandler ();_aacgf ,_aff :=_cdc .GenerateParams (&_agd ._cabf ,_cge ,_afa );if _aff !=nil {return _aff ;};_agd ._bdb =_aacgf ;return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfgb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_daed *JBIG2Encoder )DecodeGlobals (encoded []byte )(_dca .Globals ,error ){return _dca .DecodeGlobals (encoded );};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_dbcba *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_edea :=&_bb .Encoder {K :_dbcba .K ,Columns :_dbcba .Columns ,EndOfLine :_dbcba .EndOfLine ,EndOfBlock :_dbcba .EndOfBlock ,BlackIs1 :_dbcba .BlackIs1 ,DamagedRowsBeforeError :_dbcba .DamagedRowsBeforeError ,Rows :_dbcba .Rows ,EncodedByteAlign :_dbcba .EncodedByteAlign };_gdaa ,_cgcg :=_edea .Decode (encoded );if _cgcg !=nil {return nil ,_cgcg ;};var _aegc []byte ;_dgcfa :=0;var _eggg byte ;var _fgdf byte ;for _caaf :=range _gdaa {if _eggg !=0{_aegc =append (_aegc ,_fgdf );_fgdf =0;_dgcfa ++;_eggg =0;};for _cbga :=range _gdaa [_caaf ]{_fgdf |=_gdaa [_caaf ][_cbga ]<<(7-_eggg );_eggg ++;if _eggg ==8{_aegc =append (_aegc ,_fgdf );_fgdf =0;_dgcfa ++;_eggg =0;};};};if _eggg > 0{_aegc =append (_aegc ,_fgdf );};return _aegc ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_debf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_cdgg :=MakeDict ();_cdgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_debf .GetFilterName ()));return _cdgg ;};var _gede =_db .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// UpdateParams updates the parameter values of the encoder.
func (_dgcd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_eg .Model ;Bounds ()_eb .Rectangle ;At (_aacge ,_cfe int )_eg .Color ;Set (_abf ,_cea int ,_eagd _eg .Color );};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_ecgb *MultiEncoder )GetFilterName ()string {_acgg :="";for _dabbc ,_cdag :=range _ecgb ._fab {_acgg +=_cdag .GetFilterName ();if _dabbc < len (_ecgb ._fab )-1{_acgg +="\u0020";};};return _acgg ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_aacea *PdfIndirectObject ,_cafa bool ){obj =ResolveReference (obj );_aacea ,_cafa =obj .(*PdfIndirectObject );return _aacea ,_cafa ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dgebb *PdfObjectArray ,_gfbcg bool ){_dgebb ,_gfbcg =TraceToDirectObject (obj ).(*PdfObjectArray );return _dgebb ,_gfbcg ;};const (DefaultJPEGQuality =75;);func (_aaecg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_aaecg ._eagbg .Seek (0,_ea .SEEK_SET );_aaecg ._ecagb =_ddc .NewReader (_aaecg ._eagbg );_bddg :=20;_bbac :=make ([]byte ,_bddg );for {_ggcgb ,_ecbb :=_aaecg ._ecagb .ReadByte ();if _ecbb !=nil {if _ecbb ==_e .EOF {break ;}else {return 0,0,_ecbb ;};};if IsDecimalDigit (_ggcgb )&&_bbac [_bddg -1]=='.'&&IsDecimalDigit (_bbac [_bddg -2])&&_bbac [_bddg -3]=='-'&&_bbac [_bddg -4]=='F'&&_bbac [_bddg -5]=='D'&&_bbac [_bddg -6]=='P'{_dage :=int (_bbac [_bddg -2]-'0');_dbdaa :=int (_ggcgb -'0');return _dage ,_dbdaa ,nil ;};_bbac =append (_bbac [1:_bddg ],_ggcgb );};return 0,0,_a .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bcg :=&PdfCrypt {_cd :false ,_gggb :make (map[PdfObject ]bool ),_afd :make (map[PdfObject ]bool ),_dfg :make (map[int ]struct{}),_ddb :parser };_eada ,_cbb :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_cbb {_af .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bcg ,_a .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_eada !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_af .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_eada );return _bcg ,_a .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bcg ._bbbb .Filter =string (*_eada );if _gdf ,_cefa :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_cefa {_bcg ._bbbb .SubFilter =_gdf .Str ();_af .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gdf );};if L ,_ddcb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ddcb {if (*L %8)!=0{_af .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bcg ,_a .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bcg ._bbbb .Length =int (*L );}else {_bcg ._bbbb .Length =40;};_bcg ._bbbb .V =0;if _egeb ,_ecee :=ed .Get ("\u0056").(*PdfObjectInteger );_ecee {V :=int (*_egeb );_bcg ._bbbb .V =V ;if V >=1&&V <=2{_bcg ._aea =_fcf (_bcg ._bbbb .Length );}else if V >=4&&V <=5{if _dcga :=_bcg .loadCryptFilters (ed );_dcga !=nil {return _bcg ,_dcga ;};}else {_af .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bcg ,_a .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _afdc :=_acf (&_bcg ._cabf ,ed );_afdc !=nil {return _bcg ,_afdc ;};_dbb :="";if _beg ,_bcga :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_bcga &&_beg .Len ()>=1{_bfc ,_dcff :=GetString (_beg .Get (0));if !_dcff {return _bcg ,_a .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_dbb =_bfc .Str ();}else {_af .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bcg ._baf =_dbb ;return _bcg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cec *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_edggg *PdfObjectDictionary )WriteString ()string {var _aedc _dd .Builder ;_aedc .WriteString ("\u003c\u003c");for _ ,_gdbe :=range _edggg ._beda {_egfe :=_edggg ._dcafa [_gdbe ];_aedc .WriteString (_gdbe .WriteString ());_aedc .WriteString ("\u0020");_aedc .WriteString (_egfe .WriteString ());};_aedc .WriteString ("\u003e\u003e");return _aedc .String ();};func _bec (_aac PdfObject )(int64 ,int64 ,error ){if _gfg ,_eafb :=_aac .(*PdfIndirectObject );_eafb {return _gfg .ObjectNumber ,_gfg .GenerationNumber ,nil ;};if _bga ,_fd :=_aac .(*PdfObjectStream );_fd {return _bga .ObjectNumber ,_bga .GenerationNumber ,nil ;};return 0,0,_a .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebcc *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbgb :=MakeDict ();_bbgb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebcc .GetFilterName ()));return _bbgb ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_dcffca *PdfObjectArray )Get (i int )PdfObject {if _dcffca ==nil ||i >=len (_dcffca ._deedf )||i < 0{return nil ;};return _dcffca ._deedf [i ];};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _ecfgf ,_dbbc :=obj .(*PdfObjectReference );_dbbc {return _ecfgf .Resolve ();};return obj ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bded Version )String ()string {return _ac .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bded .Major ,_bded .Minor );};func _acb (_gdac *PdfObjectStream )(*MultiEncoder ,error ){_eaadd :=NewMultiEncoder ();_bcf :=_gdac .PdfObjectDictionary ;if _bcf ==nil {return _eaadd ,nil ;};var _dabd *PdfObjectDictionary ;var _dgce []PdfObject ;_bcfa :=_bcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _bcfa !=nil {_dggf ,_adea :=_bcfa .(*PdfObjectDictionary );if _adea {_dabd =_dggf ;};_eaaf ,_cdgdb :=_bcfa .(*PdfObjectArray );if _cdgdb {for _ ,_ecg :=range _eaaf .Elements (){_ecg =TraceToDirectObject (_ecg );if _aaf ,_gcd :=_ecg .(*PdfObjectDictionary );_gcd {_dgce =append (_dgce ,_aaf );}else {_dgce =append (_dgce ,MakeDict ());};};};};_bcfa =_bcf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _bcfa ==nil {return nil ,_ac .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_cba ,_afad :=_bcfa .(*PdfObjectArray );if !_afad {return nil ,_ac .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _gada ,_aggaa :=range _cba .Elements (){_fggb ,_ecde :=_aggaa .(*PdfObjectName );if !_ecde {return nil ,_ac .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _cbd PdfObject ;if _dabd !=nil {_cbd =_dabd ;}else {if len (_dgce )> 0{if _gada >=len (_dgce ){return nil ,_ac .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_cbd =_dgce [_gada ];};};var _abbe *PdfObjectDictionary ;if _ccge ,_cbbf :=_cbd .(*PdfObjectDictionary );_cbbf {_abbe =_ccge ;};_af .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_fggb ,_cbd ,_abbe );if *_fggb ==StreamEncodingFilterNameFlate {_ebde ,_dag :=_gag (_gdac ,_abbe );if _dag !=nil {return nil ,_dag ;};_eaadd .AddEncoder (_ebde );}else if *_fggb ==StreamEncodingFilterNameLZW {_dcgd ,_aeca :=_ecdf (_gdac ,_abbe );if _aeca !=nil {return nil ,_aeca ;};_eaadd .AddEncoder (_dcgd );}else if *_fggb ==StreamEncodingFilterNameASCIIHex {_efae :=NewASCIIHexEncoder ();_eaadd .AddEncoder (_efae );}else if *_fggb ==StreamEncodingFilterNameASCII85 {_cbec :=NewASCII85Encoder ();_eaadd .AddEncoder (_cbec );}else if *_fggb ==StreamEncodingFilterNameDCT {_deeb ,_abee :=_bdf (_gdac ,_eaadd );if _abee !=nil {return nil ,_abee ;};_eaadd .AddEncoder (_deeb );_af .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_af .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_eaadd );}else {_af .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_fggb );return nil ,_ac .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _eaadd ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dfaf *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bedbe :=MakeDict ();_bedbe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfaf .GetFilterName ()));return _bedbe ;};