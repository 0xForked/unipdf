//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_db "bufio";_fce "bytes";_cc "compress/lzw";_fc "compress/zlib";_ec "crypto/md5";_dg "crypto/rand";_be "encoding/hex";_ab "errors";_ccd "fmt";_bc "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/core/security";_fbb "github.com/unidoc/unipdf/v3/core/security/crypt";_gf "github.com/unidoc/unipdf/v3/internal/ccittfax";_ba "github.com/unidoc/unipdf/v3/internal/imageutil";_eb "github.com/unidoc/unipdf/v3/internal/jbig2";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_abb "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ecf "github.com/unidoc/unipdf/v3/internal/jbig2/document";_de "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cg "github.com/unidoc/unipdf/v3/internal/strutils";_fd "golang.org/x/image/tiff/lzw";_agg "golang.org/x/xerrors";_f "image";_ga "image/color";_c "image/jpeg";_bg "io";_ag "reflect";_g "regexp";_e "sort";_b "strconv";_dc "strings";_d "time";);

// String returns a string representation of the *PdfObjectString.
func (_cfcd *PdfObjectString )String ()string {return _cfcd ._gafc };

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// GetFilterName returns the name of the encoding filter.
func (_eceg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// UpdateParams updates the parameter values of the encoder.
func (_beba *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_cbce :=range _beba ._beb {_cbce .UpdateParams (params );};};func (_bcf *PdfParser )lookupByNumberWrapper (_ff int ,_dac bool )(PdfObject ,bool ,error ){_ceg ,_beg ,_ddcf :=_bcf .lookupByNumber (_ff ,_dac );if _ddcf !=nil {return nil ,_beg ,_ddcf ;};if !_beg &&_bcf ._abbbc !=nil &&!_bcf ._abbbc .isDecrypted (_ceg ){_dab :=_bcf ._abbbc .Decrypt (_ceg ,0,0);if _dab !=nil {return nil ,_beg ,_dab ;};};return _ceg ,_beg ,nil ;};var _ffbdf =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fcfd *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fcfd .GetFilterName ());return data ,ErrNoJPXDecode ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_dafg *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _ddgf _fce .Buffer ;for _bbce :=0;_bbce < len (data );_bbce +=4{_bgeb :=data [_bbce ];_geff :=1;_bgda :=byte (0);if _bbce +1< len (data ){_bgda =data [_bbce +1];_geff ++;};_ecfb :=byte (0);if _bbce +2< len (data ){_ecfb =data [_bbce +2];_geff ++;};_ffed :=byte (0);if _bbce +3< len (data ){_ffed =data [_bbce +3];_geff ++;};_bbfb :=(uint32 (_bgeb )<<24)|(uint32 (_bgda )<<16)|(uint32 (_ecfb )<<8)|uint32 (_ffed );if _bbfb ==0{_ddgf .WriteByte ('z');}else {_aee :=_dafg .base256Tobase85 (_bbfb );for _ ,_fcea :=range _aee [:_geff +1]{_ddgf .WriteByte (_fcea +'!');};};};_ddgf .WriteString ("\u007e\u003e");return _ddgf .Bytes (),nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_ggbg *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_bc .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_cbeg :=MakeDict ();_cbeg ._adfc =_ggbg ;_cegb ,_ :=_ggbg ._dcada .ReadByte ();if _cegb !='<'{return nil ,_ab .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_cegb ,_ =_ggbg ._dcada .ReadByte ();if _cegb !='<'{return nil ,_ab .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_ggbg .skipSpaces ();_ggbg .skipComments ();_acdc ,_eeae :=_ggbg ._dcada .Peek (2);if _eeae !=nil {return nil ,_eeae ;};_bc .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_acdc ),string (_acdc ));if (_acdc [0]=='>')&&(_acdc [1]=='>'){_bc .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_ggbg ._dcada .ReadByte ();_ggbg ._dcada .ReadByte ();break ;};_bc .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_eacb ,_eeae :=_ggbg .parseName ();_bc .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_eacb );if _eeae !=nil {_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_eeae );return nil ,_eeae ;};if len (_eacb )> 4&&_eacb [len (_eacb )-4:]=="\u006e\u0075\u006c\u006c"{_cfgea :=_eacb [0:len (_eacb )-4];_bc .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_eacb );_bc .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_cfgea );_ggbg .skipSpaces ();_ggee ,_ :=_ggbg ._dcada .Peek (1);if _ggee [0]=='/'{_cbeg .Set (_cfgea ,MakeNull ());continue ;};};_ggbg .skipSpaces ();_eacd ,_eeae :=_ggbg .parseObject ();if _eeae !=nil {return nil ,_eeae ;};_cbeg .Set (_eacb ,_eacd );if _bc .Log .IsLogLevel (_bc .LogLevelTrace ){_bc .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_eacb ,_eacd .String ());};};_bc .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _cbeg ,nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func (_cbgd *PdfCrypt )generateParams (_bbgb ,_efed []byte )error {_geeg :=_cbgd .securityHandler ();_eaad ,_dad :=_geeg .GenerateParams (&_cbgd ._bbe ,_efed ,_bbgb );if _dad !=nil {return _dad ;};_cbgd ._cce =_eaad ;return nil ;};func (_gddcd *offsetReader )Read (p []byte )(_ddde int ,_acdb error ){return _gddcd ._bged .Read (p )};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cgbc *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// UpdateParams updates the parameter values of the encoder.
func (_cbff *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_edad :objects };};var _bec =_g .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_gbg *JBIG2Encoder )EncodeImage (img _f .Image )([]byte ,error ){return _gbg .encodeImage (img )};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fgfd []PdfObject };func (_cfge *PdfCrypt )makeKey (_edc string ,_ebga ,_dgefe uint32 ,_ebfg []byte )([]byte ,error ){_fdd ,_abcd :=_cfge ._ege [_edc ];if !_abcd {return nil ,_ccd .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_edc );};return _fdd .MakeKey (_ebga ,_dgefe ,_ebfg );};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_cbga :=PdfObjectName (s );return &_cbga };const (DefaultJPEGQuality =75;);

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};func (_dcff *PdfParser )parseString ()(*PdfObjectString ,error ){_dcff ._dcada .ReadByte ();var _cfga _fce .Buffer ;_bfceb :=1;for {_abgc ,_bfcag :=_dcff ._dcada .Peek (1);if _bfcag !=nil {return MakeString (_cfga .String ()),_bfcag ;};if _abgc [0]=='\\'{_dcff ._dcada .ReadByte ();_afac ,_feebd :=_dcff ._dcada .ReadByte ();if _feebd !=nil {return MakeString (_cfga .String ()),_feebd ;};if IsOctalDigit (_afac ){_eeaf ,_dddbd :=_dcff ._dcada .Peek (2);if _dddbd !=nil {return MakeString (_cfga .String ()),_dddbd ;};var _geec []byte ;_geec =append (_geec ,_afac );for _ ,_afbfa :=range _eeaf {if IsOctalDigit (_afbfa ){_geec =append (_geec ,_afbfa );}else {break ;};};_dcff ._dcada .Discard (len (_geec )-1);_bc .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_geec );_cgcc ,_dddbd :=_b .ParseUint (string (_geec ),8,32);if _dddbd !=nil {return MakeString (_cfga .String ()),_dddbd ;};_cfga .WriteByte (byte (_cgcc ));continue ;};switch _afac {case 'n':_cfga .WriteRune ('\n');case 'r':_cfga .WriteRune ('\r');case 't':_cfga .WriteRune ('\t');case 'b':_cfga .WriteRune ('\b');case 'f':_cfga .WriteRune ('\f');case '(':_cfga .WriteRune ('(');case ')':_cfga .WriteRune (')');case '\\':_cfga .WriteRune ('\\');};continue ;}else if _abgc [0]=='('{_bfceb ++;}else if _abgc [0]==')'{_bfceb --;if _bfceb ==0{_dcff ._dcada .ReadByte ();break ;};};_eaed ,_ :=_dcff ._dcada .ReadByte ();_cfga .WriteByte (_eaed );};return MakeString (_cfga .String ()),nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_fgba :=PdfObjectString {_gafc :s };return &_fgba };

// GetFilterName returns the name of the encoding filter.
func (_gdba *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_fbba *JBIG2Encoder )encodeImage (_gfab _f .Image )([]byte ,error ){const _cbedc ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_fcgf ,_gadd :=GoImageToJBIG2 (_gfab ,JB2ImageAutoThreshold );if _gadd !=nil {return nil ,_de .Wrap (_gadd ,_cbedc ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _gadd =_fbba .AddPageImage (_fcgf ,&_fbba .DefaultPageSettings );_gadd !=nil {return nil ,_de .Wrap (_gadd ,_cbedc ,"");};return _fbba .Encode ();};

// String returns a string describing `d`.
func (_fccefa *PdfObjectDictionary )String ()string {var _ebed _dc .Builder ;_ebed .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_cfeee :=range _fccefa ._bcffe {_accg :=_fccefa ._edef [_cfeee ];_ebed .WriteString ("\u0022"+_cfeee .String ()+"\u0022\u003a\u0020");_ebed .WriteString (_accg .String ());_ebed .WriteString ("\u002c\u0020");};_ebed .WriteString ("\u0029");return _ebed .String ();};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_fbdc *PdfObjectDictionary )Keys ()[]PdfObjectName {if _fbdc ==nil {return nil ;};return _fbdc ._bcffe ;};var _bfge =_g .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_gade *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_gade ._geaf .Seek (0,_bg .SeekStart );_gade ._dcada =_db .NewReader (_gade ._geaf );_fcge :=20;_bbcg :=make ([]byte ,_fcge );for {_cecgc ,_aeaa :=_gade ._dcada .ReadByte ();if _aeaa !=nil {if _aeaa ==_bg .EOF {break ;}else {return 0,0,_aeaa ;};};if IsDecimalDigit (_cecgc )&&_bbcg [_fcge -1]=='.'&&IsDecimalDigit (_bbcg [_fcge -2])&&_bbcg [_fcge -3]=='-'&&_bbcg [_fcge -4]=='F'&&_bbcg [_fcge -5]=='D'&&_bbcg [_fcge -6]=='P'{_bcge :=int (_bbcg [_fcge -2]-'0');_ebfb :=int (_cecgc -'0');return _bcge ,_ebfb ,nil ;};_bbcg =append (_bbcg [1:_fcge ],_cecgc );};return 0,0,_ab .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_agb *PdfObjectDictionary );EncodeBytes (_ecbc []byte )([]byte ,error );DecodeBytes (_aaf []byte )([]byte ,error );DecodeStream (_fee *PdfObjectStream )([]byte ,error );};func _cbaf (_efdgf int )int {if _efdgf < 0{return -_efdgf ;};return _efdgf ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_gafc string ;_bfee bool ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gfb *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_aafc :=data ;var _befad error ;for _adead :=len (_gfb ._beb )-1;_adead >=0;_adead --{_ageg :=_gfb ._beb [_adead ];_aafc ,_befad =_ageg .EncodeBytes (_aafc );if _befad !=nil {return nil ,_befad ;};};return _aafc ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gafa :=PdfObjectFloat (val );return &_gafa };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_bdaa *PdfObjectString )Str ()string {return _bdaa ._gafc };

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_egdg :=MakeArray ();for _ ,_abeg :=range vals {_egdg .Append (MakeFloat (_abeg ));};return _egdg ;};

// Append appends PdfObject(s) to the streams.
func (_gcce *PdfObjectStreams )Append (objects ...PdfObject ){if _gcce ==nil {_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_gcce ._edad =append (_gcce ._edad ,objects ...);};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_affe *_ecf .Document ;

// Globals are the JBIG2 global segments.
Globals _eb .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func (_aecb *PdfCrypt )checkAccessRights (_bgb []byte )(bool ,_fb .Permissions ,error ){_cge :=_aecb .securityHandler ();_dbc ,_agff ,_efe :=_cge .Authenticate (&_aecb ._bbe ,_bgb );if _efe !=nil {return false ,0,_efe ;}else if _agff ==0||len (_dbc )==0{return false ,0,nil ;};return true ,_agff ,nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_daeb :=&DCTEncoder {};_daeb .ColorComponents =3;_daeb .BitsPerComponent =8;_daeb .Quality =DefaultJPEGQuality ;return _daeb ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_eggf *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_bcdbg string ,_cbde bool ){_dcda ,_cbde :=TraceToDirectObject (obj ).(*PdfObjectName );if _cbde {return string (*_dcda ),true ;};return ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_cbc *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbc .DecodeBytes (streamObj .Stream );};

// UpdateParams updates the parameter values of the encoder.
func (_geeb *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_gffd ,_gge :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _gge ==nil {_geeb .Predictor =int (_gffd );};_degb ,_gge :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gge ==nil {_geeb .BitsPerComponent =int (_degb );};_eafb ,_gge :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gge ==nil {_geeb .Columns =int (_eafb );};_dgf ,_gge :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gge ==nil {_geeb .Colors =int (_dgf );};_fafe ,_gge :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _gge ==nil {_geeb .EarlyChange =int (_fafe );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_eeac *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_cca :=MakeDict ();_cca .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eeac .GetFilterName ()));_aadb :=_eeac .MakeDecodeParams ();if _aadb !=nil {_cca .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aadb );};_cca .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_eeac .EarlyChange )));return _cca ;};

// String returns a descriptive information string about the encryption method used.
func (_egbb *PdfCrypt )String ()string {if _egbb ==nil {return "";};_ffa :=_egbb ._bbfc .Filter +"\u0020\u002d\u0020";if _egbb ._bbfc .V ==0{_ffa +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _egbb ._bbfc .V ==1{_ffa +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _egbb ._bbfc .V ==2{_ffa +=_ccd .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_egbb ._bbfc .Length );}else if _egbb ._bbfc .V ==3{_ffa +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _egbb ._bbfc .V >=4{_ffa +=_ccd .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_egbb ._ecc ,_egbb ._gac );_ffa +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _gga ,_gbc :=range _egbb ._ege {_ffa +=_ccd .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_gga ,_gbc .Name (),_gbc .KeyLength ());};};_gaa :=_egbb .GetAccessPermissions ();_ffa +=_ccd .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_gaa );return _ffa ;};const _efadg =10;

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _debb _fce .Buffer ;_debb .Write ([]byte {0xFE,0xFF});_debb .WriteString (_cg .StringToUTF16 (s ));return &PdfObjectString {_gafc :_debb .String (),_bfee :true };};return &PdfObjectString {_gafc :string (_cg .StringToPDFDocEncoding (s )),_bfee :false };};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bfec *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cdbf :=&_gf .Encoder {K :_bfec .K ,Columns :_bfec .Columns ,EndOfLine :_bfec .EndOfLine ,EndOfBlock :_bfec .EndOfBlock ,BlackIs1 :_bfec .BlackIs1 ,DamagedRowsBeforeError :_bfec .DamagedRowsBeforeError ,Rows :_bfec .Rows ,EncodedByteAlign :_bfec .EncodedByteAlign };_cfcc ,_ddag :=_cdbf .Decode (encoded );if _ddag !=nil {return nil ,_ddag ;};var _gbf []byte ;_dbgcf :=0;var _dfgd byte ;var _bga byte ;for _ggcg :=range _cfcc {if _dfgd !=0{_gbf =append (_gbf ,_bga );_bga =0;_dbgcf ++;_dfgd =0;};for _bgce :=range _cfcc [_ggcg ]{_bga |=_cfcc [_ggcg ][_bgce ]<<(7-_dfgd );_dfgd ++;if _dfgd ==8{_gbf =append (_gbf ,_bga );_bga =0;_dbgcf ++;_dfgd =0;};};};if _dfgd > 0{_gbf =append (_gbf ,_bga );};return _gbf ,nil ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ffeda *PdfObjectDictionary ,_bdeeb bool ){_ffeda ,_bdeeb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ffeda ,_bdeeb ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_fgfd :objects }};

// WriteString outputs the object as it is to be written to file.
func (_fabe *PdfObjectFloat )WriteString ()string {return _b .FormatFloat (float64 (*_fabe ),'f',-1,64);};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_edfdc *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cecca ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _edfdc .ColorComponents !=1||_edfdc .BitsPerComponent !=1{return nil ,_de .Errorf (_cecca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_dfcc *_fg .Bitmap ;_fcgg error ;);_daeg :=(_edfdc .Width *_edfdc .Height )==len (data );if _daeg {_dfcc ,_fcgg =_fg .NewWithUnpaddedData (_edfdc .Width ,_edfdc .Height ,data );}else {_dfcc ,_fcgg =_fg .NewWithData (_edfdc .Width ,_edfdc .Height ,data );};if _fcgg !=nil {return nil ,_fcgg ;};_fbga :=_edfdc .DefaultPageSettings ;if _fcgg =_fbga .Validate ();_fcgg !=nil {return nil ,_de .Wrap (_fcgg ,_cecca ,"");};switch _fbga .Compression {case JB2Generic :if _fcgg =_edfdc ._affe .AddGenericPage (_dfcc ,_fbga .DuplicatedLinesRemoval );_fcgg !=nil {return nil ,_de .Wrap (_fcgg ,_cecca ,"");};case JB2SymbolCorrelation :return nil ,_de .Error (_cecca ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_de .Error (_cecca ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_de .Error (_cecca ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _edfdc .Encode ();};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_cfca :=&PdfIndirectObject {};_cfca .PdfObject =obj ;return _cfca ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_ecgd *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ecgd .GetFilterName ());return encoded ,ErrNoJPXDecode ;};func (_fef *PdfCrypt )isEncrypted (_cgee PdfObject )bool {_ ,_gea :=_fef ._baf [_cgee ];if _gea {_bc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_bc .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_ga .Model ;Bounds ()_f .Rectangle ;At (_deaf ,_fdaf int )_ga .Color ;Set (_cfgd ,_geab int ,_facfa _ga .Color );};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_db .Reader )(PdfObject ,error ){_bcbagf :=false ;_cfeeda :=true ;var _ggeba _fce .Buffer ;for {if _bc .Log .IsLogLevel (_bc .LogLevelTrace ){_bc .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ggeba .String ());};_adebb ,_aabfa :=buf .Peek (1);if _aabfa ==_bg .EOF {break ;};if _aabfa !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_aabfa );return nil ,_aabfa ;};if _cfeeda &&(_adebb [0]=='-'||_adebb [0]=='+'){_badd ,_ :=buf .ReadByte ();_ggeba .WriteByte (_badd );_cfeeda =false ;}else if IsDecimalDigit (_adebb [0]){_aaef ,_ :=buf .ReadByte ();_ggeba .WriteByte (_aaef );}else if _adebb [0]=='.'{_agdcd ,_ :=buf .ReadByte ();_ggeba .WriteByte (_agdcd );_bcbagf =true ;}else if _adebb [0]=='e'||_adebb [0]=='E'{_dfgf ,_ :=buf .ReadByte ();_ggeba .WriteByte (_dfgf );_bcbagf =true ;_cfeeda =true ;}else {break ;};};var _gebb PdfObject ;if _bcbagf {_gfef ,_cdffb :=_b .ParseFloat (_ggeba .String (),64);if _cdffb !=nil {_bc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ggeba .String (),_cdffb );_gfef =0.0;};_bfaa :=PdfObjectFloat (_gfef );_gebb =&_bfaa ;}else {_befc ,_bacec :=_b .ParseInt (_ggeba .String (),10,64);if _bacec !=nil {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ggeba .String (),_bacec );_befc =0;};_gacacb :=PdfObjectInteger (_befc );_gebb =&_gacacb ;};return _gebb ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gbdg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ffbe :=range another .Keys (){_eegd :=another .Get (_ffbe );_gbdg .Set (_ffbe ,_eegd );};};return _gbdg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fdbeg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ecef :=MakeDict ();_ecef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fdbeg .GetFilterName ()));return _ecef ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_cfaca *PdfObjectArray )Elements ()[]PdfObject {if _cfaca ==nil {return nil ;};return _cfaca ._fgfd ;};func (_afbf *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_afbf ._dcada )};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_ceff *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ebeg error ){const _gdbfb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _ceff ==nil {return _de .Error (_gdbfb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_ceff .DefaultPageSettings ;};if _ceff ._affe ==nil {_ceff ._affe =_ecf .InitEncodeDocument (settings .FileMode );};if _ebeg =settings .Validate ();_ebeg !=nil {return _de .Wrap (_ebeg ,_gdbfb ,"");};_bfcaa ,_ebeg :=img .toBitmap ();if _ebeg !=nil {return _de .Wrap (_ebeg ,_gdbfb ,"");};switch settings .Compression {case JB2Generic :if _ebeg =_ceff ._affe .AddGenericPage (_bfcaa ,settings .DuplicatedLinesRemoval );_ebeg !=nil {return _de .Wrap (_ebeg ,_gdbfb ,"");};case JB2SymbolCorrelation :return _de .Error (_gdbfb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _de .Error (_gdbfb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _de .Error (_gdbfb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};var _faab =_g .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_baga *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_gefg :=MakeDict ();_gefg .Set ("\u004b",MakeInteger (int64 (_baga .K )));_gefg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_baga .Columns )));if _baga .BlackIs1 {_gefg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_baga .BlackIs1 ));};if _baga .EncodedByteAlign {_gefg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_baga .EncodedByteAlign ));};if _baga .EndOfLine &&_baga .K >=0{_gefg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_baga .EndOfLine ));};if _baga .Rows !=0&&!_baga .EndOfBlock {_gefg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_baga .Rows )));};if !_baga .EndOfBlock {_gefg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_baga .EndOfBlock ));};if _baga .DamagedRowsBeforeError !=0{_gefg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_baga .DamagedRowsBeforeError )));};return _gefg ;};

// Len returns the number of elements in the array.
func (_agag *PdfObjectArray )Len ()int {if _agag ==nil {return 0;};return len (_agag ._fgfd );};var _decb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_edcde *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_edcde ._edad ){return _ab .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_edcde ._edad [i ]=obj ;return nil ;};var _edbd =_g .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_caag *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func _bfce (_fdcc *PdfObjectStream )(*MultiEncoder ,error ){_cdad :=NewMultiEncoder ();_fccf :=_fdcc .PdfObjectDictionary ;if _fccf ==nil {return _cdad ,nil ;};var _gbe *PdfObjectDictionary ;var _fgfa []PdfObject ;_gegfb :=_fccf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gegfb !=nil {_cccf ,_bgaf :=_gegfb .(*PdfObjectDictionary );if _bgaf {_gbe =_cccf ;};_afde ,_cbb :=_gegfb .(*PdfObjectArray );if _cbb {for _ ,_dfabd :=range _afde .Elements (){_dfabd =TraceToDirectObject (_dfabd );if _fbe ,_eeebe :=_dfabd .(*PdfObjectDictionary );_eeebe {_fgfa =append (_fgfa ,_fbe );}else {_fgfa =append (_fgfa ,MakeDict ());};};};};_gegfb =_fccf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _gegfb ==nil {return nil ,_ccd .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_gbac ,_dbed :=_gegfb .(*PdfObjectArray );if !_dbed {return nil ,_ccd .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _ebaa ,_dgfa :=range _gbac .Elements (){_gfdf ,_bcgb :=_dgfa .(*PdfObjectName );if !_bcgb {return nil ,_ccd .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _cebb PdfObject ;if _gbe !=nil {_cebb =_gbe ;}else {if len (_fgfa )> 0{if _ebaa >=len (_fgfa ){return nil ,_ccd .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_cebb =_fgfa [_ebaa ];};};var _dddb *PdfObjectDictionary ;if _dbgd ,_baag :=_cebb .(*PdfObjectDictionary );_baag {_dddb =_dbgd ;};_bc .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gfdf ,_cebb ,_dddb );if *_gfdf ==StreamEncodingFilterNameFlate {_cbbe ,_adfd :=_fedgf (_fdcc ,_dddb );if _adfd !=nil {return nil ,_adfd ;};_cdad .AddEncoder (_cbbe );}else if *_gfdf ==StreamEncodingFilterNameLZW {_afceb ,_fgfg :=_cceg (_fdcc ,_dddb );if _fgfg !=nil {return nil ,_fgfg ;};_cdad .AddEncoder (_afceb );}else if *_gfdf ==StreamEncodingFilterNameASCIIHex {_daec :=NewASCIIHexEncoder ();_cdad .AddEncoder (_daec );}else if *_gfdf ==StreamEncodingFilterNameASCII85 {_add :=NewASCII85Encoder ();_cdad .AddEncoder (_add );}else if *_gfdf ==StreamEncodingFilterNameDCT {_dgd ,_addc :=_bdb (_fdcc ,_cdad );if _addc !=nil {return nil ,_addc ;};_cdad .AddEncoder (_dgd );_bc .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_bc .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_cdad );}else {_bc .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gfdf );return nil ,_ccd .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _cdad ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func (_ccae *PdfParser )readComment ()(string ,error ){var _facg _fce .Buffer ;_ ,_dbcb :=_ccae .skipSpaces ();if _dbcb !=nil {return _facg .String (),_dbcb ;};_becd :=true ;for {_afaed ,_gffa :=_ccae ._dcada .Peek (1);if _gffa !=nil {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gffa .Error ());return _facg .String (),_gffa ;};if _becd &&_afaed [0]!='%'{return _facg .String (),_ab .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_becd =false ;if (_afaed [0]!='\r')&&(_afaed [0]!='\n'){_dccce ,_ :=_ccae ._dcada .ReadByte ();_facg .WriteByte (_dccce );}else {break ;};};return _facg .String (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_dgdf *PdfObjectStream )WriteString ()string {var _abec _dc .Builder ;_abec .WriteString (_b .FormatInt (_dgdf .ObjectNumber ,10));_abec .WriteString ("\u0020\u0030\u0020\u0052");return _abec .String ();};func _efbe (_gbffd PdfObject ,_fgaca int ,_ecbd map[PdfObject ]struct{})error {_bc .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fgaca );if _ ,_febgg :=_ecbd [_gbffd ];_febgg {_bc .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ecbd [_gbffd ]=struct{}{};switch _bbega :=_gbffd .(type ){case *PdfIndirectObject :_dcgadc :=_bbega ;_bc .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_dcgadc );_bc .Log .Trace ("\u002d\u0020\u0025\u0073",_dcgadc .PdfObject );return _efbe (_dcgadc .PdfObject ,_fgaca +1,_ecbd );case *PdfObjectStream :_abcg :=_bbega ;return _efbe (_abcg .PdfObjectDictionary ,_fgaca +1,_ecbd );case *PdfObjectDictionary :_afge :=_bbega ;_bc .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_afge );for _ ,_efea :=range _afge .Keys (){_fcdb :=_afge .Get (_efea );if _bebeg ,_bbef :=_fcdb .(*PdfObjectReference );_bbef {_bdbd :=_bebeg .Resolve ();_afge .Set (_efea ,_bdbd );_ecbf :=_efbe (_bdbd ,_fgaca +1,_ecbd );if _ecbf !=nil {return _ecbf ;};}else {_cggce :=_efbe (_fcdb ,_fgaca +1,_ecbd );if _cggce !=nil {return _cggce ;};};};return nil ;case *PdfObjectArray :_bedb :=_bbega ;_bc .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_bedb );for _affd ,_fggd :=range _bedb .Elements (){if _fdac ,_gedb :=_fggd .(*PdfObjectReference );_gedb {_ebcd :=_fdac .Resolve ();_bedb .Set (_affd ,_ebcd );_bebf :=_efbe (_ebcd ,_fgaca +1,_ecbd );if _bebf !=nil {return _bebf ;};}else {_fcef :=_efbe (_fggd ,_fgaca +1,_ecbd );if _fcef !=nil {return _fcef ;};};};return nil ;case *PdfObjectReference :_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _ab .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_fbgg *PdfParser )Decrypt (password []byte )(bool ,error ){if _fbgg ._abbbc ==nil {return false ,_ab .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_agad ,_fdede :=_fbgg ._abbbc .authenticate (password );if _fdede !=nil {return false ,_fdede ;};if !_agad {_agad ,_fdede =_fbgg ._abbbc .authenticate ([]byte (""));};return _agad ,_fdede ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_feeb *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bc .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_bc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_feeb .Predictor );_eabe ,_cdfe :=_feeb .DecodeBytes (streamObj .Stream );if _cdfe !=nil {return nil ,_cdfe ;};_bc .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_bc .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_eabe ),_eabe );if _feeb .Predictor > 1{if _feeb .Predictor ==2{_bc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gaaf :=_feeb .Columns *_feeb .Colors ;if _gaaf < 1{return []byte {},nil ;};_decc :=len (_eabe )/_gaaf ;if len (_eabe )%_gaaf !=0{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eabe ),_gaaf );};if _gaaf %_feeb .Colors !=0{return nil ,_ccd .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_gaaf ,_feeb .Colors );};if _gaaf > len (_eabe ){_bc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gaaf ,len (_eabe ));return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_eabe ),_eabe );_eef :=_fce .NewBuffer (nil );for _eadg :=0;_eadg < _decc ;_eadg ++{_abe :=_eabe [_gaaf *_eadg :_gaaf *(_eadg +1)];for _aab :=_feeb .Colors ;_aab < _gaaf ;_aab ++{_abe [_aab ]=byte (int (_abe [_aab ]+_abe [_aab -_feeb .Colors ])%256);};_eef .Write (_abe );};_fgec :=_eef .Bytes ();_bc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fgec ),_fgec );return _fgec ,nil ;}else if _feeb .Predictor >=10&&_feeb .Predictor <=15{_bc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dfde :=_feeb .Columns *_feeb .Colors +1;if _dfde < 1{return []byte {},nil ;};_ace :=len (_eabe )/_dfde ;if len (_eabe )%_dfde !=0{return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eabe ),_dfde );};if _dfde > len (_eabe ){_bc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dfde ,len (_eabe ));return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggd :=_fce .NewBuffer (nil );_bc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_feeb .Columns );_bc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_eabe ),_dfde ,_ace );_aafa :=make ([]byte ,_dfde );for _fbaa :=0;_fbaa < _dfde ;_fbaa ++{_aafa [_fbaa ]=0;};for _gfe :=0;_gfe < _ace ;_gfe ++{_babaf :=_eabe [_dfde *_gfe :_dfde *(_gfe +1)];_egfg :=_babaf [0];switch _egfg {case 0:case 1:for _gbdf :=2;_gbdf < _dfde ;_gbdf ++{_babaf [_gbdf ]=byte (int (_babaf [_gbdf ]+_babaf [_gbdf -1])%256);};case 2:for _bdge :=1;_bdge < _dfde ;_bdge ++{_babaf [_bdge ]=byte (int (_babaf [_bdge ]+_aafa [_bdge ])%256);};default:_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_egfg );return nil ,_ccd .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_egfg );};for _egbbb :=0;_egbbb < _dfde ;_egbbb ++{_aafa [_egbbb ]=_babaf [_egbbb ];};_ggd .Write (_babaf [1:]);};_bade :=_ggd .Bytes ();return _bade ,nil ;}else {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_feeb .Predictor );return nil ,_ccd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_feeb .Predictor );};};return _eabe ,nil ;};func _bfc (_acc *PdfObjectStream ,_cfaf *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_eaae *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gafd []byte ;_bc .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_dbdf :=0;_gaeb :=false ;for _dbdf < len (encoded )&&!_gaeb {_agdg :=[5]byte {0,0,0,0,0};_agab :=0;_acgd :=0;_cdag :=4;for _acgd < 5+_agab {if _dbdf +_acgd ==len (encoded ){break ;};_debc :=encoded [_dbdf +_acgd ];if IsWhiteSpace (_debc ){_agab ++;_acgd ++;continue ;}else if _debc =='~'&&_dbdf +_acgd +1< len (encoded )&&encoded [_dbdf +_acgd +1]=='>'{_cdag =(_acgd -_agab )-1;if _cdag < 0{_cdag =0;};_gaeb =true ;break ;}else if _debc >='!'&&_debc <='u'{_debc -='!';}else if _debc =='z'&&_acgd -_agab ==0{_cdag =4;_acgd ++;break ;}else {_bc .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_ab .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_agdg [_acgd -_agab ]=_debc ;_acgd ++;};_dbdf +=_acgd ;for _bddg :=_cdag +1;_bddg < 5;_bddg ++{_agdg [_bddg ]=84;};_abceb :=uint32 (_agdg [0])*85*85*85*85+uint32 (_agdg [1])*85*85*85+uint32 (_agdg [2])*85*85+uint32 (_agdg [3])*85+uint32 (_agdg [4]);_fdgef :=[]byte {byte ((_abceb >>24)&0xff),byte ((_abceb >>16)&0xff),byte ((_abceb >>8)&0xff),byte (_abceb &0xff)};_gafd =append (_gafd ,_fdgef [:_cdag ]...);};_bc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_bc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_gafd );return _gafd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dabf *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fgdee :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fgdee ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bagaf *PdfObjectString ,_ddec bool ){_bagaf ,_ddec =TraceToDirectObject (obj ).(*PdfObjectString );return _bagaf ,_ddec ;};func (_abd *PdfCrypt )authenticate (_ffe []byte )(bool ,error ){_abd ._cgd =false ;_ceb :=_abd .securityHandler ();_afe ,_deb ,_bd :=_ceb .Authenticate (&_abd ._bbe ,_ffe );if _bd !=nil {return false ,_bd ;}else if _deb ==0||len (_afe )==0{return false ,nil ;};_abd ._cgd =true ;_abd ._cce =_afe ;return true ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_agc *PdfParser )xrefNextObjectOffset (_eacfc int64 )int64 {_bbbd :=int64 (0);if len (_agc ._cgbd .ObjectMap )==0{return 0;};if len (_agc ._cgbd ._df )==0{_caca :=0;for _ ,_fadd :=range _agc ._cgbd .ObjectMap {if _fadd .Offset > 0{_caca ++;};};if _caca ==0{return 0;};_agc ._cgbd ._df =make ([]XrefObject ,_caca );_agegc :=0;for _ ,_egce :=range _agc ._cgbd .ObjectMap {if _egce .Offset > 0{_agc ._cgbd ._df [_agegc ]=_egce ;_agegc ++;};};_e .Slice (_agc ._cgbd ._df ,func (_cadc ,_bfbdc int )bool {return _agc ._cgbd ._df [_cadc ].Offset < _agc ._cgbd ._df [_bfbdc ].Offset });};_gffcf :=_e .Search (len (_agc ._cgbd ._df ),func (_dgcgg int )bool {return _agc ._cgbd ._df [_dgcgg ].Offset >=_eacfc });if _gffcf < len (_agc ._cgbd ._df ){_bbbd =_agc ._cgbd ._df [_gffcf ].Offset ;};return _bbbd ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_dcdb []float64 ,_cbag error ){for _ ,_fdedd :=range objects {_beae ,_fgc :=GetNumberAsFloat (_fdedd );if _fgc !=nil {return nil ,_fgc ;};_dcdb =append (_dcdb ,_beae );};return _dcdb ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_dcad *MultiEncoder )GetFilterName ()string {_affgf :="";for _babca ,_ecee :=range _dcad ._beb {_affgf +=_ecee .GetFilterName ();if _babca < len (_dcad ._beb )-1{_affgf +="\u0020";};};return _affgf ;};var _eaaea =_g .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_ggag *PdfParser )GetObjectNums ()[]int {var _bcga []int ;for _ ,_egefe :=range _ggag ._cgbd .ObjectMap {_bcga =append (_bcga ,_egefe .ObjectNumber );};_e .Ints (_bcga );return _bcga ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_effd :=PdfObjectBool (val );return &_effd };

// UpdateParams updates the parameter values of the encoder.
func (_feca *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};type offsetReader struct{_bged _bg .ReadSeeker ;_adbg int64 ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_ceae *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeStream implements ASCII85 stream decoding.
func (_afcd *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _afcd .DecodeBytes (streamObj .Stream );};

// UpdateParams updates the parameter values of the encoder.
func (_dafa *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// String returns a string describing `ind`.
func (_ceccd *PdfIndirectObject )String ()string {return _ccd .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_ceccd ).ObjectNumber );};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_fbb .FilterDict ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func _abbd (_ecgb _ba .Image )*JBIG2Image {_cacb :=_ecgb .Base ();return &JBIG2Image {Data :_cacb .Data ,Width :_cacb .Width ,Height :_cacb .Height ,HasPadding :true };};

// Clear resets the array to an empty state.
func (_gedgd *PdfObjectArray )Clear (){_gedgd ._fgfd =[]PdfObject {}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afeg *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// String returns a string describing `ref`.
func (_dbfg *PdfObjectReference )String ()string {return _ccd .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_dbfg .ObjectNumber ,_dbfg .GenerationNumber );};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_fggfa :=MakeArray ();for _ ,_gbff :=range vals {_fggfa .Append (MakeInteger (_gbff ));};return _fggfa ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// Clear resets the dictionary to an empty state.
func (_gdbc *PdfObjectDictionary )Clear (){_gdbc ._bcffe =[]PdfObjectName {};_gdbc ._edef =map[PdfObjectName ]PdfObject {};};func _gdab (_gfaba int )int {_fedgb :=_gfaba >>(_ggfa -1);return (_gfaba ^_fedgb )-_fedgb };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_cggg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_eagg :=_cggg .GetFileOffset ();_ ,_fad :=_cggg ._geaf .Seek (offset ,_bg .SeekStart );if _fad !=nil {return nil ,_fad ;};_dgcdf :=make ([]byte ,len );_ ,_fad =_bg .ReadAtLeast (_cggg ._geaf ,_dgcdf ,int (len ));if _fad !=nil {return nil ,_fad ;};_cggg .SetFileOffset (_eagg );return _dgcdf ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_bafb :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _bafb ==nil {return NewRawEncoder (),nil ;};if _ ,_edadc :=_bafb .(*PdfObjectNull );_edadc {return NewRawEncoder (),nil ;};_bgac ,_aabaf :=_bafb .(*PdfObjectName );if !_aabaf {_gcad ,_edeff :=_bafb .(*PdfObjectArray );if !_edeff {return nil ,_ccd .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _gcad .Len ()==0{return NewRawEncoder (),nil ;};if _gcad .Len ()!=1{_cdcca ,_bbbbg :=_bfce (streamObj );if _bbbbg !=nil {_bc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bbbbg );return nil ,_bbbbg ;};_bc .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_cdcca );return _cdcca ,nil ;};_bafb =_gcad .Get (0);_bgac ,_edeff =_bafb .(*PdfObjectName );if !_edeff {return nil ,_ccd .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bgac {case StreamEncodingFilterNameFlate :return _fedgf (streamObj ,nil );case StreamEncodingFilterNameLZW :return _cceg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bdb (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _bfc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _agaa (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _ceaff (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ccd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bgac );};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _agdd :=obj .(type ){case *PdfObjectFloat :_bc .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_agdd ),nil ;case *PdfObjectInteger :return int64 (*_agdd ),nil ;};return 0,ErrNotANumber ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_abda *PdfParser )IsEncrypted ()(bool ,error ){if _abda ._abbbc !=nil {return true ,nil ;}else if _abda ._dccd ==nil {return false ,nil ;};_bc .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_fecb :=_abda ._dccd .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fecb ==nil {return false ,nil ;};_bc .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_cgeed *PdfObjectDictionary ;);switch _ebebf :=_fecb .(type ){case *PdfObjectDictionary :_cgeed =_ebebf ;case *PdfObjectReference :_bc .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_ebebf );_bgef ,_babge :=_abda .LookupByReference (*_ebebf );_bc .Log .Trace ("\u0031\u003a\u0020%\u0071",_bgef );if _babge !=nil {return false ,_babge ;};_eged ,_geegg :=_bgef .(*PdfIndirectObject );if !_geegg {_bc .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_ab .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_acfad ,_geegg :=_eged .PdfObject .(*PdfObjectDictionary );_bc .Log .Trace ("\u0032\u003a\u0020%\u0071",_acfad );if !_geegg {return false ,_ab .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_cgeed =_acfad ;case *PdfObjectNull :_bc .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ccd .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_ebebf );};_gaae ,_gfbb :=PdfCryptNewDecrypt (_abda ,_cgeed ,_abda ._dccd );if _gfbb !=nil {return false ,_gfbb ;};for _ ,_fccef :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_gfdg :=_abda ._dccd .Get (PdfObjectName (_fccef ));if _gfdg ==nil {continue ;};switch _ccefa :=_gfdg .(type ){case *PdfObjectReference :_gaae ._dec [int (_ccefa .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_gaae ._afg [_ccefa ]=true ;_gaae ._dec [int (_ccefa .ObjectNumber )]=struct{}{};};};_abda ._abbbc =_gaae ;_bc .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_gaae );return true ,nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_beaa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fefe _fce .Buffer ;for _ ,_gaeg :=range data {_fefe .WriteString (_ccd .Sprintf ("\u0025\u002e\u0032X\u0020",_gaeg ));};_fefe .WriteByte ('>');return _fefe .Bytes (),nil ;};func (_bdceb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_agee :=_bdceb ._dcada .Discard (4);return PdfObjectNull {},_agee ;};const _ecab ="\u0053\u0074\u0064C\u0046";

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_aage *MultiEncoder )AddEncoder (encoder StreamEncoder ){_aage ._beb =append (_aage ._beb ,encoder );};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_dcea *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_gced ,_faaa :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _faaa ==nil {_dcea .BitsPerComponent =int (_gced );};_bbbb ,_faaa :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _faaa ==nil {_dcea .Width =int (_bbbb );};_cgc ,_faaa :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _faaa ==nil {_dcea .Height =int (_cgc );};_fbbb ,_faaa :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _faaa ==nil {_dcea .ColorComponents =int (_fbbb );};};func _ceaff (_bdce *PdfObjectStream ,_dgbb *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _acce ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cefe :=&JBIG2Encoder {};_dbcde :=_bdce .PdfObjectDictionary ;if _dbcde ==nil {return _cefe ,nil ;};if _dgbb ==nil {_eafd :=_dbcde .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eafd !=nil {switch _dcgad :=_eafd .(type ){case *PdfObjectDictionary :_dgbb =_dcgad ;case *PdfObjectArray :if _dcgad .Len ()==1{if _cddd ,_gfgc :=GetDict (_dcgad .Get (0));_gfgc {_dgbb =_cddd ;};};default:_bc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_eafd );return nil ,_de .Errorf (_acce ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_dcgad );};};};if _dgbb ==nil {return _cefe ,nil ;};_cefe .UpdateParams (_dgbb );_bebad :=_dgbb .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _bebad ==nil {return _cefe ,nil ;};var _babg error ;_cdab ,_fgeg :=_bebad .(*PdfObjectStream );if !_fgeg {_babg =_de .Error (_acce ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_babg );return nil ,_babg ;};_cefe .Globals ,_babg =_eb .DecodeGlobals (_cdab .Stream );if _babg !=nil {_babg =_de .Wrap (_babg ,_acce ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_babg );return nil ,_babg ;};return _cefe ,nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_cfdg *PdfObjectString )Decoded ()string {if _cfdg ==nil {return "";};_cfce :=[]byte (_cfdg ._gafc );if len (_cfce )>=2&&_cfce [0]==0xFE&&_cfce [1]==0xFF{return _cg .UTF16ToString (_cfce [2:]);};return _cg .PDFDocEncodingToString (_cfce );};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// String returns a string representation of `name`.
func (_fecbd *PdfObjectName )String ()string {return string (*_fecbd )};func (_gdcb *PdfParser )rebuildXrefTable ()error {_ccdea :=XrefTable {};_ccdea .ObjectMap =map[int ]XrefObject {};_efb :=make ([]int ,0,len (_gdcb ._cgbd .ObjectMap ));for _efgfe :=range _gdcb ._cgbd .ObjectMap {_efb =append (_efb ,_efgfe );};_e .Ints (_efb );for _ ,_eacdf :=range _efb {_egfe :=_gdcb ._cgbd .ObjectMap [_eacdf ];_dcbe ,_ ,_ebfdd :=_gdcb .lookupByNumberWrapper (_eacdf ,false );if _ebfdd !=nil {_bc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ebfdd );_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_bbda ,_eecgf :=_gdcb .repairRebuildXrefsTopDown ();if _eecgf !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_eecgf );return _eecgf ;};_gdcb ._cgbd =*_bbda ;_bc .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_fbdg ,_gccea ,_ebfdd :=_fca (_dcbe );if _ebfdd !=nil {return _ebfdd ;};_egfe .ObjectNumber =int (_fbdg );_egfe .Generation =int (_gccea );_ccdea .ObjectMap [int (_fbdg )]=_egfe ;};_gdcb ._cgbd =_ccdea ;_bc .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bef (_gdcb ._cgbd );return nil ;};func (_dbge *PdfParser )skipComments ()error {if _ ,_dgcb :=_dbge .skipSpaces ();_dgcb !=nil {return _dgcb ;};_gbdfa :=true ;for {_dgca ,_eegb :=_dbge ._dcada .Peek (1);if _eegb !=nil {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_eegb .Error ());return _eegb ;};if _gbdfa &&_dgca [0]!='%'{return nil ;};_gbdfa =false ;if (_dgca [0]!='\r')&&(_dgca [0]!='\n'){_dbge ._dcada .ReadByte ();}else {break ;};};return _dbge .skipComments ();};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_aggg *JBIG2Encoder )DecodeImages (encoded []byte )([]_f .Image ,error ){const _cegdc ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_fcca ,_ddca :=_abb .Decode (encoded ,_abb .Parameters {},_aggg .Globals .ToDocumentGlobals ());if _ddca !=nil {return nil ,_de .Wrap (_ddca ,_cegdc ,"");};_ebee ,_ddca :=_fcca .PageNumber ();if _ddca !=nil {return nil ,_de .Wrap (_ddca ,_cegdc ,"");};_bddga :=[]_f .Image {};var _gbab _f .Image ;for _ebec :=1;_ebec <=_ebee ;_ebec ++{_gbab ,_ddca =_fcca .DecodePageImage (_ebec );if _ddca !=nil {return nil ,_de .Wrapf (_ddca ,_cegdc ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ebec );};_bddga =append (_bddga ,_gbab );};return _bddga ,nil ;};func _bafa (_abf _fbb .Filter ,_fcgb _fb .AuthEvent )*PdfObjectDictionary {if _fcgb ==""{_fcgb =_fb .EventDocOpen ;};_abfb :=MakeDict ();_abfb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_abfb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fcgb )));_abfb .Set ("\u0043\u0046\u004d",MakeName (_abf .Name ()));_abfb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_abf .KeyLength ())));return _abfb ;};func (_ebgb *PdfParser )parseName ()(PdfObjectName ,error ){var _dgdg _fce .Buffer ;_agdc :=false ;for {_gbcb ,_ggab :=_ebgb ._dcada .Peek (1);if _ggab ==_bg .EOF {break ;};if _ggab !=nil {return PdfObjectName (_dgdg .String ()),_ggab ;};if !_agdc {if _gbcb [0]=='/'{_agdc =true ;_ebgb ._dcada .ReadByte ();}else if _gbcb [0]=='%'{_ebgb .readComment ();_ebgb .skipSpaces ();}else {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_gbcb ,_gbcb );return PdfObjectName (_dgdg .String ()),_ccd .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_gbcb [0]);};}else {if IsWhiteSpace (_gbcb [0]){break ;}else if (_gbcb [0]=='/')||(_gbcb [0]=='[')||(_gbcb [0]=='(')||(_gbcb [0]==']')||(_gbcb [0]=='<')||(_gbcb [0]=='>'){break ;}else if _gbcb [0]=='#'{_bgba ,_gagb :=_ebgb ._dcada .Peek (3);if _gagb !=nil {return PdfObjectName (_dgdg .String ()),_gagb ;};_gffc ,_gagb :=_be .DecodeString (string (_bgba [1:3]));if _gagb !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_dgdg .WriteByte ('#');_ebgb ._dcada .Discard (1);continue ;};_ebgb ._dcada .Discard (3);_dgdg .Write (_gffc );}else {_gbgd ,_ :=_ebgb ._dcada .ReadByte ();_dgdg .WriteByte (_gbgd );};};};return PdfObjectName (_dgdg .String ()),nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_eeb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _eeb ._dccd };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cgec *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// SetFileOffset sets the file to an offset position and resets buffer.
func (_gcbcd *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_gcbcd ._geaf .Seek (offset ,_bg .SeekStart );_gcbcd ._dcada =_db .NewReader (_gcbcd ._geaf );};func (_daae *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_bg .SeekStart {offset +=_daae ._adbg ;};_cddc ,_bca :=_daae ._bged .Seek (offset ,whence );if _bca !=nil {return _cddc ,_bca ;};if whence ==_bg .SeekCurrent {_cddc -=_daae ._adbg ;};if _cddc < 0{return 0,_ab .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _cddc ,nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _fbb .Filter ,userPass ,ownerPass []byte ,perm _fb .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_ffb :=&PdfCrypt {_baf :make (map[PdfObject ]bool ),_ege :make (cryptFilters ),_bbe :_fb .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _eaa Version ;if cf !=nil {_begb :=cf .PDFVersion ();_eaa .Major ,_eaa .Minor =_begb [0],_begb [1];V ,R :=cf .HandlerVersion ();_ffb ._bbfc .V =V ;_ffb ._bbe .R =R ;_ffb ._bbfc .Length =cf .KeyLength ()*8;};const (_aeb =_ecab ;);_ffb ._ege [_aeb ]=cf ;if _ffb ._bbfc .V >=4{_ffb ._ecc =_aeb ;_ffb ._gac =_aeb ;};_bba :=_ffb .newEncryptDict ();_cfe :=_ec .Sum ([]byte (_d .Now ().Format (_d .RFC850 )));_dcc :=string (_cfe [:]);_fbdd :=make ([]byte ,100);_dg .Read (_fbdd );_cfe =_ec .Sum (_fbdd );_ddf :=string (_cfe [:]);_bc .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fbdd );_bc .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_dcc );_ffb ._gae =_dcc ;_ed :=_ffb .generateParams (userPass ,ownerPass );if _ed !=nil {return nil ,nil ,_ed ;};_cb (&_ffb ._bbe ,_bba );if _ffb ._bbfc .V >=4{if _eca :=_ffb .saveCryptFilters (_bba );_eca !=nil {return nil ,nil ,_eca ;};};return _ffb ,&EncryptInfo {Version :_eaa ,Encrypt :_bba ,ID0 :_dcc ,ID1 :_ddf },nil ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_bgde float64 ,_gcda bool ){_caaf ,_gcda :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _gcda {return float64 (*_caaf ),true ;};return 0,false ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gbaf *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// UpdateParams updates the parameter values of the encoder.
func (_ccdb *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _afbb ,_ffgg :=GetNumberAsInt64 (params .Get ("\u004b"));_ffgg ==nil {_ccdb .K =int (_afbb );};if _cggc ,_ccf :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_ccf ==nil {_ccdb .Columns =int (_cggc );}else if _cggc ,_ccf =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_ccf ==nil {_ccdb .Columns =int (_cggc );};if _ffgf ,_aafgg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_aafgg ==nil {_ccdb .BlackIs1 =_ffgf > 0;}else {if _bdfb ,_ffcg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ffcg {_ccdb .BlackIs1 =_bdfb ;}else {if _eeef ,_gcc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_gcc {_gdead ,_bedc :=_eeef .ToIntegerArray ();if _bedc ==nil {_ccdb .BlackIs1 =_gdead [0]==1&&_gdead [1]==0;};};};};if _ddbde ,_eefg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eefg ==nil {_ccdb .EncodedByteAlign =_ddbde > 0;}else {if _abbb ,_gagc :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gagc {_ccdb .EncodedByteAlign =_abbb ;};};if _afae ,_bdgef :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bdgef ==nil {_ccdb .EndOfLine =_afae > 0;}else {if _bfca ,_agbc :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_agbc {_ccdb .EndOfLine =_bfca ;};};if _bafdg ,_dafed :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_dafed ==nil {_ccdb .Rows =int (_bafdg );}else if _bafdg ,_dafed =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_dafed ==nil {_ccdb .Rows =int (_bafdg );};if _daebb ,_cffd :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cffd ==nil {_ccdb .EndOfBlock =_daebb > 0;}else {if _dbe ,_cdbe :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cdbe {_ccdb .EndOfBlock =_dbe ;};};if _gdde ,_gcac :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gcac !=nil {_ccdb .DamagedRowsBeforeError =int (_gdde );};};

// SetImage sets the image base for given flate encoder.
func (_agfgf *FlateEncoder )SetImage (img *_ba .ImageBase ){_agfgf ._ggf =img };func (_bfb *PdfCrypt )isDecrypted (_cecd PdfObject )bool {_ ,_adb :=_bfb ._afg [_cecd ];if _adb {_bc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _ged :=_cecd .(type ){case *PdfObjectStream :if _bfb ._bbe .R !=5{if _dcbc ,_cfc :=_ged .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cfc &&*_dcbc =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_adb =_bfb ._dec [int (_ged .ObjectNumber )];_adb {return true ;};switch _gacd :=_ged .PdfObject .(type ){case *PdfObjectDictionary :_edg :=true ;for _ ,_dbcd :=range _decb {if _gacd .Get (_dbcd )==nil {_edg =false ;break ;};};if _edg {return true ;};};};_bc .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cbf :=&PdfCrypt {_cgd :false ,_afg :make (map[PdfObject ]bool ),_baf :make (map[PdfObject ]bool ),_dec :make (map[int ]struct{}),_ccc :parser };_ebe ,_bbea :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_bbea {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _cbf ,_ab .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_ebe !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_bc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_ebe );return _cbf ,_ab .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cbf ._bbfc .Filter =string (*_ebe );if _cbe ,_eba :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_eba {_cbf ._bbfc .SubFilter =_cbe .Str ();_bc .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_cbe );};if L ,_dgef :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_dgef {if (*L %8)!=0{_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _cbf ,_ab .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cbf ._bbfc .Length =int (*L );}else {_cbf ._bbfc .Length =40;};_cbf ._bbfc .V =0;if _bgfb ,_dag :=ed .Get ("\u0056").(*PdfObjectInteger );_dag {V :=int (*_bgfb );_cbf ._bbfc .V =V ;if V >=1&&V <=2{_cbf ._ege =_dgba (_cbf ._bbfc .Length );}else if V >=4&&V <=5{if _bgfe :=_cbf .loadCryptFilters (ed );_bgfe !=nil {return _cbf ,_bgfe ;};}else {_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _cbf ,_ab .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _feaa :=_ffd (&_cbf ._bbe ,ed );_feaa !=nil {return _cbf ,_feaa ;};_bada :="";if _afc ,_aca :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_aca &&_afc .Len ()>=1{_cbg ,_babc :=GetString (_afc .Get (0));if !_babc {return _cbf ,_ab .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_bada =_cbg .Str ();}else {_bc .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_cbf ._gae =_bada ;return _cbf ,nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_edad []PdfObject ;};

// GetXrefOffset returns the offset of the xref table.
func (_ffff *PdfParser )GetXrefOffset ()int64 {return _ffff ._gdbd };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_ddggd *PdfObjectName ,_dgbc bool ){_ddggd ,_dgbc =TraceToDirectObject (obj ).(*PdfObjectName );return _ddggd ,_dgbc ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _efbe (o ,0,traversed );};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_adg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fae :=_fce .NewReader (encoded );var _dcac []byte ;for {_befa ,_cfee :=_fae .ReadByte ();if _cfee !=nil {return nil ,_cfee ;};if _befa =='>'{break ;};if IsWhiteSpace (_befa ){continue ;};if (_befa >='a'&&_befa <='f')||(_befa >='A'&&_befa <='F')||(_befa >='0'&&_befa <='9'){_dcac =append (_dcac ,_befa );}else {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_befa );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_befa );};};if len (_dcac )%2==1{_dcac =append (_dcac ,'0');};_bc .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dcac );_cbfb :=make ([]byte ,_be .DecodedLen (len (_dcac )));_ ,_eaac :=_be .Decode (_cbfb ,_dcac );if _eaac !=nil {return nil ,_eaac ;};return _cbfb ,nil ;};func _cceg (_bcg *PdfObjectStream ,_gfggb *PdfObjectDictionary )(*LZWEncoder ,error ){_ede :=NewLZWEncoder ();_ebacg :=_bcg .PdfObjectDictionary ;if _ebacg ==nil {return _ede ,nil ;};if _gfggb ==nil {_dff :=TraceToDirectObject (_ebacg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dff !=nil {if _baba ,_fffb :=_dff .(*PdfObjectDictionary );_fffb {_gfggb =_baba ;}else if _aed ,_ddd :=_dff .(*PdfObjectArray );_ddd {if _aed .Len ()==1{if _gdb ,_cbge :=GetDict (_aed .Get (0));_cbge {_gfggb =_gdb ;};};};if _gfggb ==nil {_bc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dff );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dcae :=_ebacg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dcae !=nil {_bag ,_efab :=_dcae .(*PdfObjectInteger );if !_efab {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dcae );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bag !=0&&*_bag !=1{return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_ede .EarlyChange =int (*_bag );}else {_ede .EarlyChange =1;};if _gfggb ==nil {return _ede ,nil ;};_dcae =_gfggb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dcae !=nil {_acdd ,_gag :=_dcae .(*PdfObjectInteger );if !_gag {_bc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dcae );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_ede .Predictor =int (*_acdd );};_dcae =_gfggb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dcae !=nil {_cgfa ,_bdg :=_dcae .(*PdfObjectInteger );if !_bdg {_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ccd .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_ede .BitsPerComponent =int (*_cgfa );};if _ede .Predictor > 1{_ede .Columns =1;_dcae =_gfggb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dcae !=nil {_ffg ,_fcfg :=_dcae .(*PdfObjectInteger );if !_fcfg {return nil ,_ccd .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ede .Columns =int (*_ffg );};_ede .Colors =1;_dcae =_gfggb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dcae !=nil {_aaag ,_cfa :=_dcae .(*PdfObjectInteger );if !_cfa {return nil ,_ccd .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_ede .Colors =int (*_aaag );};};_bc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gfggb .String ());return _ede ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_babcg :=&FlateEncoder {};_babcg .Predictor =1;_babcg .BitsPerComponent =8;_babcg .Colors =1;_babcg .Columns =1;return _babcg ;};

// WriteString outputs the object as it is to be written to file.
func (_efga *PdfObjectArray )WriteString ()string {var _fdgd _dc .Builder ;_fdgd .WriteString ("\u005b");for _efaf ,_faac :=range _efga .Elements (){_fdgd .WriteString (_faac .WriteString ());if _efaf < (_efga .Len ()-1){_fdgd .WriteString ("\u0020");};};_fdgd .WriteString ("\u005d");return _fdgd .String ();};func (_fgbf *FlateEncoder )postDecodePredict (_agbb []byte )([]byte ,error ){if _fgbf .Predictor > 1{if _fgbf .Predictor ==2{_bc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bc .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_fgbf .Colors );_ffbd :=_fgbf .Columns *_fgbf .Colors ;if _ffbd < 1{return []byte {},nil ;};_eae :=len (_agbb )/_ffbd ;if len (_agbb )%_ffbd !=0{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_agbb ),_ffbd );};if _ffbd %_fgbf .Colors !=0{return nil ,_ccd .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ffbd ,_fgbf .Colors );};if _ffbd > len (_agbb ){_bc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ffbd ,len (_agbb ));return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_agbb ),_agbb );_gde :=_fce .NewBuffer (nil );for _eaef :=0;_eaef < _eae ;_eaef ++{_cae :=_agbb [_ffbd *_eaef :_ffbd *(_eaef +1)];for _ggb :=_fgbf .Colors ;_ggb < _ffbd ;_ggb ++{_cae [_ggb ]+=_cae [_ggb -_fgbf .Colors ];};_gde .Write (_cae );};_bcdb :=_gde .Bytes ();_bc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bcdb ),_bcdb );return _bcdb ,nil ;}else if _fgbf .Predictor >=10&&_fgbf .Predictor <=15{_bc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gegf :=_fgbf .Columns *_fgbf .Colors +1;_aafg :=len (_agbb )/_gegf ;if len (_agbb )%_gegf !=0{return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_agbb ),_gegf );};if _gegf > len (_agbb ){_bc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gegf ,len (_agbb ));return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fddg :=_fce .NewBuffer (nil );_bc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fgbf .Columns );_bc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_agbb ),_gegf ,_aafg );_bgc :=make ([]byte ,_gegf );for _efad :=0;_efad < _gegf ;_efad ++{_bgc [_efad ]=0;};_gfae :=_fgbf .Colors ;for _fbde :=0;_fbde < _aafg ;_fbde ++{_bde :=_agbb [_gegf *_fbde :_gegf *(_fbde +1)];_edb :=_bde [0];switch _edb {case _acaf :case _fdbe :for _ffad :=1+_gfae ;_ffad < _gegf ;_ffad ++{_bde [_ffad ]+=_bde [_ffad -_gfae ];};case _ebgg :for _daac :=1;_daac < _gegf ;_daac ++{_bde [_daac ]+=_bgc [_daac ];};case _cgdd :for _dfdd :=1;_dfdd < _gfae +1;_dfdd ++{_bde [_dfdd ]+=_bgc [_dfdd ]/2;};for _ebgd :=_gfae +1;_ebgd < _gegf ;_ebgd ++{_bde [_ebgd ]+=byte ((int (_bde [_ebgd -_gfae ])+int (_bgc [_ebgd ]))/2);};case _fcde :for _agd :=1;_agd < _gegf ;_agd ++{var _dcg ,_age ,_degg byte ;_age =_bgc [_agd ];if _agd >=_gfae +1{_dcg =_bde [_agd -_gfae ];_degg =_bgc [_agd -_gfae ];};_bde [_agd ]+=_adgf (_dcg ,_age ,_degg );};default:_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_edb ,_fbde );return nil ,_ccd .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_edb );};copy (_bgc ,_bde );_fddg .Write (_bde [1:]);};_geac :=_fddg .Bytes ();return _geac ,nil ;}else {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fgbf .Predictor );return nil ,_ccd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fgbf .Predictor );};};return _agbb ,nil ;};func (_fbbag *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fbbag ._cgbd .ObjectMap =make (map[int ]XrefObject );_fbbag ._cfcg =make (objectStreams );_dcdg ,_edfb :=_fbbag ._geaf .Seek (0,_bg .SeekEnd );if _edfb !=nil {return nil ,_edfb ;};_bc .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_dcdg );_fbbag ._bdgd =_dcdg ;_edfb =_fbbag .seekToEOFMarker (_dcdg );if _edfb !=nil {_bc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_edfb );return nil ,_edfb ;};_ffdb ,_edfb :=_fbbag ._geaf .Seek (0,_bg .SeekCurrent );if _edfb !=nil {return nil ,_edfb ;};var _egdd int64 =64;_dcfac :=_ffdb -_egdd ;if _dcfac < 0{_dcfac =0;};_ ,_edfb =_fbbag ._geaf .Seek (_dcfac ,_bg .SeekStart );if _edfb !=nil {return nil ,_edfb ;};_fafeg :=make ([]byte ,_egdd );_ ,_edfb =_fbbag ._geaf .Read (_fafeg );if _edfb !=nil {_bc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_edfb );return nil ,_edfb ;};_efdg :=_bfge .FindStringSubmatch (string (_fafeg ));if len (_efdg )< 2{_bc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_ab .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_efdg )> 2{_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_fafeg );return nil ,_ab .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cdefd ,_ :=_b .ParseInt (_efdg [1],10,64);_bc .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cdefd );if _cdefd > _dcdg {_bc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_bc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cdefd ,_edfb =_fbbag .repairLocateXref ();if _edfb !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_edfb ;};};_fbbag ._geaf .Seek (_cdefd ,_bg .SeekStart );_fbbag ._dcada =_db .NewReader (_fbbag ._geaf );_bggdd ,_edfb :=_fbbag .parseXref ();if _edfb !=nil {return nil ,_edfb ;};_begca :=_bggdd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _begca !=nil {_ebcg ,_gdeg :=_begca .(*PdfObjectInteger );if !_gdeg {return nil ,_ab .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_edfb =_fbbag .parseXrefStream (_ebcg );if _edfb !=nil {return nil ,_edfb ;};};var _gabb []int64 ;_ffacc :=func (_fcce int64 ,_gccg []int64 )bool {for _ ,_bfbd :=range _gccg {if _bfbd ==_fcce {return true ;};};return false ;};_begca =_bggdd .Get ("\u0050\u0072\u0065\u0076");for _begca !=nil {_fafd ,_efcg :=_begca .(*PdfObjectInteger );if !_efcg {_bc .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_begca );return _bggdd ,nil ;};_dege :=*_fafd ;_bc .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_dege );_fbbag ._geaf .Seek (int64 (_dege ),_bg .SeekStart );_fbbag ._dcada =_db .NewReader (_fbbag ._geaf );_abag ,_dfaf :=_fbbag .parseXref ();if _dfaf !=nil {_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_bc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_begca =_abag .Get ("\u0050\u0072\u0065\u0076");if _begca !=nil {_dabc :=*(_begca .(*PdfObjectInteger ));if _ffacc (int64 (_dabc ),_gabb ){_bc .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_gabb =append (_gabb ,int64 (_dabc ));};};return _bggdd ,nil ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_deff :=MakeArray ();for _ ,_dccg :=range vals {_deff .Append (MakeInteger (int64 (_dccg )));};return _deff ;};

// WriteString outputs the object as it is to be written to file.
func (_cgff *PdfObjectDictionary )WriteString ()string {var _fceb _dc .Builder ;_fceb .WriteString ("\u003c\u003c");for _ ,_cagc :=range _cgff ._bcffe {_bdfc :=_cgff ._edef [_cagc ];_fceb .WriteString (_cagc .WriteString ());_fceb .WriteString ("\u0020");_fceb .WriteString (_bdfc .WriteString ());};_fceb .WriteString ("\u003e\u003e");return _fceb .String ();};var (ErrUnsupportedEncodingParameters =_ab .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_ab .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_ab .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_ab .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_ab .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_ab .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_agg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_ab .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_bbeac *PdfIndirectObject ,_ggdag bool ){obj =ResolveReference (obj );_bbeac ,_ggdag =obj .(*PdfIndirectObject );return _bbeac ,_ggdag ;};type xrefType int ;const _ggfa =32<<(^uint (0)>>63);

// GetFilterName returns the name of the encoding filter.
func (_aeff *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_aede *PdfParser )parseObject ()(PdfObject ,error ){_bc .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_aede .skipSpaces ();for {_deba ,_ebbc :=_aede ._dcada .Peek (2);if _ebbc !=nil {if _ebbc !=_bg .EOF ||len (_deba )==0{return nil ,_ebbc ;};if len (_deba )==1{_deba =append (_deba ,' ');};};_bc .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_deba ));if _deba [0]=='/'{_daece ,_feeg :=_aede .parseName ();_bc .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_daece );return &_daece ,_feeg ;}else if _deba [0]=='('{_bc .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_dfadd ,_dfdg :=_aede .parseString ();return _dfadd ,_dfdg ;}else if _deba [0]=='['{_bc .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_ebbf ,_aefc :=_aede .parseArray ();return _ebbf ,_aefc ;}else if (_deba [0]=='<')&&(_deba [1]=='<'){_bc .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_fabb ,_ecca :=_aede .ParseDict ();return _fabb ,_ecca ;}else if _deba [0]=='<'{_bc .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cfbd ,_fabg :=_aede .parseHexString ();return _cfbd ,_fabg ;}else if _deba [0]=='%'{_aede .readComment ();_aede .skipSpaces ();}else {_bc .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_deba ,_ =_aede ._dcada .Peek (15);_eagb :=string (_deba );_bc .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_eagb );if (len (_eagb )> 3)&&(_eagb [:4]=="\u006e\u0075\u006c\u006c"){_cbcec ,_dbdd :=_aede .parseNull ();return &_cbcec ,_dbdd ;}else if (len (_eagb )> 4)&&(_eagb [:5]=="\u0066\u0061\u006cs\u0065"){_ddbe ,_gdagd :=_aede .parseBool ();return &_ddbe ,_gdagd ;}else if (len (_eagb )> 3)&&(_eagb [:4]=="\u0074\u0072\u0075\u0065"){_gccd ,_effa :=_aede .parseBool ();return &_gccd ,_effa ;};_cdbg :=_eaaea .FindStringSubmatch (_eagb );if len (_cdbg )> 1{_deba ,_ =_aede ._dcada .ReadBytes ('R');_bc .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_deba [:]));_adfdb ,_bcgc :=_dgee (string (_deba ));_adfdb ._eggf =_aede ;return &_adfdb ,_bcgc ;};_fdff :=_bec .FindStringSubmatch (_eagb );if len (_fdff )> 1{_bc .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cab ,_aeg :=_aede .parseNumber ();return _cab ,_aeg ;};_fdff =_dcbf .FindStringSubmatch (_eagb );if len (_fdff )> 1{_bc .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_bc .Log .Trace ("\u0025\u0020\u0073",_fdff );_eadgb ,_eeag :=_aede .parseNumber ();return _eadgb ,_eeag ;};_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_eagb );return nil ,_ab .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};var _eec =_g .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func _adgf (_cgfc ,_egbbd ,_cgbf uint8 )uint8 {_dgec :=int (_cgbf );_daga :=int (_egbbd )-_dgec ;_eafdf :=int (_cgfc )-_dgec ;_dgec =_gdab (_daga +_eafdf );_daga =_gdab (_daga );_eafdf =_gdab (_eafdf );if _daga <=_eafdf &&_daga <=_dgec {return _cgfc ;}else if _eafdf <=_dgec {return _egbbd ;};return _cgbf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afad *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_eded :=MakeDict ();_eded .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_afad .GetFilterName ()));return _eded ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fddd *MultiEncoder )GetFilterArray ()*PdfObjectArray {_faad :=make ([]PdfObject ,len (_fddd ._beb ));for _abgg ,_gcaf :=range _fddd ._beb {_faad [_abgg ]=MakeName (_gcaf .GetFilterName ());};return MakeArray (_faad ...);};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cdcc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bc .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_bc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cdcc .Predictor );if _cdcc .BitsPerComponent !=8{return nil ,_ccd .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cdcc .BitsPerComponent );};_gacc ,_bfag :=_cdcc .DecodeBytes (streamObj .Stream );if _bfag !=nil {return nil ,_bfag ;};_gacc ,_bfag =_cdcc .postDecodePredict (_gacc );if _bfag !=nil {return nil ,_bfag ;};return _cdcc .cleanImageData (_gacc );};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_afgaa :=PdfObjectInteger (val );return &_afgaa };func (_fgfe *PdfObjectInteger )String ()string {return _ccd .Sprintf ("\u0025\u0064",*_fgfe )};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bab *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ccb ,_bac :=obj .(*PdfObjectReference );if !_bac {return obj ,nil ;};_fda :=_bab .GetFileOffset ();defer func (){_bab .SetFileOffset (_fda )}();_dgb ,_ef :=_bab .LookupByReference (*_ccb );if _ef !=nil {return nil ,_ef ;};_deg ,_bbb :=_dgb .(*PdfIndirectObject );if !_bbb {return _dgb ,nil ;};_dgb =_deg .PdfObject ;_ ,_bac =_dgb .(*PdfObjectReference );if _bac {return _deg ,_ab .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _dgb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bcdc *PdfObjectBool )WriteString ()string {if *_bcdc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _f .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _dbga ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_de .Error (_dbga ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_gdg uint8 ;_bgfc _ba .Image ;_beee error ;);if bwThreshold ==JB2ImageAutoThreshold {_bgfc ,_beee =_ba .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_de .Error (_dbga ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_gdg =uint8 (255*bwThreshold );_bgfc ,_beee =_ba .MonochromeThresholdConverter (_gdg ).Convert (i );};if _beee !=nil {return nil ,_beee ;};return _abbd (_bgfc ),nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_ggf *_ba .ImageBase ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_ebbe *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gbb :=_fce .NewReader (encoded );_eace ,_acaa :=_c .Decode (_gbb );if _acaa !=nil {_bc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_acaa );return nil ,_acaa ;};_fbg :=_eace .Bounds ();var _fbab =make ([]byte ,_fbg .Dx ()*_fbg .Dy ()*_ebbe .ColorComponents *_ebbe .BitsPerComponent /8);_bgfd :=0;for _dcd :=_fbg .Min .Y ;_dcd < _fbg .Max .Y ;_dcd ++{for _gdbe :=_fbg .Min .X ;_gdbe < _fbg .Max .X ;_gdbe ++{_fdec :=_eace .At (_gdbe ,_dcd );if _ebbe .ColorComponents ==1{if _ebbe .BitsPerComponent ==16{_afa ,_bdgeb :=_fdec .(_ga .Gray16 );if !_bdgeb {return nil ,_ab .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbab [_bgfd ]=byte ((_afa .Y >>8)&0xff);_bgfd ++;_fbab [_bgfd ]=byte (_afa .Y &0xff);_bgfd ++;}else {_bdd ,_geb :=_fdec .(_ga .Gray );if !_geb {return nil ,_ab .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbab [_bgfd ]=_bdd .Y &0xff;_bgfd ++;};}else if _ebbe .ColorComponents ==3{if _ebbe .BitsPerComponent ==16{_dfed ,_gda :=_fdec .(_ga .RGBA64 );if !_gda {return nil ,_ab .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbab [_bgfd ]=byte ((_dfed .R >>8)&0xff);_bgfd ++;_fbab [_bgfd ]=byte (_dfed .R &0xff);_bgfd ++;_fbab [_bgfd ]=byte ((_dfed .G >>8)&0xff);_bgfd ++;_fbab [_bgfd ]=byte (_dfed .G &0xff);_bgfd ++;_fbab [_bgfd ]=byte ((_dfed .B >>8)&0xff);_bgfd ++;_fbab [_bgfd ]=byte (_dfed .B &0xff);_bgfd ++;}else {_cag ,_bbge :=_fdec .(_ga .RGBA );if _bbge {_fbab [_bgfd ]=_cag .R &0xff;_bgfd ++;_fbab [_bgfd ]=_cag .G &0xff;_bgfd ++;_fbab [_bgfd ]=_cag .B &0xff;_bgfd ++;}else {_ggc ,_aceg :=_fdec .(_ga .YCbCr );if !_aceg {return nil ,_ab .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bbfg ,_abff ,_ccde ,_ :=_ggc .RGBA ();_fbab [_bgfd ]=byte (_bbfg >>8);_bgfd ++;_fbab [_bgfd ]=byte (_abff >>8);_bgfd ++;_fbab [_bgfd ]=byte (_ccde >>8);_bgfd ++;};};}else if _ebbe .ColorComponents ==4{_edga ,_adea :=_fdec .(_ga .CMYK );if !_adea {return nil ,_ab .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbab [_bgfd ]=255-_edga .C &0xff;_bgfd ++;_fbab [_bgfd ]=255-_edga .M &0xff;_bgfd ++;_fbab [_bgfd ]=255-_edga .Y &0xff;_bgfd ++;_fbab [_bgfd ]=255-_edga .K &0xff;_bgfd ++;};};};return _fbab ,nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dagf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dagf .PdfObjectDictionary =encoder .MakeStreamDict ();_aefb ,_dfdbb :=encoder .EncodeBytes (contents );if _dfdbb !=nil {return nil ,_dfdbb ;};_dagf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aefb ))));_dagf .Stream =_aefb ;return _dagf ,nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_gcga *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_abfc :=_gcga ._edef [key ];if !_abfc {_gcga ._bcffe =append (_gcga ._bcffe ,key );};_gcga ._edef [key ]=val ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gadb *PdfObjectFloat ,_ccbfg bool ){_gadb ,_ccbfg =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gadb ,_ccbfg ;};

// String returns a string describing `null`.
func (_egbf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func _cfbc (_acab PdfObject ,_bcfb int )PdfObject {if _bcfb > _efadg {_bc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_efadg );return MakeNull ();};switch _ebae :=_acab .(type ){case *PdfIndirectObject :_acab =_cfbc ((*_ebae ).PdfObject ,_bcfb +1);case *PdfObjectArray :for _babfg ,_bdgg :=range (*_ebae )._fgfd {(*_ebae )._fgfd [_babfg ]=_cfbc (_bdgg ,_bcfb +1);};case *PdfObjectDictionary :for _cdcf ,_ffdc :=range (*_ebae )._edef {(*_ebae )._edef [_cdcf ]=_cfbc (_ffdc ,_bcfb +1);};_e .Slice ((*_ebae )._bcffe ,func (_bgca ,_egfb int )bool {return (*_ebae )._bcffe [_bgca ]< (*_ebae )._bcffe [_egfb ]});};return _acab ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gba *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gba .isEncrypted (obj ){return nil ;};switch _fbc :=obj .(type ){case *PdfIndirectObject :_gba ._baf [_fbc ]=true ;_bc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fbc .ObjectNumber ,_fbc .GenerationNumber );_facf :=_fbc .ObjectNumber ;_edfg :=_fbc .GenerationNumber ;_bbg :=_gba .Encrypt (_fbc .PdfObject ,_facf ,_edfg );if _bbg !=nil {return _bbg ;};return nil ;case *PdfObjectStream :_gba ._baf [_fbc ]=true ;_gcfa :=_fbc .PdfObjectDictionary ;if _dabb ,_eaab :=_gcfa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eaab &&*_dabb =="\u0058\u0052\u0065\u0066"{return nil ;};_acf :=_fbc .ObjectNumber ;_eea :=_fbc .GenerationNumber ;_bc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_acf ,_eea );_aff :=_ecab ;if _gba ._bbfc .V >=4{_aff =_gba ._ecc ;_bc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gba ._ecc );if _cgf ,_ebd :=_gcfa .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_ebd {if _edde ,_ebac :=GetName (_cgf .Get (0));_ebac {if *_edde =="\u0043\u0072\u0079p\u0074"{_aff ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gfg ,_geae :=_gcfa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_geae {if _feb ,_efgd :=_gfg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_efgd {if _ ,_afb :=_gba ._ege [string (*_feb )];_afb {_bc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_feb );_aff =string (*_feb );};};};};};};_bc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aff );if _aff =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ca :=_gba .Encrypt (_fbc .PdfObjectDictionary ,_acf ,_eea );if _ca !=nil {return _ca ;};_cgagg ,_ca :=_gba .makeKey (_aff ,uint32 (_acf ),uint32 (_eea ),_gba ._cce );if _ca !=nil {return _ca ;};_fbc .Stream ,_ca =_gba .encryptBytes (_fbc .Stream ,_aff ,_cgagg );if _ca !=nil {return _ca ;};_gcfa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fbc .Stream ))));return nil ;case *PdfObjectString :_bc .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gbag :=_ecab ;if _gba ._bbfc .V >=4{_bc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gba ._gac );if _gba ._gac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gbag =_gba ._gac ;};_gdc ,_bcd :=_gba .makeKey (_gbag ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gba ._cce );if _bcd !=nil {return _bcd ;};_cbee :=_fbc .Str ();_acd :=make ([]byte ,len (_cbee ));for _fcdf :=0;_fcdf < len (_cbee );_fcdf ++{_acd [_fcdf ]=_cbee [_fcdf ];};_bc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_acd ,_acd );_acd ,_bcd =_gba .encryptBytes (_acd ,_gbag ,_gdc );if _bcd !=nil {return _bcd ;};_fbc ._gafc =string (_acd );return nil ;case *PdfObjectArray :for _ ,_efgc :=range _fbc .Elements (){_bfg :=_gba .Encrypt (_efgc ,parentObjNum ,parentGenNum );if _bfg !=nil {return _bfg ;};};return nil ;case *PdfObjectDictionary :_edfd :=false ;if _ccge :=_fbc .Get ("\u0054\u0079\u0070\u0065");_ccge !=nil {_efc ,_dgag :=_ccge .(*PdfObjectName );if _dgag &&*_efc =="\u0053\u0069\u0067"{_edfd =true ;};};for _ ,_ceef :=range _fbc .Keys (){_bbcd :=_fbc .Get (_ceef );if _edfd &&string (_ceef )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_ceef )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ceef )!="\u0050\u0072\u0065\u0076"&&string (_ceef )!="\u004c\u0061\u0073\u0074"{_bbde :=_gba .Encrypt (_bbcd ,parentObjNum ,parentGenNum );if _bbde !=nil {return _bbde ;};};};return nil ;};return nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_adef *PdfObjectStream ,_edbb bool ){obj =ResolveReference (obj );_adef ,_edbb =obj .(*PdfObjectStream );return _adef ,_edbb ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_eee *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bee :=_fce .NewReader (encoded );var _cgac []byte ;for {_ada ,_aead :=_bee .ReadByte ();if _aead !=nil {return nil ,_aead ;};if _ada > 128{_bff ,_fbcd :=_bee .ReadByte ();if _fbcd !=nil {return nil ,_fbcd ;};for _fdge :=0;_fdge < 257-int (_ada );_fdge ++{_cgac =append (_cgac ,_bff );};}else if _ada < 128{for _ggade :=0;_ggade < int (_ada )+1;_ggade ++{_dfcg ,_egde :=_bee .ReadByte ();if _egde !=nil {return nil ,_egde ;};_cgac =append (_cgac ,_dfcg );};}else {break ;};};return _cgac ,nil ;};const JB2ImageAutoThreshold =-1.0;func (_bbec *PdfParser )parseArray ()(*PdfObjectArray ,error ){_eeda :=MakeArray ();_bbec ._dcada .ReadByte ();for {_bbec .skipSpaces ();_bagb ,_efdc :=_bbec ._dcada .Peek (1);if _efdc !=nil {return _eeda ,_efdc ;};if _bagb [0]==']'{_bbec ._dcada .ReadByte ();break ;};_gfc ,_efdc :=_bbec .parseObject ();if _efdc !=nil {return _eeda ,_efdc ;};_eeda .Append (_gfc );};return _eeda ,nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dcga *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_bdf ,_beac :=_ba .NewImage (_dcga .Width ,_dcga .Height ,_dcga .BitsPerComponent ,_dcga .ColorComponents ,data ,nil ,nil );if _beac !=nil {return nil ,_beac ;};_ded :=_c .Options {};_ded .Quality =_dcga .Quality ;var _gce _fce .Buffer ;if _beac =_c .Encode (&_gce ,_bdf ,&_ded );_beac !=nil {return nil ,_beac ;};return _gce .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_bagg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func _dgba (_ggad int )cryptFilters {return cryptFilters {_ecab :_fbb .NewFilterV2 (_ggad )}};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func _fbdad (_beff PdfObject )(*float64 ,error ){switch _aabed :=_beff .(type ){case *PdfObjectFloat :_afca :=float64 (*_aabed );return &_afca ,nil ;case *PdfObjectInteger :_fead :=float64 (*_aabed );return &_fead ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// Len returns the number of elements in the streams.
func (_gcae *PdfObjectStreams )Len ()int {if _gcae ==nil {return 0;};return len (_gcae ._edad );};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cceff *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_bffg :=n ;_gcff :=0;_cfafe :=0;for _bffg > 0{_eedb ,_adda :=_cceff ._dcada .Read (p [_gcff :]);if _adda !=nil {_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_eedb ,_cfafe ,_adda .Error ());return _gcff ,_ab .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_cfafe ++;_gcff +=_eedb ;_bffg -=_eedb ;};return _gcff ,nil ;};func (_cade *PdfParser )inspect ()(map[string ]int ,error ){_bc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_bc .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_egfd :=map[string ]int {};_gceee :=0;_fefd :=0;var _acda []int ;for _deeac :=range _cade ._cgbd .ObjectMap {_acda =append (_acda ,_deeac );};_e .Ints (_acda );_gbef :=0;for _ ,_abgfg :=range _acda {_gcbb :=_cade ._cgbd .ObjectMap [_abgfg ];if _gcbb .ObjectNumber ==0{continue ;};_gceee ++;_bc .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_bc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_gcbb .ObjectNumber );_fadf ,_gcaae :=_cade .LookupByNumber (_gcbb .ObjectNumber );if _gcaae !=nil {_bc .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_gcbb .ObjectNumber ,_gcaae );_fefd ++;continue ;};_bc .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_fadf );_acae ,_gdbdc :=_fadf .(*PdfIndirectObject );if _gdbdc {_bc .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_gcbb .ObjectNumber ,_acae );_cddff ,_fdee :=_acae .PdfObject .(*PdfObjectDictionary );if _fdee {if _agbbg ,_gaabc :=_cddff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gaabc {_bbeeb :=string (*_agbbg );_bc .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bbeeb );_ ,_aedda :=_egfd [_bbeeb ];if _aedda {_egfd [_bbeeb ]++;}else {_egfd [_bbeeb ]=1;};}else if _dfeb ,_cfebg :=_cddff .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cfebg {_agege :=string (*_dfeb );_bc .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_agege );_ ,_fbad :=_egfd [_agege ];if _fbad {_egfd [_agege ]++;}else {_egfd [_agege ]=1;};};if _decce ,_aadf :=_cddff .Get ("\u0053").(*PdfObjectName );_aadf &&*_decce =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_dede :=_egfd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _dede {_egfd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_egfd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _ccad ,_fcee :=_fadf .(*PdfObjectStream );_fcee {if _fedc ,_gfcb :=_ccad .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gfcb {_bc .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_fedc );_gabd :=string (*_fedc );_egfd [_gabd ]++;};}else {_bbbbc ,_dbedc :=_fadf .(*PdfObjectDictionary );if _dbedc {_gafg ,_babbg :=_bbbbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _babbg {_fgdc :=string (*_gafg );_bc .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fgdc );_egfd [_fgdc ]++;};};_bc .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_gcbb .ObjectNumber ,_fadf );};_gbef ++;};_bc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_bc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_bc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gceee );_bc .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_fefd );for _dcfd ,_dgae :=range _egfd {_bc .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dcfd ,_dgae );};_bc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_cade ._cgbd .ObjectMap )< 1{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ccd .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_fbac ,_gcef :=_egfd ["\u0046\u006f\u006e\u0074"];if !_gcef ||_fbac < 2{_bc .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_bc .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _egfd ,nil ;};func _gacff (_eece ,_fcdef PdfObject ,_bggddf int )bool {if _bggddf > _efadg {_bc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_efadg );return false ;};if _eece ==nil &&_fcdef ==nil {return true ;}else if _eece ==nil ||_fcdef ==nil {return false ;};if _ag .TypeOf (_eece )!=_ag .TypeOf (_fcdef ){return false ;};switch _eaaec :=_eece .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_eaaec ==*(_fcdef .(*PdfObjectName ));case *PdfObjectString :return *_eaaec ==*(_fcdef .(*PdfObjectString ));case *PdfObjectInteger :return *_eaaec ==*(_fcdef .(*PdfObjectInteger ));case *PdfObjectBool :return *_eaaec ==*(_fcdef .(*PdfObjectBool ));case *PdfObjectFloat :return *_eaaec ==*(_fcdef .(*PdfObjectFloat ));case *PdfIndirectObject :return _gacff (TraceToDirectObject (_eece ),TraceToDirectObject (_fcdef ),_bggddf +1);case *PdfObjectArray :_abeb :=_fcdef .(*PdfObjectArray );if len ((*_eaaec )._fgfd )!=len ((*_abeb )._fgfd ){return false ;};for _cada ,_cacd :=range (*_eaaec )._fgfd {if !_gacff (_cacd ,(*_abeb )._fgfd [_cada ],_bggddf +1){return false ;};};return true ;case *PdfObjectDictionary :_fcggc :=_fcdef .(*PdfObjectDictionary );_daef ,_gffae :=(*_eaaec )._edef ,(*_fcggc )._edef ;if len (_daef )!=len (_gffae ){return false ;};for _gedgf ,_cbabb :=range _daef {_gebc ,_ecbdd :=_gffae [_gedgf ];if !_ecbdd ||!_gacff (_cbabb ,_gebc ,_bggddf +1){return false ;};};return true ;case *PdfObjectStream :_dacc :=_fcdef .(*PdfObjectStream );return _gacff ((*_eaaec ).PdfObjectDictionary ,(*_dacc ).PdfObjectDictionary ,_bggddf +1);default:_bc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_eece );};return false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ade *FlateEncoder )MakeDecodeParams ()PdfObject {if _ade .Predictor > 1{_abg :=MakeDict ();_abg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ade .Predictor )));if _ade .BitsPerComponent !=8{_abg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ade .BitsPerComponent )));};if _ade .Columns !=1{_abg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ade .Columns )));};if _ade .Colors !=1{_abg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ade .Colors )));};return _abg ;};return nil ;};func (_agfd *PdfParser )parseXrefStream (_fggf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _fggf !=nil {_bc .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_fggf );_agfd ._geaf .Seek (int64 (*_fggf ),_bg .SeekStart );_agfd ._dcada =_db .NewReader (_agfd ._geaf );};_bfdc :=_agfd .GetFileOffset ();_dfbc ,_aeade :=_agfd .ParseIndirectObject ();if _aeade !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_ab .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_bc .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dfbc );_cgeca ,_ebgbg :=_dfbc .(*PdfObjectStream );if !_ebgbg {_bc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_ab .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bgg :=_cgeca .PdfObjectDictionary ;_bbbg ,_ebgbg :=_cgeca .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ebgbg {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_ab .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bbbg )> 8388607{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bbbg );return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggda :=_cgeca .PdfObjectDictionary .Get ("\u0057");_degbc ,_ebgbg :=_ggda .(*PdfObjectArray );if !_ebgbg {return nil ,_ab .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_dbee :=_degbc .Len ();if _dbee !=3{_bc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_dbee );return nil ,_ab .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _dgcg []int64 ;for _adac :=0;_adac < 3;_adac ++{_febd ,_cead :=GetInt (_degbc .Get (_adac ));if !_cead {return nil ,_ab .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_dgcg =append (_dgcg ,int64 (*_febd ));};_fefea ,_aeade :=DecodeStream (_cgeca );if _aeade !=nil {_bc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_aeade );return nil ,_aeade ;};_ffef :=int (_dgcg [0]);_eddg :=int (_dgcg [0]+_dgcg [1]);_gbcbe :=int (_dgcg [0]+_dgcg [1]+_dgcg [2]);_cdef :=int (_dgcg [0]+_dgcg [1]+_dgcg [2]);if _ffef < 0||_eddg < 0||_gbcbe < 0{_bc .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_ffef ,_eddg ,_gbcbe );return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cdef ==0{_bc .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _bgg ,nil ;};_bdea :=len (_fefea )/_cdef ;_eefgb :=0;_gcab :=_cgeca .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _eeaef []int ;if _gcab !=nil {_bc .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_gcab );_ccda ,_efedc :=_gcab .(*PdfObjectArray );if !_efedc {_bc .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_ab .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _ccda .Len ()%2!=0{_bc .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eefgb =0;_abaf ,_edcf :=_ccda .ToIntegerArray ();if _edcf !=nil {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_edcf );return nil ,_edcf ;};for _gcaa :=0;_gcaa < len (_abaf );_gcaa +=2{_dedf :=_abaf [_gcaa ];_cacg :=_abaf [_gcaa +1];for _cdefa :=0;_cdefa < _cacg ;_cdefa ++{_eeaef =append (_eeaef ,_dedf +_cdefa );};_eefgb +=_cacg ;};}else {for _begd :=0;_begd < int (*_bbbg );_begd ++{_eeaef =append (_eeaef ,_begd );};_eefgb =int (*_bbbg );};if _bdea ==_eefgb +1{_bc .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_daad :=_eefgb -1;for _ ,_fdef :=range _eeaef {if _fdef > _daad {_daad =_fdef ;};};_eeaef =append (_eeaef ,_daad +1);_eefgb ++;};if _bdea !=len (_eeaef ){_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_bdea ,len (_eeaef ));return nil ,_ab .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_bc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_eefgb );_bc .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_eeaef );_ggfac :=func (_dbcc []byte )int64 {var _ccfe int64 ;for _ffea :=0;_ffea < len (_dbcc );_ffea ++{_ccfe +=int64 (_dbcc [_ffea ])*(1<<uint (8*(len (_dbcc )-_ffea -1)));};return _ccfe ;};_bc .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_fefea ));_fdbb :=0;for _gacbd :=0;_gacbd < len (_fefea );_gacbd +=_cdef {_becb :=_dbgf (len (_fefea ),_gacbd ,_gacbd +_ffef );if _becb !=nil {_bc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_becb );return nil ,_becb ;};_ceegd :=_fefea [_gacbd :_gacbd +_ffef ];_becb =_dbgf (len (_fefea ),_gacbd +_ffef ,_gacbd +_eddg );if _becb !=nil {_bc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_becb );return nil ,_becb ;};_cccfd :=_fefea [_gacbd +_ffef :_gacbd +_eddg ];_becb =_dbgf (len (_fefea ),_gacbd +_eddg ,_gacbd +_gbcbe );if _becb !=nil {_bc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_becb );return nil ,_becb ;};_cgda :=_fefea [_gacbd +_eddg :_gacbd +_gbcbe ];_bcgba :=_ggfac (_ceegd );_fecg :=_ggfac (_cccfd );_gegd :=_ggfac (_cgda );if _dgcg [0]==0{_bcgba =1;};if _fdbb >=len (_eeaef ){_bc .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_cadd :=_eeaef [_fdbb ];_fdbb ++;_bc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_cadd ,_ceegd );_bc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_cadd ,_cccfd );_bc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_cadd ,_cgda );_bc .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_cadd ,_bcgba ,_fecg ,_gegd );if _bcgba ==0{_bc .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _bcgba ==1{_bc .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_cccfd );if _fecg ==_bfdc {_bc .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_cadd ,_cgeca .ObjectNumber );_cadd =int (_cgeca .ObjectNumber );};if _cbgec ,_dcfb :=_agfd ._cgbd .ObjectMap [_cadd ];!_dcfb ||int (_gegd )> _cbgec .Generation {_bcff :=XrefObject {ObjectNumber :_cadd ,XType :XrefTypeTableEntry ,Offset :_fecg ,Generation :int (_gegd )};_agfd ._cgbd .ObjectMap [_cadd ]=_bcff ;};}else if _bcgba ==2{_bc .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_abgf :=_agfd ._cgbd .ObjectMap [_cadd ];!_abgf {_gcea :=XrefObject {ObjectNumber :_cadd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fecg ),OsObjIndex :int (_gegd )};_agfd ._cgbd .ObjectMap [_cadd ]=_gcea ;_bc .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_gcea );};}else {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _agfd ._gdag ==nil {_affc :=XrefTypeObjectStream ;_agfd ._gdag =&_affc ;};return _bgg ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_cef *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cf ,_ ,_gd :=_cef .lookupByNumberWrapper (objNumber ,true );return _cf ,_gd ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func (_fcc *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_aea :=MakeDict ();_aea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_aea .Set ("\u0056",MakeInteger (int64 (_fcc ._bbfc .V )));_aea .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_fcc ._bbfc .Length )));return _aea ;};var _afgcb =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcdd *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_cebg int ,_bdbbe bool ){_dcca ,_bdbbe :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bdbbe &&_dcca !=nil {return int (*_dcca ),true ;};return 0,false ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_edcd *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _eb .DecodeBytes (encoded ,_abb .Parameters {},_edcd .Globals );};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_begf :=_fce .NewReader ([]byte (txt ));_gdagb :=&PdfParser {ObjCache :objectCache {},_geaf :_begf ,_dcada :_db .NewReader (_begf ),_bdgd :int64 (len (txt )),_egcd :map[int64 ]bool {}};_gdagb ._cgbd .ObjectMap =make (map[int ]XrefObject );return _gdagb ;};func (_acge *PdfParser )parseBool ()(PdfObjectBool ,error ){_dbde ,_ebc :=_acge ._dcada .Peek (4);if _ebc !=nil {return PdfObjectBool (false ),_ebc ;};if (len (_dbde )>=4)&&(string (_dbde [:4])=="\u0074\u0072\u0075\u0065"){_acge ._dcada .Discard (4);return PdfObjectBool (true ),nil ;};_dbde ,_ebc =_acge ._dcada .Peek (5);if _ebc !=nil {return PdfObjectBool (false ),_ebc ;};if (len (_dbde )>=5)&&(string (_dbde [:5])=="\u0066\u0061\u006cs\u0065"){_acge ._dcada .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_ab .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_edef map[PdfObjectName ]PdfObject ;_bcffe []PdfObjectName ;_adfc *PdfParser ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dgde :=obj .(type ){case *PdfObjectFloat :return float64 (*_dgde ),nil ;case *PdfObjectInteger :return float64 (*_dgde ),nil ;};return 0,ErrNotANumber ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bbfc encryptDict ;_bbe _fb .StdEncryptDict ;_gae string ;_cce []byte ;_afg map[PdfObject ]bool ;_baf map[PdfObject ]bool ;_cgd bool ;_ege cryptFilters ;_ecc string ;_gac string ;_ccc *PdfParser ;_dec map[int ]struct{};};var _dcbf =_g .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_eccb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eccb .DecodeBytes (streamObj .Stream );};

// Remove removes an element specified by key.
func (_ggebd *PdfObjectDictionary )Remove (key PdfObjectName ){_aedd :=-1;for _aedc ,_edaa :=range _ggebd ._bcffe {if _edaa ==key {_aedd =_aedc ;break ;};};if _aedd >=0{_ggebd ._bcffe =append (_ggebd ._bcffe [:_aedd ],_ggebd ._bcffe [_aedd +1:]...);delete (_ggebd ._edef ,key );};};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ccdc *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ccdc .DecodeBytes (streamObj .Stream );};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_ebdac *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_bead ,_efag :=_ebdac ._edef [key ].(*PdfObjectString );if !_efag {return "",false ;};return _bead .Str (),true ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ddaf :=&ASCIIHexEncoder {};return _ddaf };func _dca (_daa *_fbb .FilterDict ,_eaf *PdfObjectDictionary )error {if _fgd ,_efg :=_eaf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_efg {if _gfa :=string (*_fgd );_gfa !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_bc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_gfa );};};_bbad ,_eabg :=_eaf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_eabg {return _ccd .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_daa .CFM =string (*_bbad );if _fbdf ,_fac :=_eaf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_fac {_daa .AuthEvent =_fb .AuthEvent (*_fbdf );}else {_daa .AuthEvent =_fb .EventDocOpen ;};if _agge ,_fdag :=_eaf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fdag {_daa .Length =int (*_agge );};return nil ;};type objectStream struct{N int ;_bed []byte ;_ee map[int ]int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_bcba *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// PdfVersion returns version of the PDF file.
func (_fcdg *PdfParser )PdfVersion ()Version {return _fcdg ._eeg };func (_bbadg *PdfParser )readTextLine ()(string ,error ){var _ccfg _fce .Buffer ;for {_gddb ,_gbfe :=_bbadg ._dcada .Peek (1);if _gbfe !=nil {_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gbfe .Error ());return _ccfg .String (),_gbfe ;};if (_gddb [0]!='\r')&&(_gddb [0]!='\n'){_ggff ,_ :=_bbadg ._dcada .ReadByte ();_ccfg .WriteByte (_ggff );}else {break ;};};return _ccfg .String (),nil ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ddgg *PdfParser )CheckAccessRights (password []byte )(bool ,_fb .Permissions ,error ){if _ddgg ._abbbc ==nil {return true ,_fb .PermOwner ,nil ;};return _ddgg ._abbbc .checkAccessRights (password );};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcdf *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetParser returns the parser for lazy-loading or compare references.
func (_bfdb *PdfObjectReference )GetParser ()*PdfParser {return _bfdb ._eggf };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dee *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_efgf :=MakeDict ();_efgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dee .GetFilterName ()));_bdfg :=_dee .MakeDecodeParams ();if _bdfg !=nil {_efgf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bdfg );};return _efgf ;};func _ffd (_cec *_fb .StdEncryptDict ,_gff *PdfObjectDictionary )error {R ,_eab :=_gff .Get ("\u0052").(*PdfObjectInteger );if !_eab {return _ab .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_cec .R =int (*R );O ,_eab :=_gff .GetString ("\u004f");if !_eab {return _ab .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _cec .R ==5||_cec .R ==6{if len (O )< 48{return _ccd .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ccd .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_cec .O =[]byte (O );U ,_eab :=_gff .GetString ("\u0055");if !_eab {return _ab .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _cec .R ==5||_cec .R ==6{if len (U )< 48{return _ccd .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_bc .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_cec .U =[]byte (U );if _cec .R >=5{OE ,_dccc :=_gff .GetString ("\u004f\u0045");if !_dccc {return _ab .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ccd .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_cec .OE =[]byte (OE );UE ,_dccc :=_gff .GetString ("\u0055\u0045");if !_dccc {return _ab .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ccd .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_cec .UE =[]byte (UE );};P ,_eab :=_gff .Get ("\u0050").(*PdfObjectInteger );if !_eab {return _ab .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_cec .P =_fb .Permissions (*P );if _cec .R ==6{Perms ,_gg :=_gff .GetString ("\u0050\u0065\u0072m\u0073");if !_gg {return _ab .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ccd .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_cec .Perms =[]byte (Perms );};if _ebg ,_bf :=_gff .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_bf {_cec .EncryptMetadata =bool (*_ebg );}else {_cec .EncryptMetadata =true ;};return nil ;};func _cfbde (_gfdc *PdfObjectDictionary )(_eedcd *_ba .ImageBase ){var (_abgge *PdfObjectInteger ;_ggbe bool ;);if _abgge ,_ggbe =_gfdc .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_ggbe {_eedcd =&_ba .ImageBase {Width :int (*_abgge )};}else {return nil ;};if _abgge ,_ggbe =_gfdc .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_ggbe {_eedcd .Height =int (*_abgge );};if _abgge ,_ggbe =_gfdc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_ggbe {_eedcd .BitsPerComponent =int (*_abgge );};if _abgge ,_ggbe =_gfdc .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_ggbe {_eedcd .ColorComponents =int (*_abgge );};return _eedcd ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ggg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dddc *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_dge *PdfParser )lookupObjectViaOS (_eed int ,_fa int )(PdfObject ,error ){var _ge *_fce .Reader ;var _baa objectStream ;var _da bool ;_baa ,_da =_dge ._cfcg [_eed ];if !_da {_fcg ,_dga :=_dge .LookupByNumber (_eed );if _dga !=nil {_bc .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_eed );return nil ,_dga ;};_ae ,_daf :=_fcg .(*PdfObjectStream );if !_daf {return nil ,_ab .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _dge ._abbbc !=nil &&!_dge ._abbbc .isDecrypted (_ae ){return nil ,_ab .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_dcf :=_ae .PdfObjectDictionary ;_bc .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_dcf .String ());_aggf ,_daf :=_dcf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_daf {_bc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_ab .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _dc .ToLower (string (*_aggf ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_ab .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_daf :=_dcf .Get ("\u004e").(*PdfObjectInteger );if !_daf {return nil ,_ab .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ad ,_daf :=_dcf .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_daf {return nil ,_ab .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bc .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_aggf ,*N );_cd ,_dga :=DecodeStream (_ae );if _dga !=nil {return nil ,_dga ;};_bc .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_cd );_bgd :=_dge .GetFileOffset ();defer func (){_dge .SetFileOffset (_bgd )}();_ge =_fce .NewReader (_cd );_dge ._dcada =_db .NewReader (_ge );_bc .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_dgc :=map[int ]int64 {};for _dd :=0;_dd < int (*N );_dd ++{_dge .skipSpaces ();_eg ,_fcd :=_dge .parseNumber ();if _fcd !=nil {return nil ,_fcd ;};_ddg ,_ce :=_eg .(*PdfObjectInteger );if !_ce {return nil ,_ab .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_dge .skipSpaces ();_eg ,_fcd =_dge .parseNumber ();if _fcd !=nil {return nil ,_fcd ;};_dcb ,_ce :=_eg .(*PdfObjectInteger );if !_ce {return nil ,_ab .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_bc .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_ddg ,*_dcb );_dgc [int (*_ddg )]=int64 (*_ad +*_dcb );};_baa =objectStream {N :int (*N ),_bed :_cd ,_ee :_dgc };_dge ._cfcg [_eed ]=_baa ;}else {_abbe :=_dge .GetFileOffset ();defer func (){_dge .SetFileOffset (_abbe )}();_ge =_fce .NewReader (_baa ._bed );_dge ._dcada =_db .NewReader (_ge );};_fgf :=_baa ._ee [_fa ];_bc .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_fa ,_fgf );_ge .Seek (_fgf ,_bg .SeekStart );_dge ._dcada =_db .NewReader (_ge );_ddc ,_ :=_dge ._dcada .Peek (100);_bc .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ddc ));_aec ,_bge :=_dge .parseObject ();if _bge !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bge );return nil ,_bge ;};if _aec ==nil {return nil ,_ab .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gc :=PdfIndirectObject {};_gc .ObjectNumber =int64 (_fa );_gc .PdfObject =_aec ;return &_gc ,nil ;};

// String returns a string describing `streams`.
func (_fgac *PdfObjectStreams )String ()string {return _ccd .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fgac .ObjectNumber );};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// WriteString outputs the object as it is to be written to file.
func (_befg *PdfObjectReference )WriteString ()string {var _cecdd _dc .Builder ;_cecdd .WriteString (_b .FormatInt (_befg .ObjectNumber ,10));_cecdd .WriteString ("\u0020");_cecdd .WriteString (_b .FormatInt (_befg .GenerationNumber ,10));_cecdd .WriteString ("\u0020\u0052");return _cecdd .String ();};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_gcfag *PdfObjectInteger ,_bcgcd bool ){_gcfag ,_bcgcd =TraceToDirectObject (obj ).(*PdfObjectInteger );return _gcfag ,_bcgcd ;};func _bffe (_geca _bg .ReadSeeker ,_bfbb int64 )(*offsetReader ,error ){_abfbg :=&offsetReader {_bged :_geca ,_adbg :_bfbb };_ ,_bgbf :=_abfbg .Seek (0,_bg .SeekStart );return _abfbg ,_bgbf ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_eedac *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _bccd :=val .(type ){case *PdfObjectName :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectDictionary :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectStream :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectString :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectNull :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectInteger :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectArray :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectBool :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectFloat :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfObjectReference :if _bccd !=nil {_eedac .Set (key ,val );};case *PdfIndirectObject :if _bccd !=nil {_eedac .Set (key ,val );};default:_bc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ggeb *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_dffa :=_fce .NewReader (data );var _ceeg []byte ;var _afdd []byte ;_bbee ,_daff :=_dffa .ReadByte ();if _daff ==_bg .EOF {return []byte {},nil ;}else if _daff !=nil {return nil ,_daff ;};_dbd :=1;for {_cad ,_bfed :=_dffa .ReadByte ();if _bfed ==_bg .EOF {break ;}else if _bfed !=nil {return nil ,_bfed ;};if _cad ==_bbee {if len (_afdd )> 0{_afdd =_afdd [:len (_afdd )-1];if len (_afdd )> 0{_ceeg =append (_ceeg ,byte (len (_afdd )-1));_ceeg =append (_ceeg ,_afdd ...);};_dbd =1;_afdd =[]byte {};};_dbd ++;if _dbd >=127{_ceeg =append (_ceeg ,byte (257-_dbd ),_bbee );_dbd =0;};}else {if _dbd > 0{if _dbd ==1{_afdd =[]byte {_bbee };}else {_ceeg =append (_ceeg ,byte (257-_dbd ),_bbee );};_dbd =0;};_afdd =append (_afdd ,_cad );if len (_afdd )>=127{_ceeg =append (_ceeg ,byte (len (_afdd )-1));_ceeg =append (_ceeg ,_afdd ...);_afdd =[]byte {};};};_bbee =_cad ;};if len (_afdd )> 0{_ceeg =append (_ceeg ,byte (len (_afdd )-1));_ceeg =append (_ceeg ,_afdd ...);}else if _dbd > 0{_ceeg =append (_ceeg ,byte (257-_dbd ),_bbee );};_ceeg =append (_ceeg ,128);return _ceeg ,nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_fgce *PdfObjectArray ,_dcbcc bool ){_fgce ,_dcbcc =TraceToDirectObject (obj ).(*PdfObjectArray );return _fgce ,_dcbcc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efd *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_efd ._beb )==0{return nil ;};if len (_efd ._beb )==1{return _efd ._beb [0].MakeDecodeParams ();};_ffgb :=MakeArray ();for _ ,_eafc :=range _efd ._beb {_aeda :=_eafc .MakeDecodeParams ();if _aeda ==nil {_ffgb .Append (MakeNull ());}else {_ffgb .Append (_aeda );};};return _ffgb ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfbe *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func (_bebg *PdfParser )seekToEOFMarker (_eaede int64 )error {var _dbbf int64 ;var _bcc int64 =2048;for _dbbf < _eaede -4{if _eaede <=(_bcc +_dbbf ){_bcc =_eaede -_dbbf ;};_ ,_dgg :=_bebg ._geaf .Seek (-_dbbf -_bcc ,_bg .SeekEnd );if _dgg !=nil {return _dgg ;};_cceffb :=make ([]byte ,_bcc );_bebg ._geaf .Read (_cceffb );_bc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_cceffb ));_cdeb :=_edbd .FindAllStringIndex (string (_cceffb ),-1);if _cdeb !=nil {_gbae :=_cdeb [len (_cdeb )-1];_bc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdeb );_bebg ._geaf .Seek (-_dbbf -_bcc +int64 (_gbae [0]),_bg .SeekEnd );return nil ;};_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_dbbf +=_bcc -4;};_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _ab .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// UpdateParams updates the parameter values of the encoder.
func (_gab *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_dbcf ,_efgdb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _efgdb ==nil {_gab .Predictor =int (_dbcf );};_gdcg ,_efgdb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _efgdb ==nil {_gab .BitsPerComponent =int (_gdcg );};_fag ,_efgdb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _efgdb ==nil {_gab .Columns =int (_fag );};_fcba ,_efgdb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _efgdb ==nil {_gab .Colors =int (_fcba );};};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_gaab *PdfCrypt )GetAccessPermissions ()_fb .Permissions {return _gaab ._bbe .P };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_affe :_ecf .InitEncodeDocument (false )}};func (_cagb *PdfObjectFloat )String ()string {return _ccd .Sprintf ("\u0025\u0066",*_cagb )};const (_acaf =0;_fdbe =1;_ebgg =2;_cgdd =3;_fcde =4;);

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gagcb *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _dfcd ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _aeca :=_gagcb .AddPageImage (img ,&_gagcb .DefaultPageSettings );_aeca !=nil {return nil ,_de .Wrap (_aeca ,_dfcd ,"");};return _gagcb .Encode ();};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_ccfec *PdfObjectStreams ,_edfdg bool ){_ccfec ,_edfdg =obj .(*PdfObjectStreams );return _ccfec ,_edfdg ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_bcdd *PdfObjectArray )Get (i int )PdfObject {if _bcdd ==nil ||i >=len (_bcdd ._fgfd )||i < 0{return nil ;};return _bcdd ._fgfd [i ];};

// String returns the state of the bool as "true" or "false".
func (_edag *PdfObjectBool )String ()string {if *_edag {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func _cb (_cgg *_fb .StdEncryptDict ,_eff *PdfObjectDictionary ){_eff .Set ("\u0052",MakeInteger (int64 (_cgg .R )));_eff .Set ("\u0050",MakeInteger (int64 (_cgg .P )));_eff .Set ("\u004f",MakeStringFromBytes (_cgg .O ));_eff .Set ("\u0055",MakeStringFromBytes (_cgg .U ));if _cgg .R >=5{_eff .Set ("\u004f\u0045",MakeStringFromBytes (_cgg .OE ));_eff .Set ("\u0055\u0045",MakeStringFromBytes (_cgg .UE ));_eff .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_cgg .EncryptMetadata ));if _cgg .R > 5{_eff .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_cgg .Perms ));};};};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_dceaa :=&PdfObjectDictionary {};_dceaa ._edef =map[PdfObjectName ]PdfObject {};_dceaa ._bcffe =[]PdfObjectName {};return _dceaa ;};func _agaa (_dgea *PdfObjectStream ,_dcab *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_dfeg :=NewCCITTFaxEncoder ();_dbcfg :=_dgea .PdfObjectDictionary ;if _dbcfg ==nil {return _dfeg ,nil ;};if _dcab ==nil {_gdea :=TraceToDirectObject (_dbcfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gdea !=nil {switch _aabf :=_gdea .(type ){case *PdfObjectDictionary :_dcab =_aabf ;case *PdfObjectArray :if _aabf .Len ()==1{if _eeeb ,_gcfg :=GetDict (_aabf .Get (0));_gcfg {_dcab =_eeeb ;};};default:_bc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gdea );return nil ,_ab .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dcab ==nil {_bc .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gdea );return nil ,_ab .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fdda ,_eabeb :=GetNumberAsInt64 (_dcab .Get ("\u004b"));_eabeb ==nil {_dfeg .K =int (_fdda );};if _egeg ,_bdee :=GetNumberAsInt64 (_dcab .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_bdee ==nil {_dfeg .Columns =int (_egeg );}else {_dfeg .Columns =1728;};if _gaba ,_bbed :=GetNumberAsInt64 (_dcab .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bbed ==nil {_dfeg .BlackIs1 =_gaba > 0;}else {if _ffbg ,_dfad :=GetBoolVal (_dcab .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dfad {_dfeg .BlackIs1 =_ffbg ;}else {if _ece ,_cac :=GetArray (_dcab .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cac {_adc ,_dfb :=_ece .ToIntegerArray ();if _dfb ==nil {_dfeg .BlackIs1 =_adc [0]==1&&_adc [1]==0;};};};};if _cdba ,_cfeb :=GetNumberAsInt64 (_dcab .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cfeb ==nil {_dfeg .EncodedByteAlign =_cdba > 0;}else {if _gacfg ,_eadgd :=GetBoolVal (_dcab .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eadgd {_dfeg .EncodedByteAlign =_gacfg ;};};if _cfafc ,_cecg :=GetNumberAsInt64 (_dcab .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cecg ==nil {_dfeg .EndOfLine =_cfafc > 0;}else {if _fbae ,_gca :=GetBoolVal (_dcab .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gca {_dfeg .EndOfLine =_fbae ;};};if _adf ,_dgad :=GetNumberAsInt64 (_dcab .Get ("\u0052\u006f\u0077\u0073"));_dgad ==nil {_dfeg .Rows =int (_adf );};_dfeg .EndOfBlock =true ;if _cddf ,_faba :=GetNumberAsInt64 (_dcab .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_faba ==nil {_dfeg .EndOfBlock =_cddf > 0;}else {if _cagf ,_dgfe :=GetBoolVal (_dcab .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dgfe {_dfeg .EndOfBlock =_cagf ;};};if _gaad ,_adbf :=GetNumberAsInt64 (_dcab .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_adbf !=nil {_dfeg .DamagedRowsBeforeError =int (_gaad );};_bc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dcab .String ());return _dfeg ,nil ;};func (_abfbgd *PdfParser )resolveReference (_cage *PdfObjectReference )(PdfObject ,bool ,error ){_cefg ,_fbgf :=_abfbgd .ObjCache [int (_cage .ObjectNumber )];if _fbgf {return _cefg ,true ,nil ;};_dfdb ,_eedg :=_abfbgd .LookupByReference (*_cage );if _eedg !=nil {return nil ,false ,_eedg ;};_abfbgd .ObjCache [int (_cage .ObjectNumber )]=_dfdb ;return _dfdb ,false ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_bdeb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _babged []float64 ;for _ ,_gbbgc :=range _bdeb .Elements (){_eggc ,_fgbab :=GetNumberAsFloat (TraceToDirectObject (_gbbgc ));if _fgbab !=nil {return nil ,_ccd .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_babged =append (_babged ,_eggc );};return _babged ,nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_febc :=PdfObjectNull {};return &_febc };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bcfc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_eedc :=MakeDict ();_eedc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcfc .GetFilterName ()));_fece :=_bcfc .MakeDecodeParams ();if _fece !=nil {_eedc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fece );};return _eedc ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_eeff *JBIG2Encoder )Encode ()(_dgeb []byte ,_afga error ){const _bdc ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _eeff ._affe ==nil {return nil ,_de .Errorf (_bdc ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_eeff ._affe .FullHeaders =_eeff .DefaultPageSettings .FileMode ;_dgeb ,_afga =_eeff ._affe .Encode ();if _afga !=nil {return nil ,_de .Wrap (_afga ,_bdc ,"");};return _dgeb ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_bcfad *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcfad .DecodeBytes (streamObj .Stream );};func (_ecfd *FlateEncoder )cleanImageData (_dacg []byte )([]byte ,error ){if _ecfd ._ggf ==nil {return _dacg ,nil ;};if _ecfd ._ggf .BitsPerComponent >=8{return _dacg ,nil ;};_dfgg :=_ecfd ._ggf .BitsPerComponent *_ecfd ._ggf .Width *_ecfd ._ggf .ColorComponents *_ecfd ._ggf .Height /8;_dacg =_dacg [:_dfgg ];var _dda error ;_dacg ,_dda =_ba .AddDataPadding (_ecfd ._ggf .Width ,_ecfd ._ggf .Height ,_ecfd ._ggf .BitsPerComponent ,_ecfd ._ggf .ColorComponents ,_dacg );if _dda !=nil {return nil ,_dda ;};return _dacg ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_bagd *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bagd ._fgfd ){return _ab .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bagd ._fgfd [i ]=obj ;return nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_cded :=MultiEncoder {};_cded ._beb =[]StreamEncoder {};return &_cded ;};

// WriteString outputs the object as it is to be written to file.
func (_bcad *PdfObjectString )WriteString ()string {var _bacd _fce .Buffer ;if _bcad ._bfee {_agae :=_be .EncodeToString (_bcad .Bytes ());_bacd .WriteString ("\u003c");_bacd .WriteString (_agae );_bacd .WriteString ("\u003e");return _bacd .String ();};_ccgdg :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_bacd .WriteString ("\u0028");for _eeefa :=0;_eeefa < len (_bcad ._gafc );_eeefa ++{_cdace :=_bcad ._gafc [_eeefa ];if _ddcb ,_gggd :=_ccgdg [_cdace ];_gggd {_bacd .WriteString (_ddcb );}else {_bacd .WriteByte (_cdace );};};_bacd .WriteString ("\u0029");return _bacd .String ();};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func _bef (_ac XrefTable ){_bc .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_bc .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gec :=0;for _ ,_aece :=range _ac .ObjectMap {_bc .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_gec +1,_aece .ObjectNumber ,_aece .Generation ,_aece .Offset );_gec ++;};};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_aaad *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ddfa _fce .Buffer ;_dece :=_fce .NewReader (encoded );var _ccgb _bg .ReadCloser ;if _aaad .EarlyChange ==1{_ccgb =_fd .NewReader (_dece ,_fd .MSB ,8);}else {_ccgb =_cc .NewReader (_dece ,_cc .MSB ,8);};defer _ccgb .Close ();_ ,_ebba :=_ddfa .ReadFrom (_ccgb );if _ebba !=nil {return nil ,_ebba ;};return _ddfa .Bytes (),nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gedg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cbcb :=MakeDict ();_cbcb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gedg .GetFilterName ()));return _cbcb ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_cbaa *PdfParser )GetFileOffset ()int64 {_babb ,_ :=_cbaa ._geaf .Seek (0,_bg .SeekCurrent );_babb -=int64 (_cbaa ._dcada .Buffered ());return _babb ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _bg .ReadSeeker )(*PdfParser ,error ){_ecd :=&PdfParser {_geaf :rs ,ObjCache :make (objectCache ),_egcd :map[int64 ]bool {}};_aecc ,_ddcd ,_fdaa :=_ecd .parsePdfVersion ();if _fdaa !=nil {_bc .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_fdaa );return nil ,_fdaa ;};_ecd ._eeg .Major =_aecc ;_ecd ._eeg .Minor =_ddcd ;if _ecd ._dccd ,_fdaa =_ecd .loadXrefs ();_fdaa !=nil {_bc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_fdaa );return nil ,_fdaa ;};_bc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ecd ._dccd );if len (_ecd ._cgbd .ObjectMap )==0{return nil ,_ccd .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ecd ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_bcgf *PdfObjectBool ,_gbfg bool ){_bcgf ,_gbfg =TraceToDirectObject (obj ).(*PdfObjectBool );return _bcgf ,_gbfg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_egc *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_ceaf :=MakeDict ();_ceaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egc .GetFilterName ()));return _ceaf ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_abce *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _abce .Predictor !=1{return nil ,_ccd .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _abce .EarlyChange ==1{return nil ,_ccd .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _acfc _fce .Buffer ;_eadf :=_cc .NewWriter (&_acfc ,_cc .MSB ,8);_eadf .Write (data );_eadf .Close ();return _acfc .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgaga *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_fdb *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bc .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_ggfc :=_fce .NewReader (encoded );_bafde ,_gfgg :=_fc .NewReader (_ggfc );if _gfgg !=nil {_bc .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gfgg );_bc .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_gfgg ;};defer _bafde .Close ();var _dade _fce .Buffer ;_dade .ReadFrom (_bafde );return _dade .Bytes (),nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_dcbd *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_bdgdg ,_cabg :=_dcbd ._edef [key ];if !_cabg {return nil ;};return _bdgdg ;};

// UpdateParams updates the parameter values of the encoder.
func (_ffbdc *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_geega *PdfObjectReference )Resolve ()PdfObject {if _geega ._eggf ==nil {return MakeNull ();};_gaafa ,_ ,_agbcb :=_geega ._eggf .resolveReference (_geega );if _agbcb !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_agbcb );return MakeNull ();};if _gaafa ==nil {_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _gaafa ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gcbce *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_dba :=MakeDict ();_dba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gcbce .GetFilterName ()));return _dba ;};func (_dfac *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _dfac ._acegg {return nil ,_ccd .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_dfac ._acegg =true ;_dfac ._geaf .Seek (0,_bg .SeekStart );_dfac ._dcada =_db .NewReader (_dfac ._geaf );_fdbc :=20;_ddce :=make ([]byte ,_fdbc );_cdddf :=XrefTable {};_cdddf .ObjectMap =make (map[int ]XrefObject );for {_affge ,_gcdc :=_dfac ._dcada .ReadByte ();if _gcdc !=nil {if _gcdc ==_bg .EOF {break ;}else {return nil ,_gcdc ;};};if _affge =='j'&&_ddce [_fdbc -1]=='b'&&_ddce [_fdbc -2]=='o'&&IsWhiteSpace (_ddce [_fdbc -3]){_bffga :=_fdbc -4;for IsWhiteSpace (_ddce [_bffga ])&&_bffga > 0{_bffga --;};if _bffga ==0||!IsDecimalDigit (_ddce [_bffga ]){continue ;};for IsDecimalDigit (_ddce [_bffga ])&&_bffga > 0{_bffga --;};if _bffga ==0||!IsWhiteSpace (_ddce [_bffga ]){continue ;};for IsWhiteSpace (_ddce [_bffga ])&&_bffga > 0{_bffga --;};if _bffga ==0||!IsDecimalDigit (_ddce [_bffga ]){continue ;};for IsDecimalDigit (_ddce [_bffga ])&&_bffga > 0{_bffga --;};if _bffga ==0{continue ;};_fcfc :=_dfac .GetFileOffset ()-int64 (_fdbc -_bffga );_aaba :=append (_ddce [_bffga +1:],_affge );_bacc ,_caafe ,_becdg :=_cfcb (string (_aaba ));if _becdg !=nil {_bc .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_becdg );return nil ,_becdg ;};if _aadadg ,_aefa :=_cdddf .ObjectMap [_bacc ];!_aefa ||_aadadg .Generation < _caafe {_cfeef :=XrefObject {};_cfeef .XType =XrefTypeTableEntry ;_cfeef .ObjectNumber =_bacc ;_cfeef .Generation =_caafe ;_cfeef .Offset =_fcfc ;_cdddf .ObjectMap [_bacc ]=_cfeef ;};};_ddce =append (_ddce [1:_fdbc ],_affge );};_dfac ._dbf =nil ;return &_cdddf ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fbgb *PdfObjectStreams )WriteString ()string {var _gebd _dc .Builder ;_gebd .WriteString (_b .FormatInt (_fbgb .ObjectNumber ,10));_gebd .WriteString ("\u0020\u0030\u0020\u0052");return _gebd .String ();};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_gaef *PdfParser )parseHexString ()(*PdfObjectString ,error ){_gaef ._dcada .ReadByte ();var _gbgg _fce .Buffer ;for {_bdbc ,_gbde :=_gaef ._dcada .Peek (1);if _gbde !=nil {return MakeString (""),_gbde ;};if _bdbc [0]=='>'{_gaef ._dcada .ReadByte ();break ;};_bebe ,_ :=_gaef ._dcada .ReadByte ();if !IsWhiteSpace (_bebe ){_gbgg .WriteByte (_bebe );};};if _gbgg .Len ()%2==1{_gbgg .WriteRune ('0');};_ecfc ,_ :=_be .DecodeString (_gbgg .String ());return MakeHexString (string (_ecfc )),nil ;};func (_ffac *PdfCrypt )loadCryptFilters (_cfg *PdfObjectDictionary )error {_ffac ._ege =cryptFilters {};_ebf :=_cfg .Get ("\u0043\u0046");_ebf =TraceToDirectObject (_ebf );if _gdf ,_cga :=_ebf .(*PdfObjectReference );_cga {_fafc ,_dea :=_ffac ._ccc .LookupByReference (*_gdf );if _dea !=nil {_bc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _dea ;};_ebf =TraceToDirectObject (_fafc );};_fcab ,_fgb :=_ebf .(*PdfObjectDictionary );if !_fgb {_bc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ebf );return _ab .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_dcbb :=range _fcab .Keys (){_gcf :=_fcab .Get (_dcbb );if _eag ,_bad :=_gcf .(*PdfObjectReference );_bad {_bbac ,_bfe :=_ffac ._ccc .LookupByReference (*_eag );if _bfe !=nil {_bc .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _bfe ;};_gcf =TraceToDirectObject (_bbac );};_cgb ,_ffaf :=_gcf .(*PdfObjectDictionary );if !_ffaf {return _ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_dcbb ,_gcf );};if _dcbb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _cea _fbb .FilterDict ;if _efa :=_dca (&_cea ,_cgb );_efa !=nil {return _efa ;};_bafd ,_bfa :=_fbb .NewFilter (_cea );if _bfa !=nil {return _bfa ;};_ffac ._ege [string (_dcbb )]=_bafd ;};_ffac ._ege ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_fbb .NewIdentity ();_ffac ._gac ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bcb ,_fbf :=_cfg .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_fbf {if _ ,_fgg :=_ffac ._ege [string (*_bcb )];!_fgg {return _ccd .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bcb );};_ffac ._gac =string (*_bcb );};_ffac ._ecc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dafe ,_edd :=_cfg .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_edd {if _ ,_ddfg :=_ffac ._ege [string (*_dafe )];!_ddfg {return _ccd .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dafe );};_ffac ._ecc =string (*_dafe );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fbbd *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_cbgf *PdfParser )IsAuthenticated ()bool {return _cbgf ._abbbc ._cgd };func (_ccg *PdfCrypt )decryptBytes (_eafg []byte ,_dfe string ,_def []byte )([]byte ,error ){_bc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_efef ,_dce :=_ccg ._ege [_dfe ];if !_dce {return nil ,_ccd .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dfe );};return _efef .DecryptBytes (_eafg ,_def );};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ggbf *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _caaga []int ;for _ ,_begbg :=range _ggbf .Elements (){if _egcdf ,_ebfe :=_begbg .(*PdfObjectInteger );_ebfe {_caaga =append (_caaga ,int (*_egcdf ));}else {return nil ,ErrTypeError ;};};return _caaga ,nil ;};type objectCache map[int ]PdfObject ;

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_adge *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_adge .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};type objectStreams map[int ]objectStream ;func (_adeac *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _cadb =20;_dbcce ,_ :=_adeac ._dcada .Peek (_cadb );for _fgae :=0;_fgae < 2;_fgae ++{if _adeac ._gdbd ==0{_adeac ._gdbd =_adeac .GetFileOffset ();};if _acfd .Match (_dbcce ){_bc .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_bc .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dbcce ));return _adeac .parseXrefStream (nil );};if _faab .Match (_dbcce ){_bc .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _adeac .parseXrefTable ();};_dcgc :=_adeac .GetFileOffset ();if _adeac ._gdbd ==0{_adeac ._gdbd =_dcgc ;};_adeac .SetFileOffset (_dcgc -_cadb );defer _adeac .SetFileOffset (_dcgc );_bgaea ,_ :=_adeac ._dcada .Peek (_cadb );_dbcce =append (_bgaea ,_dbcce ...);};_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _bggd :=_adeac .repairSeekXrefMarker ();_bggd !=nil {_bc .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_bggd );return nil ,_bggd ;};return _adeac .parseXrefTable ();};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_affcg *PdfParser )Inspect ()(map[string ]int ,error ){return _affcg .inspect ()};type cryptFilters map[string ]_fbb .Filter ;

// Append appends PdfObject(s) to the array.
func (_cafa *PdfObjectArray )Append (objects ...PdfObject ){if _cafa ==nil {_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_cafa ._fgfd =append (_cafa ._fgfd ,objects ...);};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_ffeb *PdfParser )GetCrypter ()*PdfCrypt {return _ffeb ._abbbc };

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _ebdce ,_badad :=obj .(*PdfObjectReference );_badad {obj =_ebdce .Resolve ();};_dbdfa ,_dbbe :=obj .(*PdfIndirectObject );_gfabc :=0;for _dbbe {obj =_dbdfa .PdfObject ;_dbdfa ,_dbbe =GetIndirect (obj );_gfabc ++;if _gfabc > _efadg {_bc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_efadg );return nil ;};};return obj ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_abed *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_bcbb :=PdfIndirectObject {};_bcbb ._eggf =_abed ;_bc .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gcfe ,_gcbcb :=_abed ._dcada .Peek (20);if _gcbcb !=nil {if _gcbcb !=_bg .EOF {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_bcbb ,_gcbcb ;};};_bc .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gcfe ));_egcf :=_acfd .FindStringSubmatchIndex (string (_gcfe ));if len (_egcf )< 6{if _gcbcb ==_bg .EOF {return nil ,_gcbcb ;};_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcfe ));return &_bcbb ,_ab .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_abed ._dcada .Discard (_egcf [0]);_bc .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_egcf );_fgde :=_egcf [1]-_egcf [0];_gaac :=make ([]byte ,_fgde );_ ,_gcbcb =_abed .ReadAtLeast (_gaac ,_fgde );if _gcbcb !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_gcbcb );return nil ,_gcbcb ;};_bc .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gaac );_ggdd :=_acfd .FindStringSubmatch (string (_gaac ));if len (_ggdd )< 3{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gaac ));return &_bcbb ,_ab .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_eacec ,_ :=_b .Atoi (_ggdd [1]);_fdfe ,_ :=_b .Atoi (_ggdd [2]);_bcbb .ObjectNumber =int64 (_eacec );_bcbb .GenerationNumber =int64 (_fdfe );for {_ecac ,_fgdf :=_abed ._dcada .Peek (2);if _fgdf !=nil {return &_bcbb ,_fgdf ;};_bc .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ecac ),string (_ecac ));if IsWhiteSpace (_ecac [0]){_abed .skipSpaces ();}else if _ecac [0]=='%'{_abed .skipComments ();}else if (_ecac [0]=='<')&&(_ecac [1]=='<'){_bc .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_bcbb .PdfObject ,_fgdf =_abed .ParseDict ();_bc .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_fgdf );if _fgdf !=nil {return &_bcbb ,_fgdf ;};_bc .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_ecac [0]=='/')||(_ecac [0]=='(')||(_ecac [0]=='[')||(_ecac [0]=='<'){_bcbb .PdfObject ,_fgdf =_abed .parseObject ();if _fgdf !=nil {return &_bcbb ,_fgdf ;};_bc .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _ecac [0]==']'{_bc .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_abed ._dcada .Discard (1);}else {if _ecac [0]=='e'{_beea ,_aeacc :=_abed .readTextLine ();if _aeacc !=nil {return nil ,_aeacc ;};if len (_beea )>=6&&_beea [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _ecac [0]=='s'{_ecac ,_ =_abed ._dcada .Peek (10);if string (_ecac [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_eeea :=6;if len (_ecac )> 6{if IsWhiteSpace (_ecac [_eeea ])&&_ecac [_eeea ]!='\r'&&_ecac [_eeea ]!='\n'{_bc .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_eeea ++;};if _ecac [_eeea ]=='\r'{_eeea ++;if _ecac [_eeea ]=='\n'{_eeea ++;};}else if _ecac [_eeea ]=='\n'{_eeea ++;};};_abed ._dcada .Discard (_eeea );_bgaa ,_affcf :=_bcbb .PdfObject .(*PdfObjectDictionary );if !_affcf {return nil ,_ab .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_bgaa );_fcgfb ,_cfac :=_abed .traceStreamLength (_bgaa .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _cfac !=nil {_bc .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_cfac );return nil ,_cfac ;};_bc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fcgfb );_gcbg ,_bdec :=_fcgfb .(*PdfObjectInteger );if !_bdec {return nil ,_ab .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_dddg :=*_gcbg ;if _dddg < 0{return nil ,_ab .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_egg :=_abed .GetFileOffset ();_gacfga :=_abed .xrefNextObjectOffset (_egg );if _egg +int64 (_dddg )> _gacfga &&_gacfga > _egg {_bc .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_egg +int64 (_dddg ));_bc .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gacfga );_bbca :=_gacfga -_egg -17;if _bbca < 0{return nil ,_ab .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_bc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_bbca );_dddg =PdfObjectInteger (_bbca );_bgaa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_bbca ));};if int64 (_dddg )> _abed ._bdgd {_bc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_ab .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_gfbg :=make ([]byte ,_dddg );_ ,_cfac =_abed .ReadAtLeast (_gfbg ,int (_dddg ));if _cfac !=nil {_bc .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_gfbg ),_gfbg );_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cfac );return nil ,_cfac ;};_defe :=PdfObjectStream {};_defe .Stream =_gfbg ;_defe .PdfObjectDictionary =_bcbb .PdfObject .(*PdfObjectDictionary );_defe .ObjectNumber =_bcbb .ObjectNumber ;_defe .GenerationNumber =_bcbb .GenerationNumber ;_defe .PdfObjectReference ._eggf =_abed ;_abed .skipSpaces ();_abed ._dcada .Discard (9);_abed .skipSpaces ();return &_defe ,nil ;};};_bcbb .PdfObject ,_fgdf =_abed .parseObject ();if _bcbb .PdfObject ==nil {_bc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_bcbb .PdfObject =MakeNull ();};return &_bcbb ,_fgdf ;};};if _bcbb .PdfObject ==nil {_bc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_bcbb .PdfObject =MakeNull ();};_bc .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_bcbb ,nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_cbcf *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _faa [][]byte ;for _ddgd :=0;_ddgd < len (data );_ddgd +=_cbcf .Columns {_cbgb :=make ([]byte ,_cbcf .Columns );_gddc :=0;for _agged :=0;_agged < _cbcf .Columns ;_agged ++{if data [_ddgd +_agged ]==255{_cbgb [_gddc ]=1;}else {_cbgb [_gddc ]=0;};_gddc ++;};_faa =append (_faa ,_cbgb );};_gdbf :=&_gf .Encoder {K :_cbcf .K ,Columns :_cbcf .Columns ,EndOfLine :_cbcf .EndOfLine ,EndOfBlock :_cbcf .EndOfBlock ,BlackIs1 :_cbcf .BlackIs1 ,DamagedRowsBeforeError :_cbcf .DamagedRowsBeforeError ,Rows :_cbcf .Rows ,EncodedByteAlign :_cbcf .EncodedByteAlign };return _gdbf .Encode (_faa ),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_debf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fffd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _fffd .Predictor !=1&&_fffd .Predictor !=11{_bc .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _fffd .Predictor ==11{_bbbc :=_fffd .Columns ;_cbed :=len (data )/_bbbc ;if len (data )%_bbbc !=0{_bc .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_ab .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cba :=_fce .NewBuffer (nil );_debe :=make ([]byte ,_bbbc );for _dacb :=0;_dacb < _cbed ;_dacb ++{_afgc :=data [_bbbc *_dacb :_bbbc *(_dacb +1)];_debe [0]=_afgc [0];for _dagd :=1;_dagd < _bbbc ;_dagd ++{_debe [_dagd ]=byte (int (_afgc [_dagd ]-_afgc [_dagd -1])%256);};_cba .WriteByte (1);_cba .Write (_debe );};data =_cba .Bytes ();};var _afbg _fce .Buffer ;_bfaf :=_fc .NewWriter (&_afbg );_bfaf .Write (data );_bfaf .Close ();return _afbg .Bytes (),nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _cfbc (obj ,0)};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abad *LZWEncoder )MakeDecodeParams ()PdfObject {if _abad .Predictor > 1{_dcaa :=MakeDict ();_dcaa .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_abad .Predictor )));if _abad .BitsPerComponent !=8{_dcaa .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_abad .BitsPerComponent )));};if _abad .Columns !=1{_dcaa .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_abad .Columns )));};if _abad .Colors !=1{_dcaa .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_abad .Colors )));};return _dcaa ;};return nil ;};

// GetXrefTable returns the PDFs xref table.
func (_ebeb *PdfParser )GetXrefTable ()XrefTable {return _ebeb ._cgbd };

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_bdfa []byte ,_fbdfb bool ){_eadb ,_fbdfb :=TraceToDirectObject (obj ).(*PdfObjectString );if _fbdfb {return _eadb .Bytes (),true ;};return ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bc .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bbdeb ,_gafae :=NewEncoderFromStream (streamObj );if _gafae !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_gafae );return nil ,_gafae ;};_bc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_bbdeb );_gegg ,_gafae :=_bbdeb .DecodeStream (streamObj );if _gafae !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_gafae );return nil ,_gafae ;};return _gegg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bdga *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_dbg *PdfCrypt )saveCryptFilters (_dae *PdfObjectDictionary )error {if _dbg ._bbfc .V < 4{return _ab .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_dfc :=MakeDict ();_dae .Set ("\u0043\u0046",_dfc );for _aaa ,_fdg :=range _dbg ._ege {if _aaa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_decd :=_bafa (_fdg ,"");_dfc .Set (PdfObjectName (_aaa ),_decd );};_dae .Set ("\u0053\u0074\u0072\u0046",MakeName (_dbg ._gac ));_dae .Set ("\u0053\u0074\u006d\u0046",MakeName (_dbg ._ecc ));return nil ;};var _acfd =_g .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_cfde *JBIG2Image )ToGoImage ()(_f .Image ,error ){const _gbdb ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _cfde .Data ==nil {return nil ,_de .Error (_gbdb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cfde .Width ==0||_cfde .Height ==0{return nil ,_de .Error (_gbdb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_agfb ,_faea :=_ba .NewImage (_cfde .Width ,_cfde .Height ,1,1,_cfde .Data ,nil ,nil );if _faea !=nil {return nil ,_faea ;};return _agfb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ebgf *PdfObjectInteger )WriteString ()string {return _b .FormatInt (int64 (*_ebgf ),10)};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ddae *JBIG2Encoder )DecodeGlobals (encoded []byte )(_eb .Globals ,error ){return _eb .DecodeGlobals (encoded );};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_ccbe :=&LZWEncoder {};_ccbe .Predictor =1;_ccbe .BitsPerComponent =8;_ccbe .Colors =1;_ccbe .Columns =1;_ccbe .EarlyChange =1;return _ccbe ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbgcg *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _dbcda []int64 ;for _ ,_eagd :=range _dbgcg .Elements (){if _bcbag ,_cdff :=_eagd .(*PdfObjectInteger );_cdff {_dbcda =append (_dbcda ,int64 (*_bcbag ));}else {return nil ,ErrTypeError ;};};return _dbcda ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _adeb ,_eaea :=obj .(*PdfObjectReference );_eaea {return _adeb .Resolve ();};return obj ;};

// GetFilterName returns the name of the encoding filter.
func (_gacf *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// WriteString outputs the object as it is to be written to file.
func (_ebbae *PdfIndirectObject )WriteString ()string {var _ceab _dc .Builder ;_ceab .WriteString (_b .FormatInt (_ebbae .ObjectNumber ,10));_ceab .WriteString ("\u0020\u0030\u0020\u0052");return _ceab .String ();};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_aada *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aada .DecodeBytes (streamObj .Stream );};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gaegd *PdfParser )GetXrefType ()*xrefType {return _gaegd ._gdag };

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_gcfad *ASCII85Encoder )base256Tobase85 (_dfdf uint32 )[5]byte {_befaa :=[5]byte {0,0,0,0,0};_cde :=_dfdf ;for _ega :=0;_ega < 5;_ega ++{_afgd :=uint32 (1);for _cddb :=0;_cddb < 4-_ega ;_cddb ++{_afgd *=85;};_fdc :=_cde /_afgd ;_cde =_cde %_afgd ;_befaa [_ega ]=byte (_fdc );};return _befaa ;};func _fedgf (_acgc *PdfObjectStream ,_cdgg *PdfObjectDictionary )(*FlateEncoder ,error ){_dcba :=NewFlateEncoder ();_feda :=_acgc .PdfObjectDictionary ;if _feda ==nil {return _dcba ,nil ;};_dcba ._ggf =_cfbde (_feda );if _cdgg ==nil {_ccef :=TraceToDirectObject (_feda .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _cegd :=_ccef .(type ){case *PdfObjectArray :if _cegd .Len ()!=1{_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_cegd .Len ());return nil ,_ab .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _aef ,_ddbd :=GetDict (_cegd .Get (0));_ddbd {_cdgg =_aef ;};case *PdfObjectDictionary :_cdgg =_cegd ;case *PdfObjectNull ,nil :default:_bc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_ccef );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdgg ==nil {return _dcba ,nil ;};_bc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cdgg .String ());_cgga :=_cdgg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _cgga ==nil {_bc .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_fage ,_ffcf :=_cgga .(*PdfObjectInteger );if !_ffcf {_bc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cgga );return nil ,_ccd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dcba .Predictor =int (*_fage );};_cgga =_cdgg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _cgga !=nil {_aag ,_ebb :=_cgga .(*PdfObjectInteger );if !_ebb {_bc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ccd .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dcba .BitsPerComponent =int (*_aag );};if _dcba .Predictor > 1{_dcba .Columns =1;_cgga =_cdgg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _cgga !=nil {_affg ,_gdd :=_cgga .(*PdfObjectInteger );if !_gdd {return nil ,_ccd .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dcba .Columns =int (*_affg );};_dcba .Colors =1;_cgga =_cdgg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cgga !=nil {_caf ,_fbag :=_cgga .(*PdfObjectInteger );if !_fbag {return nil ,_ccd .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_dcba .Colors =int (*_caf );};};return _dcba ,nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_bc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gbdfe ,_bbfbb :=NewEncoderFromStream (streamObj );if _bbfbb !=nil {_bc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bbfbb );return _bbfbb ;};if _dccdd ,_bfeef :=_gbdfe .(*LZWEncoder );_bfeef {_dccdd .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_bc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_gbdfe );_adgc ,_bbfbb :=_gbdfe .EncodeBytes (streamObj .Stream );if _bbfbb !=nil {_bc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bbfbb );return _bbfbb ;};streamObj .Stream =_adgc ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_adgc ))));return nil ;};

// String returns a string describing `stream`.
func (_caga *PdfObjectStream )String ()string {return _ccd .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_caga .ObjectNumber ,_caga .PdfObjectDictionary );};func _cfcb (_gabe string )(int ,int ,error ){_ccgg :=_acfd .FindStringSubmatch (_gabe );if len (_ccgg )< 3{return 0,0,_ab .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_edfc ,_ :=_b .Atoi (_ccgg [1]);_fgab ,_ :=_b .Atoi (_ccgg [2]);return _edfc ,_fgab ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_beb []StreamEncoder };

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_cfeed :=PdfObjectString {_gafc :s ,_bfee :true };return &_cfeed ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bgag bool ,_geebd bool ){_geegd ,_geebd :=TraceToDirectObject (obj ).(*PdfObjectBool );if _geebd {return bool (*_geegd ),true ;};return false ,false ;};

// DecodeStream implements ASCII hex decoding.
func (_cege *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cege .DecodeBytes (streamObj .Stream );};func (_bdgf *JBIG2Image )toBitmap ()(_adcf *_fg .Bitmap ,_aagb error ){const _gacb ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _bdgf .Data ==nil {return nil ,_de .Error (_gacb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bdgf .Width ==0||_bdgf .Height ==0{return nil ,_de .Error (_gacb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _bdgf .HasPadding {_adcf ,_aagb =_fg .NewWithData (_bdgf .Width ,_bdgf .Height ,_bdgf .Data );}else {_adcf ,_aagb =_fg .NewWithUnpaddedData (_bdgf .Width ,_bdgf .Height ,_bdgf .Data );};if _aagb !=nil {return nil ,_de .Wrap (_aagb ,_gacb ,"");};return _adcf ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _gacff (obj1 ,obj2 ,0)};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_ffc *FlateEncoder )SetPredictor (columns int ){_ffc .Predictor =11;_ffc .Columns =columns };

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_bfgad string ,_ddee bool ){_deee ,_ddee :=TraceToDirectObject (obj ).(*PdfObjectString );if _ddee {return _deee .Str (),true ;};return ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aebb *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aebb .isDecrypted (obj ){return nil ;};switch _bace :=obj .(type ){case *PdfIndirectObject :_aebb ._afg [_bace ]=true ;_bc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bace .ObjectNumber ,_bace .GenerationNumber );_fddf :=_bace .ObjectNumber ;_cfed :=_bace .GenerationNumber ;_afce :=_aebb .Decrypt (_bace .PdfObject ,_fddf ,_cfed );if _afce !=nil {return _afce ;};return nil ;case *PdfObjectStream :_aebb ._afg [_bace ]=true ;_gef :=_bace .PdfObjectDictionary ;if _aebb ._bbe .R !=5{if _cgag ,_fcb :=_gef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fcb &&*_cgag =="\u0058\u0052\u0065\u0066"{return nil ;};};_dgcd :=_bace .ObjectNumber ;_cee :=_bace .GenerationNumber ;_bc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dgcd ,_cee );_babf :=_ecab ;if _aebb ._bbfc .V >=4{_babf =_aebb ._ecc ;_bc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aebb ._ecc );if _cdb ,_aac :=_gef .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_aac {if _dbgc ,_gdfa :=GetName (_cdb .Get (0));_gdfa {if *_dbgc =="\u0043\u0072\u0079p\u0074"{_babf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fec ,_acg :=_gef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_acg {if _gcg ,_fge :=_fec .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fge {if _ ,_gee :=_aebb ._ege [string (*_gcg )];_gee {_bc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gcg );_babf =string (*_gcg );};};};};};};_bc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_babf );if _babf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_gbd :=_aebb .Decrypt (_gef ,_dgcd ,_cee );if _gbd !=nil {return _gbd ;};_bbd ,_gbd :=_aebb .makeKey (_babf ,uint32 (_dgcd ),uint32 (_cee ),_aebb ._cce );if _gbd !=nil {return _gbd ;};_bace .Stream ,_gbd =_aebb .decryptBytes (_bace .Stream ,_babf ,_bbd );if _gbd !=nil {return _gbd ;};_gef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bace .Stream ))));return nil ;case *PdfObjectString :_bc .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dfg :=_ecab ;if _aebb ._bbfc .V >=4{_bc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aebb ._gac );if _aebb ._gac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dfg =_aebb ._gac ;};_cfd ,_fedg :=_aebb .makeKey (_dfg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aebb ._cce );if _fedg !=nil {return _fedg ;};_begc :=_bace .Str ();_ead :=make ([]byte ,len (_begc ));for _face :=0;_face < len (_begc );_face ++{_ead [_face ]=_begc [_face ];};_bc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ead ,_ead );_ead ,_fedg =_aebb .decryptBytes (_ead ,_dfg ,_cfd );if _fedg !=nil {return _fedg ;};_bace ._gafc =string (_ead );return nil ;case *PdfObjectArray :for _ ,_bbbe :=range _bace .Elements (){_cdf :=_aebb .Decrypt (_bbbe ,parentObjNum ,parentGenNum );if _cdf !=nil {return _cdf ;};};return nil ;case *PdfObjectDictionary :_gad :=false ;if _ddb :=_bace .Get ("\u0054\u0079\u0070\u0065");_ddb !=nil {_cff ,_bea :=_ddb .(*PdfObjectName );if _bea &&*_cff =="\u0053\u0069\u0067"{_gad =true ;};};for _ ,_cda :=range _bace .Keys (){_feg :=_bace .Get (_cda );if _gad &&string (_cda )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_cda )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_cda )!="\u0050\u0072\u0065\u0076"&&string (_cda )!="\u004c\u0061\u0073\u0074"{_fcf :=_aebb .Decrypt (_feg ,parentObjNum ,parentGenNum );if _fcf !=nil {return _fcf ;};};};return nil ;};return nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_cgde *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gdbac :=encoded ;var _ceec error ;for _ ,_dabd :=range _cgde ._beb {_bc .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_dabd ,_dabd );_gdbac ,_ceec =_dabd .DecodeBytes (_gdbac );if _ceec !=nil {return nil ,_ceec ;};};return _gdbac ,nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_fed *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_bc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _fed .LookupByNumber (int (ref .ObjectNumber ));};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ccfea *PdfObjectString )Bytes ()[]byte {return []byte (_ccfea ._gafc )};func (_gbbg *PdfParser )skipSpaces ()(int ,error ){_ffdd :=0;for {_ggeg ,_ccgd :=_gbbg ._dcada .ReadByte ();if _ccgd !=nil {return 0,_ccgd ;};if IsWhiteSpace (_ggeg ){_ffdd ++;}else {_gbbg ._dcada .UnreadByte ();break ;};};return _ffdd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gfaf *PdfObjectName )WriteString ()string {var _ebbg _fce .Buffer ;if len (*_gfaf )> 127{_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_gfaf );};_ebbg .WriteString ("\u002f");for _cdbb :=0;_cdbb < len (*_gfaf );_cdbb ++{_cfdef :=(*_gfaf )[_cdbb ];if !IsPrintable (_cfdef )||_cfdef =='#'||IsDelimiter (_cfdef ){_ebbg .WriteString (_ccd .Sprintf ("\u0023\u0025\u002e2\u0078",_cfdef ));}else {_ebbg .WriteByte (_cfdef );};};return _ebbg .String ();};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_eage Version )String ()string {return _ccd .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_eage .Major ,_eage .Minor );};func (_edf *PdfCrypt )securityHandler ()_fb .StdHandler {if _edf ._bbe .R >=5{return _fb .NewHandlerR6 ();};return _fb .NewHandlerR4 (_edf ._gae ,_edf ._bbfc .Length );};func (_ggadc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _fded *PdfObjectDictionary ;_ggcb ,_deea :=_ggadc .readTextLine ();if _deea !=nil {return nil ,_deea ;};_bc .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_ggcb );_gggb :=-1;_fgdd :=0;_ebda :=false ;_eadfc :="";for {_ggadc .skipSpaces ();_ ,_bbdef :=_ggadc ._dcada .Peek (1);if _bbdef !=nil {return nil ,_bbdef ;};_ggcb ,_bbdef =_ggadc .readTextLine ();if _bbdef !=nil {return nil ,_bbdef ;};_ffcc :=_ffbdf .FindStringSubmatch (_ggcb );if len (_ffcc )==0{_cdfg :=len (_eadfc )> 0;_eadfc +=_ggcb +"\u000a";if _cdfg {_ffcc =_ffbdf .FindStringSubmatch (_eadfc );};};if len (_ffcc )==3{_gdgf ,_ :=_b .Atoi (_ffcc [1]);_fade ,_ :=_b .Atoi (_ffcc [2]);_gggb =_gdgf ;_fgdd =_fade ;_ebda =true ;_eadfc ="";_bc .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gggb ,_fgdd );continue ;};_cggcg :=_afgcb .FindStringSubmatch (_ggcb );if len (_cggcg )==4{if !_ebda {_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_ab .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_dcfg ,_ :=_b .ParseInt (_cggcg [1],10,64);_bdbb ,_ :=_b .Atoi (_cggcg [2]);_aeeg :=_cggcg [3];_eadfc ="";if _dc .ToLower (_aeeg )=="\u006e"&&_dcfg > 1{_cfbb ,_cbab :=_ggadc ._cgbd .ObjectMap [_gggb ];if !_cbab ||_bdbb > _cfbb .Generation {_dacgf :=XrefObject {ObjectNumber :_gggb ,XType :XrefTypeTableEntry ,Offset :_dcfg ,Generation :_bdbb };_ggadc ._cgbd .ObjectMap [_gggb ]=_dacgf ;};};_gggb ++;continue ;};if (len (_ggcb )> 6)&&(_ggcb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_bc .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_ggcb );if len (_ggcb )> 9{_ceda :=_ggadc .GetFileOffset ();_ggadc .SetFileOffset (_ceda -int64 (len (_ggcb ))+7);};_ggadc .skipSpaces ();_ggadc .skipComments ();_bc .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_bc .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_ggcb );_fded ,_bbdef =_ggadc .ParseDict ();_bc .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bbdef !=nil {_bc .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bbdef );return nil ,_bbdef ;};break ;};if _ggcb =="\u0025\u0025\u0045O\u0046"{_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_ab .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_bc .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_ggcb );};_bc .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _ggadc ._gdag ==nil {_dbddc :=XrefTypeTableEntry ;_ggadc ._gdag =&_dbddc ;};return _fded ,nil ;};var _becg =_g .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func (_facd *PdfParser )repairLocateXref ()(int64 ,error ){_ffbdg :=int64 (1000);_facd ._geaf .Seek (-_ffbdg ,_bg .SeekCurrent );_gebg ,_dfca :=_facd ._geaf .Seek (0,_bg .SeekCurrent );if _dfca !=nil {return 0,_dfca ;};_cgaf :=make ([]byte ,_ffbdg );_facd ._geaf .Read (_cgaf );_aadad :=_becg .FindAllStringIndex (string (_cgaf ),-1);if len (_aadad )< 1{_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_ab .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_cabc :=int64 (_aadad [len (_aadad )-1][0]);_eafe :=_gebg +_cabc ;return _eafe ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_egef *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddda :=MakeDict ();_ddda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_egef .GetFilterArray ());for _ ,_afda :=range _egef ._beb {_accf :=_afda .MakeStreamDict ();for _ ,_dccf :=range _accf .Keys (){_agbd :=_accf .Get (_dccf );if _dccf !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_dccf !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_ddda .Set (_dccf ,_agbd );};};};_gfgb :=_egef .MakeDecodeParams ();if _gfgb !=nil {_ddda .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfgb );};return _ddda ;};

// UpdateParams updates the parameter values of the encoder.
func (_caa *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dfab ,_aae :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _aae ==nil {_caa .ColorComponents =int (_dfab );};_gcb ,_aae :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _aae ==nil {_caa .BitsPerComponent =int (_gcb );};_fde ,_aae :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _aae ==nil {_caa .Width =int (_fde );};_bfd ,_aae :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _aae ==nil {_caa .Height =int (_bfd );};_gcbc ,_aae :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _aae ==nil {_caa .Quality =int (_gcbc );};};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fagf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ggdg []float64 ;for _ ,_gcee :=range _fagf .Elements (){switch _efefd :=_gcee .(type ){case *PdfObjectInteger :_ggdg =append (_ggdg ,float64 (*_efefd ));case *PdfObjectFloat :_ggdg =append (_ggdg ,float64 (*_efefd ));default:return nil ,ErrTypeError ;};};return _ggdg ,nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_df []XrefObject ;};func _fca (_gfd PdfObject )(int64 ,int64 ,error ){if _ecb ,_faf :=_gfd .(*PdfIndirectObject );_faf {return _ecb .ObjectNumber ,_ecb .GenerationNumber ,nil ;};if _fe ,_gcd :=_gfd .(*PdfObjectStream );_gcd {return _fe .ObjectNumber ,_fe .GenerationNumber ,nil ;};return 0,0,_ab .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// String returns a string describing `array`.
func (_bfef *PdfObjectArray )String ()string {_egda :="\u005b";for _bfga ,_cece :=range _bfef .Elements (){_egda +=_cece .String ();if _bfga < (_bfef .Len ()-1){_egda +="\u002c\u0020";};};_egda +="\u005d";return _egda ;};func (_ccdba *PdfParser )traceStreamLength (_ddab PdfObject )(PdfObject ,error ){_cbec ,_edgf :=_ddab .(*PdfObjectReference );if _edgf {_cdae ,_agaf :=_ccdba ._egcd [_cbec .ObjectNumber ];if _agaf &&_cdae {_bc .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_ab .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_ccdba ._egcd [_cbec .ObjectNumber ]=true ;};_dbgb ,_eebb :=_ccdba .Resolve (_ddab );if _eebb !=nil {return nil ,_eebb ;};_bc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dbgb );if _edgf {_ccdba ._egcd [_cbec .ObjectNumber ]=false ;};return _dbgb ,nil ;};func (_gb *PdfParser )lookupByNumber (_fff int ,_egb bool )(PdfObject ,bool ,error ){_agf ,_dgce :=_gb .ObjCache [_fff ];if _dgce {_bc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fff );return _agf ,false ,nil ;};if _gb ._dbf ==nil {_gb ._dbf =map[int ]bool {};};if _gb ._dbf [_fff ]{_bc .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_fff );return nil ,false ,_ab .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_gb ._dbf [_fff ]=true ;defer delete (_gb ._dbf ,_fff );_bcfa ,_dgce :=_gb ._cgbd .ObjectMap [_fff ];if !_dgce {_bc .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _abc PdfObjectNull ;return &_abc ,false ,nil ;};_bc .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fff );if _bcfa .XType ==XrefTypeTableEntry {_bc .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_bcfa .ObjectNumber );_bc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_bcfa .Generation );_bc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_bcfa .Offset );_gb ._geaf .Seek (_bcfa .Offset ,_bg .SeekStart );_gb ._dcada =_db .NewReader (_gb ._geaf );_ea ,_cdg :=_gb .ParseIndirectObject ();if _cdg !=nil {_bc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cdg );if _egb {_bc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_fga ,_cdd :=_gb .repairRebuildXrefsTopDown ();if _cdd !=nil {_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_cdd );return nil ,false ,_cdd ;};_gb ._cgbd =*_fga ;return _gb .lookupByNumber (_fff ,false );};return nil ,false ,_cdg ;};if _egb {_af ,_ ,_ :=_fca (_ea );if int (_af )!=_fff {_bc .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_aa :=_gb .rebuildXrefTable ();if _aa !=nil {return nil ,false ,_aa ;};_gb .ObjCache =objectCache {};return _gb .lookupByNumberWrapper (_fff ,false );};};_bc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_gb .ObjCache [_fff ]=_ea ;return _ea ,false ,nil ;}else if _bcfa .XType ==XrefTypeObjectStream {_bc .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_bc .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_bc .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_bcfa .OsObjNumber ,_bcfa .OsObjIndex );if _bcfa .OsObjNumber ==_fff {_bc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_ab .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_egd :=_gb ._cgbd .ObjectMap [_bcfa .OsObjNumber ];_egd {_fea ,_fbd :=_gb .lookupObjectViaOS (_bcfa .OsObjNumber ,_fff );if _fbd !=nil {_bc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fbd );return nil ,true ,_fbd ;};_bc .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_gb .ObjCache [_fff ]=_fea ;if _gb ._abbbc !=nil {_gb ._abbbc ._afg [_fea ]=true ;};return _fea ,true ,nil ;};_bc .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_ab .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_ab .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func _bdb (_fgdb *PdfObjectStream ,_ecg *MultiEncoder )(*DCTEncoder ,error ){_febg :=NewDCTEncoder ();_bce :=_fgdb .PdfObjectDictionary ;if _bce ==nil {return _febg ,nil ;};_bgcg :=_fgdb .Stream ;if _ecg !=nil {_ebfd ,_gaca :=_ecg .DecodeBytes (_bgcg );if _gaca !=nil {return nil ,_gaca ;};_bgcg =_ebfd ;};_dbb :=_fce .NewReader (_bgcg );_ebab ,_befb :=_c .DecodeConfig (_dbb );if _befb !=nil {_bc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_befb );return nil ,_befb ;};switch _ebab .ColorModel {case _ga .RGBAModel :_febg .BitsPerComponent =8;_febg .ColorComponents =3;case _ga .RGBA64Model :_febg .BitsPerComponent =16;_febg .ColorComponents =3;case _ga .GrayModel :_febg .BitsPerComponent =8;_febg .ColorComponents =1;case _ga .Gray16Model :_febg .BitsPerComponent =16;_febg .ColorComponents =1;case _ga .CMYKModel :_febg .BitsPerComponent =8;_febg .ColorComponents =4;case _ga .YCbCrModel :_febg .BitsPerComponent =8;_febg .ColorComponents =3;default:return nil ,_ab .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_febg .Width =_ebab .Width ;_febg .Height =_ebab .Height ;_bc .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_febg );_febg .Quality =DefaultJPEGQuality ;return _febg ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};func _bbegg ()string {return _bc .Version };func (_ced *PdfCrypt )encryptBytes (_dagc []byte ,_bbc string ,_bfeg []byte )([]byte ,error ){_bc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_dfd ,_eac :=_ced ._ege [_bbc ];if !_eac {return nil ,_ccd .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bbc );};return _dfd .EncryptBytes (_dagc ,_bfeg );};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_eeg Version ;_geaf _bg .ReadSeeker ;_dcada *_db .Reader ;_bdgd int64 ;_cgbd XrefTable ;_gdbd int64 ;_gdag *xrefType ;_cfcg objectStreams ;_dccd *PdfObjectDictionary ;_abbbc *PdfCrypt ;_acegg bool ;ObjCache objectCache ;_dbf map[int ]bool ;_egcd map[int64 ]bool ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_dfdc *PdfObjectStreams )Elements ()[]PdfObject {if _dfdc ==nil {return nil ;};return _dfdc ._edad ;};

// WriteString outputs the object as it is to be written to file.
func (_gcdg *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func _dbgf (_ddbeb ,_gacba ,_ccaa int )error {if _gacba < 0||_gacba > _ddbeb {return _ab .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _ccaa < _gacba {return _ab .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _ccaa > _ddbeb {return _ab .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};func (_gdcf *PdfParser )parsePdfVersion ()(int ,int ,error ){var _ebdcb int64 =20;_fdgg :=make ([]byte ,_ebdcb );_gdcf ._geaf .Seek (0,_bg .SeekStart );_gdcf ._geaf .Read (_fdgg );var _fegd error ;var _bgcef ,_agegg int ;if _caad :=_eec .FindStringSubmatch (string (_fdgg ));len (_caad )< 3{if _bgcef ,_agegg ,_fegd =_gdcf .seekPdfVersionTopDown ();_fegd !=nil {_bc .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_fegd ;};_gdcf ._geaf ,_fegd =_bffe (_gdcf ._geaf ,_gdcf .GetFileOffset ()-8);if _fegd !=nil {return 0,0,_fegd ;};}else {if _bgcef ,_fegd =_b .Atoi (_caad [1]);_fegd !=nil {return 0,0,_fegd ;};if _agegg ,_fegd =_b .Atoi (_caad [2]);_fegd !=nil {return 0,0,_fegd ;};_gdcf .SetFileOffset (0);};_gdcf ._dcada =_db .NewReader (_gdcf ._geaf );_bc .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_bgcef ,_agegg );return _bgcef ,_agegg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aacd *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func _dgee (_acag string )(PdfObjectReference ,error ){_cbd :=PdfObjectReference {};_adad :=_eaaea .FindStringSubmatch (_acag );if len (_adad )< 3{_bc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _cbd ,_ab .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_aabe ,_ :=_b .Atoi (_adad [1]);_cacc ,_ :=_b .Atoi (_adad [2]);_cbd .ObjectNumber =int64 (_aabe );_cbd .GenerationNumber =int64 (_cacc );return _cbd ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_edea JBIG2EncoderSettings )Validate ()error {const _dgdb ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _edea .Threshold < 0||_edea .Threshold > 1.0{return _de .Errorf (_dgdb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_edea .Threshold );};if _edea .ResolutionX < 0{return _de .Errorf (_dgdb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_edea .ResolutionX );};if _edea .ResolutionY < 0{return _de .Errorf (_dgdb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_edea .ResolutionY );};if _edea .DefaultPixelValue !=0&&_edea .DefaultPixelValue !=1{return _de .Errorf (_dgdb ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_edea .DefaultPixelValue );};if _edea .Compression !=JB2Generic {return _de .Errorf (_dgdb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};func (_efade *PdfParser )repairSeekXrefMarker ()error {_edcg ,_eeagg :=_efade ._geaf .Seek (0,_bg .SeekEnd );if _eeagg !=nil {return _eeagg ;};_ffab :=_g .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _fgaa int64 ;var _dcdaa int64 =1000;for _fgaa < _edcg {if _edcg <=(_dcdaa +_fgaa ){_dcdaa =_edcg -_fgaa ;};_ ,_gfabcd :=_efade ._geaf .Seek (-_fgaa -_dcdaa ,_bg .SeekEnd );if _gfabcd !=nil {return _gfabcd ;};_dcgd :=make ([]byte ,_dcdaa );_efade ._geaf .Read (_dcgd );_bc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_dcgd ));_dbbd :=_ffab .FindAllStringIndex (string (_dcgd ),-1);if _dbbd !=nil {_cgaca :=_dbbd [len (_dbbd )-1];_bc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dbbd );_efade ._geaf .Seek (-_fgaa -_dcdaa +int64 (_cgaca [0]),_bg .SeekEnd );_efade ._dcada =_db .NewReader (_efade ._geaf );for {_defc ,_gdege :=_efade ._dcada .Peek (1);if _gdege !=nil {return _gdege ;};_bc .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_defc [0],_defc [0]);if !IsWhiteSpace (_defc [0]){break ;};_efade ._dcada .Discard (1);};return nil ;};_bc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_fgaa +=_dcdaa ;};_bc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _ab .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_cdac :=&ASCII85Encoder {};return _cdac };