//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_da "bufio";_ed "bytes";_abe "compress/lzw";_fc "compress/zlib";_aa "crypto/md5";_ee "crypto/rand";_cd "encoding/hex";_g "errors";_dca "fmt";_cb "github.com/unidoc/unipdf/v3/common";_af "github.com/unidoc/unipdf/v3/core/security";
_ad "github.com/unidoc/unipdf/v3/core/security/crypt";_b "github.com/unidoc/unipdf/v3/internal/ccittfax";_eg "github.com/unidoc/unipdf/v3/internal/imageutil";_dea "github.com/unidoc/unipdf/v3/internal/jbig2";_cde "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_edf "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_db "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ace "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ggf "github.com/unidoc/unipdf/v3/internal/strutils";_dab "golang.org/x/image/tiff/lzw";
_fca "golang.org/x/xerrors";_c "image";_dc "image/color";_ab "image/jpeg";_de "io";_fd "io/ioutil";_gc "reflect";_ec "regexp";_gg "sort";_f "strconv";_gcd "strings";_e "sync";_ac "time";_d "unicode";);

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _beega _ed .Buffer ;_beega .Write ([]byte {0xFE,0xFF});_beega .WriteString (_ggf .StringToUTF16 (s ));return &PdfObjectString {_fdgged :_beega .String (),_bggf :true };};
return &PdfObjectString {_fdgged :string (_ggf .StringToPDFDocEncoding (s )),_bggf :false };};func _cdefe (_effbf string )(int ,int ,error ){_cegc :=_cfff .FindStringSubmatch (_effbf );if len (_cegc )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ggfed ,_ :=_f .Atoi (_cegc [1]);_ecff ,_ :=_f .Atoi (_cegc [2]);return _ggfed ,_ecff ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_cdged *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_dgb :=MakeDict ();_dgb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cdged .GetFilterName ()));return _dgb ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcca *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_fcca ._dbeg )==0{return nil ;};if len (_fcca ._dbeg )==1{return _fcca ._dbeg [0].MakeDecodeParams ();};_ffgb :=MakeArray ();_gbde :=true ;for _ ,_dbde :=range _fcca ._dbeg {_dbec :=_dbde .MakeDecodeParams ();
if _dbec ==nil {_ffgb .Append (MakeNull ());}else {_gbde =false ;_ffgb .Append (_dbec );};};if _gbde {return nil ;};return _ffgb ;};func _abd (_bcf uint ,_fggc ,_aafee float64 )float64 {return (_fggc +(float64 (_bcf )*(_aafee -_fggc )/255))*255;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_gece *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_gece ._ecgd .Seek (offset ,_de .SeekStart );_gece ._gega =_da .NewReader (_gece ._ecgd );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_cfge :=&DCTEncoder {};_cfge .ColorComponents =3;_cfge .BitsPerComponent =8;_cfge .Quality =DefaultJPEGQuality ;_cfge .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};return _cfge ;};func (_fdf *PdfParser )lookupObjectViaOS (_adf int ,_eb int )(PdfObject ,error ){var _ggc *_ed .Reader ;
var _cbg objectStream ;var _cdb bool ;_cbg ,_cdb =_fdf ._aeab [_adf ];if !_cdb {_fb ,_dbf :=_fdf .LookupByNumber (_adf );if _dbf !=nil {_cb .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_adf );
return nil ,_dbf ;};_ga ,_df :=_fb .(*PdfObjectStream );if !_df {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _fdf ._agf !=nil &&!_fdf ._agf .isDecrypted (_ga ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_bd :=_ga .PdfObjectDictionary ;_cb .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bd .String ());_bf ,_df :=_bd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_df {_cb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gcd .ToLower (string (*_bf ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_df :=_bd .Get ("\u004e").(*PdfObjectInteger );if !_df {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_ag ,_df :=_bd .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_df {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_cb .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_bf ,*N );_ce ,_dbf :=DecodeStream (_ga );if _dbf !=nil {return nil ,_dbf ;
};_cb .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ce );_aaf :=_fdf .GetFileOffset ();defer func (){_fdf .SetFileOffset (_aaf )}();_ggc =_ed .NewReader (_ce );_fdf ._gega =_da .NewReader (_ggc );_cb .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_age :=map[int ]int64 {};for _gga :=0;_gga < int (*N );_gga ++{_fdf .skipSpaces ();_ea ,_ebd :=_fdf .parseNumber ();if _ebd !=nil {return nil ,_ebd ;};_adc ,_aae :=_ea .(*PdfObjectInteger );if !_aae {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fdf .skipSpaces ();_ea ,_ebd =_fdf .parseNumber ();if _ebd !=nil {return nil ,_ebd ;};_eae ,_aae :=_ea .(*PdfObjectInteger );if !_aae {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cb .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_adc ,*_eae );_age [int (*_adc )]=int64 (*_ag +*_eae );};_cbg =objectStream {N :int (*N ),_abc :_ce ,_dd :_age };_fdf ._aeab [_adf ]=_cbg ;}else {_gd :=_fdf .GetFileOffset ();
defer func (){_fdf .SetFileOffset (_gd )}();_ggc =_ed .NewReader (_cbg ._abc );_fdf ._gega =_da .NewReader (_ggc );};_cf :=_cbg ._dd [_eb ];_cb .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_eb ,_cf );
_ggc .Seek (_cf ,_de .SeekStart );_fdf ._gega =_da .NewReader (_ggc );_cdg ,_ :=_fdf ._gega .Peek (100);_cb .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cdg ));_ade ,_bdc :=_fdf .parseObject ();
if _bdc !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bdc );return nil ,_bdc ;};if _ade ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_bb :=PdfIndirectObject {};_bb .ObjectNumber =int64 (_eb );_bb .PdfObject =_ade ;_bb ._fdbeb =_fdf ;return &_bb ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_gcfb *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_adcc :=_ed .NewReader (data );var _ddd []byte ;var _fge []byte ;_feef ,_aca :=_adcc .ReadByte ();if _aca ==_de .EOF {return []byte {},nil ;}else if _aca !=nil {return nil ,_aca ;
};_deac :=1;for {_aafd ,_ccee :=_adcc .ReadByte ();if _ccee ==_de .EOF {break ;}else if _ccee !=nil {return nil ,_ccee ;};if _aafd ==_feef {if len (_fge )> 0{_fge =_fge [:len (_fge )-1];if len (_fge )> 0{_ddd =append (_ddd ,byte (len (_fge )-1));_ddd =append (_ddd ,_fge ...);
};_deac =1;_fge =[]byte {};};_deac ++;if _deac >=127{_ddd =append (_ddd ,byte (257-_deac ),_feef );_deac =0;};}else {if _deac > 0{if _deac ==1{_fge =[]byte {_feef };}else {_ddd =append (_ddd ,byte (257-_deac ),_feef );};_deac =0;};_fge =append (_fge ,_aafd );
if len (_fge )>=127{_ddd =append (_ddd ,byte (len (_fge )-1));_ddd =append (_ddd ,_fge ...);_fge =[]byte {};};};_feef =_aafd ;};if len (_fge )> 0{_ddd =append (_ddd ,byte (len (_fge )-1));_ddd =append (_ddd ,_fge ...);}else if _deac > 0{_ddd =append (_ddd ,byte (257-_deac ),_feef );
};_ddd =append (_ddd ,128);return _ddd ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fcdb *PdfParser )GetFileOffset ()int64 {_fbbe ,_ :=_fcdb ._ecgd .Seek (0,_de .SeekCurrent );_fbbe -=int64 (_fcdb ._gega .Buffered ());return _fbbe ;};func (_ddgc *PdfCrypt )decryptBytes (_ede []byte ,_caea string ,_ccg []byte )([]byte ,error ){_cb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_bfbc ,_egb :=_ddgc ._eede [_caea ];if !_egb {return nil ,_dca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_caea );};return _bfbc .DecryptBytes (_ede ,_ccg );};

// String returns a string describing `d`.
func (_ebce *PdfObjectDictionary )String ()string {var _eefe _gcd .Builder ;_eefe .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_cedf :=range _ebce ._edaeb {_aaace :=_ebce ._cgaag [_cedf ];_eefe .WriteString ("\u0022"+_cedf .String ()+"\u0022\u003a\u0020");
_eefe .WriteString (_aaace .String ());_eefe .WriteString ("\u002c\u0020");};_eefe .WriteString ("\u0029");return _eefe .String ();};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// WriteString outputs the object as it is to be written to file.
func (_fdfcg *PdfObjectReference )WriteString ()string {var _ecbd _gcd .Builder ;_ecbd .WriteString (_f .FormatInt (_fdfcg .ObjectNumber ,10));_ecbd .WriteString ("\u0020");_ecbd .WriteString (_f .FormatInt (_fdfcg .GenerationNumber ,10));_ecbd .WriteString ("\u0020\u0052");
return _ecbd .String ();};func (_eged *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dbbd *PdfObjectDictionary ;_dfcf ,_gaca :=_eged .readTextLine ();if _gaca !=nil {return nil ,_gaca ;};if _eged ._bgda &&_gcd .Count (_gcd .TrimPrefix (_dfcf ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_eged ._dbcb ._fgdc =true ;
};_cb .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dfcf );_fddb :=-1;_bfgd :=0;_bgab :=false ;_afbb :="";for {_eged .skipSpaces ();_ ,_becaf :=_eged ._gega .Peek (1);if _becaf !=nil {return nil ,_becaf ;
};_dfcf ,_becaf =_eged .readTextLine ();if _becaf !=nil {return nil ,_becaf ;};_adfcd :=_gdceg .FindStringSubmatch (_dfcf );if len (_adfcd )==0{_fgfa :=len (_afbb )> 0;_afbb +=_dfcf +"\u000a";if _fgfa {_adfcd =_gdceg .FindStringSubmatch (_afbb );};};if len (_adfcd )==3{if _eged ._bgda &&!_eged ._dbcb ._dcag {var (_becg bool ;
_gbfc int ;);for _ ,_ccaa :=range _dfcf {if _d .IsDigit (_ccaa ){if _becg {break ;};continue ;};if !_becg {_becg =true ;};_gbfc ++;};if _gbfc > 1{_eged ._dbcb ._dcag =true ;};};_ebca ,_ :=_f .Atoi (_adfcd [1]);_ebcae ,_ :=_f .Atoi (_adfcd [2]);_fddb =_ebca ;
_bfgd =_ebcae ;_bgab =true ;_afbb ="";_cb .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fddb ,_bfgd );
continue ;};_dfcc :=_bbff .FindStringSubmatch (_dfcf );if len (_dfcc )==4{if !_bgab {_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_fcbf ,_ :=_f .ParseInt (_dfcc [1],10,64);_cagc ,_ :=_f .Atoi (_dfcc [2]);_efgbga :=_dfcc [3];_afbb ="";if _gcd .ToLower (_efgbga )=="\u006e"&&_fcbf > 1{_cfeaf ,_ddfd :=_eged ._fffef .ObjectMap [_fddb ];if !_ddfd ||_cagc > _cfeaf .Generation {_edba :=XrefObject {ObjectNumber :_fddb ,XType :XrefTypeTableEntry ,Offset :_fcbf ,Generation :_cagc };
_eged ._fffef .ObjectMap [_fddb ]=_edba ;};};_fddb ++;continue ;};if (len (_dfcf )> 6)&&(_dfcf [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_cb .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_dfcf );
if len (_dfcf )> 9{_fbfbd :=_eged .GetFileOffset ();_eged .SetFileOffset (_fbfbd -int64 (len (_dfcf ))+7);};_eged .skipSpaces ();_eged .skipComments ();_cb .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_cb .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_dfcf );_dbbd ,_becaf =_eged .ParseDict ();_cb .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _becaf !=nil {_cb .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_becaf );return nil ,_becaf ;};break ;};if _dfcf =="\u0025\u0025\u0045O\u0046"{_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_cb .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_dfcf );
};_cb .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _eged ._cacf ==nil {_gcbe :=XrefTypeTableEntry ;_eged ._cacf =&_gcbe ;};return _dbbd ,nil ;};func (_adg *PdfCrypt )securityHandler ()_af .StdHandler {if _adg ._ebb .R >=5{return _af .NewHandlerR6 ();
};return _af .NewHandlerR4 (_adg ._eaeg ,_adg ._dce .Length );};func (_daf *PdfParser )lookupByNumberWrapper (_dfe int ,_cg bool )(PdfObject ,bool ,error ){_dg ,_eaea ,_efd :=_daf .lookupByNumber (_dfe ,_cg );if _efd !=nil {return nil ,_eaea ,_efd ;};if !_eaea &&_daf ._agf !=nil &&_daf ._agf ._cba &&!_daf ._agf .isDecrypted (_dg ){_fbb :=_daf ._agf .Decrypt (_dg ,0,0);
if _fbb !=nil {return nil ,_eaea ,_fbb ;};};return _dg ,_eaea ,nil ;};var _bbff =_ec .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_dabc int ;_acc bool ;_aafg [4]byte ;_cfd bool ;_ceda bool ;_bbe bool ;_eea bool ;_dcag bool ;_fgdc bool ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_ebdc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cfbf :=range another .Keys (){_fbcab :=another .Get (_cfbf );_ebdc .Set (_cfbf ,_fbcab );};};return _ebdc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bddd *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_fcae *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_eagb :=_fcae ._bbfb ;if _eagb ==revisionNumber {return _fcae ,nil ;};if _eagb < revisionNumber {return nil ,_g .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _fcae ._bcga [revisionNumber ]!=nil {return _fcae ._bcga [revisionNumber ],nil ;};_fadc :=_fcae ;for ;_eagb > revisionNumber ;_eagb --{_ffaf ,_egfdd :=_fadc .GetPreviousRevisionParser ();if _egfdd !=nil {return nil ,_egfdd ;};_fcae ._bcga [_eagb -1]=_ffaf ;
_fcae ._gcgb [_fadc ]=_ffaf ;_fadc =_ffaf ;};return _fadc ,nil ;};type cryptFilters map[string ]_ad .Filter ;

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ge []XrefObject ;};const _cfeg ="\u0053\u0074\u0064C\u0046";func (_ebbd *PdfParser )checkPostEOFData ()error {const _agag ="\u0025\u0025\u0045O\u0046";_ ,_gef :=_ebbd ._ecgd .Seek (-int64 (len ([]byte (_agag )))-1,_de .SeekEnd );
if _gef !=nil {return _gef ;};_adfc :=make ([]byte ,len ([]byte (_agag ))+1);_ ,_gef =_ebbd ._ecgd .Read (_adfc );if _gef !=nil {if _gef !=_de .EOF {return _gef ;};};if string (_adfc )==_agag ||string (_adfc )==_agag +"\u000a"{_ebbd ._dbcb ._cfd =true ;
};return nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gfgf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _caga []float64 ;for _ ,_bgee :=range _gfgf .Elements (){switch _cgafc :=_bgee .(type ){case *PdfObjectInteger :_caga =append (_caga ,float64 (*_cgafc ));case *PdfObjectFloat :_caga =append (_caga ,float64 (*_cgafc ));
default:return nil ,ErrTypeError ;};};return _caga ,nil ;};func (_bccg *JBIG2Image )toBitmap ()(_bfdf *_cde .Bitmap ,_afb error ){const _fgffe ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _bccg .Data ==nil {return nil ,_ace .Error (_fgffe ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _bccg .Width ==0||_bccg .Height ==0{return nil ,_ace .Error (_fgffe ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _bccg .HasPadding {_bfdf ,_afb =_cde .NewWithData (_bccg .Width ,_bccg .Height ,_bccg .Data );}else {_bfdf ,_afb =_cde .NewWithUnpaddedData (_bccg .Width ,_bccg .Height ,_bccg .Data );};if _afb !=nil {return nil ,_ace .Wrap (_afb ,_fgffe ,"");};return _bfdf ,nil ;
};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dcad Version ;_ecgd _de .ReadSeeker ;_gega *_da .Reader ;_baeb int64 ;_fffef XrefTable ;_gdcf int64 ;_cacf *xrefType ;_aeab objectStreams ;_bga *PdfObjectDictionary ;_agf *PdfCrypt ;_ffdg *PdfIndirectObject ;_ccdb bool ;ObjCache objectCache ;
_dafe map[int ]bool ;_ccbe map[int64 ]bool ;_dbcb ParserMetadata ;_bgda bool ;_aadfg []int64 ;_bbfb int ;_aaec bool ;_gacf int64 ;_gcgb map[*PdfParser ]*PdfParser ;_bcga []*PdfParser ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_cbbb *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcg :=_ed .NewReader (encoded );_agab ,_gabg :=_ab .Decode (_gcg );if _gabg !=nil {_cb .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gabg );
return nil ,_gabg ;};_bbcfg :=_agab .Bounds ();var _dgaf =make ([]byte ,_bbcfg .Dx ()*_bbcfg .Dy ()*_cbbb .ColorComponents *_cbbb .BitsPerComponent /8);_fgffd :=0;switch _cbbb .ColorComponents {case 1:_bef :=[]float64 {_cbbb .Decode [0],_cbbb .Decode [1]};
for _cbbg :=_bbcfg .Min .Y ;_cbbg < _bbcfg .Max .Y ;_cbbg ++{for _bbca :=_bbcfg .Min .X ;_bbca < _bbcfg .Max .X ;_bbca ++{_deba :=_agab .At (_bbca ,_cbbg );if _cbbb .BitsPerComponent ==16{_ageg ,_ffgff :=_deba .(_dc .Gray16 );if !_ffgff {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_eba :=_abd (uint (_ageg .Y >>8),_bef [0],_bef [1]);_gcca :=_abd (uint (_ageg .Y ),_bef [0],_bef [1]);_dgaf [_fgffd ]=byte (_eba );_fgffd ++;_dgaf [_fgffd ]=byte (_gcca );_fgffd ++;}else {_fdaf ,_abeb :=_deba .(_dc .Gray );if !_abeb {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dgaf [_fgffd ]=byte (_abd (uint (_fdaf .Y ),_bef [0],_bef [1]));_fgffd ++;};};};case 3:_dbda :=[]float64 {_cbbb .Decode [0],_cbbb .Decode [1]};_adaf :=[]float64 {_cbbb .Decode [2],_cbbb .Decode [3]};_gfdg :=[]float64 {_cbbb .Decode [4],_cbbb .Decode [5]};
for _ebde :=_bbcfg .Min .Y ;_ebde < _bbcfg .Max .Y ;_ebde ++{for _fcc :=_bbcfg .Min .X ;_fcc < _bbcfg .Max .X ;_fcc ++{_acdg :=_agab .At (_fcc ,_ebde );if _cbbb .BitsPerComponent ==16{_gdb ,_cbea :=_acdg .(_dc .RGBA64 );if !_cbea {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_effd :=_abd (uint (_gdb .R >>8),_dbda [0],_dbda [1]);_dbge :=_abd (uint (_gdb .R ),_dbda [0],_dbda [1]);_gcda :=_abd (uint (_gdb .G >>8),_adaf [0],_adaf [1]);_ageb :=_abd (uint (_gdb .G ),_adaf [0],_adaf [1]);_bfff :=_abd (uint (_gdb .B >>8),_gfdg [0],_gfdg [1]);
_ggea :=_abd (uint (_gdb .B ),_gfdg [0],_gfdg [1]);_dgaf [_fgffd ]=byte (_effd );_fgffd ++;_dgaf [_fgffd ]=byte (_dbge );_fgffd ++;_dgaf [_fgffd ]=byte (_gcda );_fgffd ++;_dgaf [_fgffd ]=byte (_ageb );_fgffd ++;_dgaf [_fgffd ]=byte (_bfff );_fgffd ++;_dgaf [_fgffd ]=byte (_ggea );
_fgffd ++;}else {_dcbc ,_fbcb :=_acdg .(_dc .RGBA );if _fbcb {_ceed :=_abd (uint (_dcbc .R ),_dbda [0],_dbda [1]);_dcde :=_abd (uint (_dcbc .G ),_adaf [0],_adaf [1]);_fcbce :=_abd (uint (_dcbc .B ),_gfdg [0],_gfdg [1]);_dgaf [_fgffd ]=byte (_ceed );_fgffd ++;
_dgaf [_fgffd ]=byte (_dcde );_fgffd ++;_dgaf [_fgffd ]=byte (_fcbce );_fgffd ++;}else {_eggc ,_ceefd :=_acdg .(_dc .YCbCr );if !_ceefd {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fadb ,_bgff ,_dabe ,_ :=_eggc .RGBA ();
_bbac :=_abd (uint (_fadb >>8),_dbda [0],_dbda [1]);_edeaa :=_abd (uint (_bgff >>8),_adaf [0],_adaf [1]);_afdb :=_abd (uint (_dabe >>8),_gfdg [0],_gfdg [1]);_dgaf [_fgffd ]=byte (_bbac );_fgffd ++;_dgaf [_fgffd ]=byte (_edeaa );_fgffd ++;_dgaf [_fgffd ]=byte (_afdb );
_fgffd ++;};};};};case 4:_efbf :=[]float64 {_cbbb .Decode [0],_cbbb .Decode [1]};_dcgg :=[]float64 {_cbbb .Decode [2],_cbbb .Decode [3]};_fbea :=[]float64 {_cbbb .Decode [4],_cbbb .Decode [5]};_fbce :=[]float64 {_cbbb .Decode [6],_cbbb .Decode [7]};for _agba :=_bbcfg .Min .Y ;
_agba < _bbcfg .Max .Y ;_agba ++{for _ffb :=_bbcfg .Min .X ;_ffb < _bbcfg .Max .X ;_ffb ++{_eeg :=_agab .At (_ffb ,_agba );_ddca ,_gggf :=_eeg .(_dc .CMYK );if !_gggf {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ggfc :=255-_abd (uint (_ddca .C ),_efbf [0],_efbf [1]);_baea :=255-_abd (uint (_ddca .M ),_dcgg [0],_dcgg [1]);_afa :=255-_abd (uint (_ddca .Y ),_fbea [0],_fbea [1]);_aegg :=255-_abd (uint (_ddca .K ),_fbce [0],_fbce [1]);_dgaf [_fgffd ]=byte (_ggfc );
_fgffd ++;_dgaf [_fgffd ]=byte (_baea );_fgffd ++;_dgaf [_fgffd ]=byte (_afa );_fgffd ++;_dgaf [_fgffd ]=byte (_aegg );_fgffd ++;};};};return _dgaf ,nil ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_aefaa .Store (filterName ,customStreamEncoder );};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cad :=&PdfCrypt {_cba :false ,_cef :make (map[PdfObject ]bool ),_ffe :make (map[PdfObject ]bool ),_gca :make (map[int ]struct{}),_aff :parser };_gfba ,_ae :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_ae {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _cad ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gfba !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_cb .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gfba );
return _cad ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cad ._dce .Filter =string (*_gfba );if _eag ,_bfgg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_bfgg {_cad ._dce .SubFilter =_eag .Str ();
_cb .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_eag );};if L ,_cdee :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cdee {if (*L %8)!=0{_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _cad ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cad ._dce .Length =int (*L );}else {_cad ._dce .Length =40;};_cad ._dce .V =0;if _bde ,_cbe :=ed .Get ("\u0056").(*PdfObjectInteger );
_cbe {V :=int (*_bde );_cad ._dce .V =V ;if V >=1&&V <=2{_cad ._eede =_aaa (_cad ._dce .Length );}else if V >=4&&V <=5{if _dcba :=_cad .loadCryptFilters (ed );_dcba !=nil {return _cad ,_dcba ;};}else {_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _cad ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _cgd :=_gfa (&_cad ._ebb ,ed );_cgd !=nil {return _cad ,_cgd ;};_aee :="";if _fbbf ,_bff :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_bff &&_fbbf .Len ()>=1{_bfdg ,_bad :=GetString (_fbbf .Get (0));if !_bad {return _cad ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_aee =_bfdg .Str ();}else {_cb .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_cad ._eaeg =_aee ;return _cad ,nil ;};

// String returns a string describing `ind`.
func (_gfdga *PdfIndirectObject )String ()string {return _dca .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_gfdga ).ObjectNumber );};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ad .Filter ,userPass ,ownerPass []byte ,perm _af .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_gcf :=&PdfCrypt {_ffe :make (map[PdfObject ]bool ),_eede :make (cryptFilters ),_ebb :_af .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _gbg Version ;if cf !=nil {_fbc :=cf .PDFVersion ();_gbg .Major ,_gbg .Minor =_fbc [0],_fbc [1];V ,R :=cf .HandlerVersion ();_gcf ._dce .V =V ;_gcf ._ebb .R =R ;_gcf ._dce .Length =cf .KeyLength ()*8;};const (_bfe =_cfeg ;);_gcf ._eede [_bfe ]=cf ;
if _gcf ._dce .V >=4{_gcf ._gdce =_bfe ;_gcf ._gfe =_bfe ;};_beg :=_gcf .newEncryptDict ();_gdca :=_aa .Sum ([]byte (_ac .Now ().Format (_ac .RFC850 )));_bbf :=string (_gdca [:]);_ged :=make ([]byte ,100);_ee .Read (_ged );_gdca =_aa .Sum (_ged );_dcb :=string (_gdca [:]);
_cb .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ged );_cb .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_bbf );_gcf ._eaeg =_bbf ;_fe :=_gcf .generateParams (userPass ,ownerPass );
if _fe !=nil {return nil ,nil ,_fe ;};_gec (&_gcf ._ebb ,_beg );if _gcf ._dce .V >=4{if _dgf :=_gcf .saveCryptFilters (_beg );_dgf !=nil {return nil ,nil ,_dgf ;};};return _gcf ,&EncryptInfo {Version :_gbg ,Encrypt :_beg ,ID0 :_bbf ,ID1 :_dcb },nil ;};


// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_dcbf :objects }};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dffa *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_efgbg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bdea :=MakeDict ();_bdea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efgbg .GetFilterName ()));return _bdea ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_dgfb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dgfb .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_beeg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func _acb (_gdceb int )int {_ccbg :=_gdceb >>(_gffc -1);return (_gdceb ^_ccbg )-_ccbg };var _fefb =_g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_edfb :=&FlateEncoder {};_edfb .Predictor =1;_edfb .BitsPerComponent =8;_edfb .Colors =1;_edfb .Columns =1;return _edfb ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_eggg *PdfObjectString )IsHexadecimal ()bool {return _eggg ._bggf };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dffaf *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cage :=_dffaf .GetFileOffset ();_ ,_bgbae :=_dffaf ._ecgd .Seek (offset ,_de .SeekStart );if _bgbae !=nil {return nil ,_bgbae ;};_edd :=make ([]byte ,len );_ ,_bgbae =_de .ReadAtLeast (_dffaf ._ecgd ,_edd ,int (len ));
if _bgbae !=nil {return nil ,_bgbae ;};_dffaf .SetFileOffset (_cage );return _edd ,nil ;};func (_ddce *PdfParser )parseBool ()(PdfObjectBool ,error ){_gfbg ,_gadf :=_ddce ._gega .Peek (4);if _gadf !=nil {return PdfObjectBool (false ),_gadf ;};if (len (_gfbg )>=4)&&(string (_gfbg [:4])=="\u0074\u0072\u0075\u0065"){_ddce ._gega .Discard (4);
return PdfObjectBool (true ),nil ;};_gfbg ,_gadf =_ddce ._gega .Peek (5);if _gadf !=nil {return PdfObjectBool (false ),_gadf ;};if (len (_gfbg )>=5)&&(string (_gfbg [:5])=="\u0066\u0061\u006cs\u0065"){_ddce ._gega .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_gggb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _eeff ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _gggb .ColorComponents !=1||_gggb .BitsPerComponent !=1{return nil ,_ace .Errorf (_eeff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_cgad *_cde .Bitmap ;_bbeg error ;);_bbfcga :=(_gggb .Width *_gggb .Height )==len (data );if _bbfcga {_cgad ,_bbeg =_cde .NewWithUnpaddedData (_gggb .Width ,_gggb .Height ,data );}else {_cgad ,_bbeg =_cde .NewWithData (_gggb .Width ,_gggb .Height ,data );
};if _bbeg !=nil {return nil ,_bbeg ;};_dfd :=_gggb .DefaultPageSettings ;if _bbeg =_dfd .Validate ();_bbeg !=nil {return nil ,_ace .Wrap (_bbeg ,_eeff ,"");};if _gggb ._efed ==nil {_gggb ._efed =_db .InitEncodeDocument (_dfd .FileMode );};switch _dfd .Compression {case JB2Generic :if _bbeg =_gggb ._efed .AddGenericPage (_cgad ,_dfd .DuplicatedLinesRemoval );
_bbeg !=nil {return nil ,_ace .Wrap (_bbeg ,_eeff ,"");};case JB2SymbolCorrelation :return nil ,_ace .Error (_eeff ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_ace .Error (_eeff ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_ace .Error (_eeff ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _gggb .Encode ();};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_ggad *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _cfdb _ed .Buffer ;for _ ,_bbgd :=range data {_cfdb .WriteString (_dca .Sprintf ("\u0025\u002e\u0032X\u0020",_bbgd ));};_cfdb .WriteByte ('>');return _cfdb .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_accgf *LZWEncoder )MakeDecodeParams ()PdfObject {if _accgf .Predictor > 1{_ecef :=MakeDict ();_ecef .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_accgf .Predictor )));if _accgf .BitsPerComponent !=8{_ecef .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_accgf .BitsPerComponent )));
};if _accgf .Columns !=1{_ecef .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_accgf .Columns )));};if _accgf .Colors !=1{_ecef .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_accgf .Colors )));};return _ecef ;};return nil ;
};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_faa ParserMetadata )HasOddLengthHexStrings ()bool {return _faa ._ceda };

// UpdateParams updates the parameter values of the encoder.
func (_aceg *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_fdfg :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _fdfg ==nil {return NewRawEncoder (),nil ;};if _ ,_dffeg :=_fdfg .(*PdfObjectNull );
_dffeg {return NewRawEncoder (),nil ;};_aggc ,_fbcad :=_fdfg .(*PdfObjectName );if !_fbcad {_gfcbd ,_cceda :=_fdfg .(*PdfObjectArray );if !_cceda {return nil ,_dca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _gfcbd .Len ()==0{return NewRawEncoder (),nil ;};if _gfcbd .Len ()!=1{_bacf ,_gfce :=_beec (streamObj );if _gfce !=nil {_cb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gfce );
return nil ,_gfce ;};_cb .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_bacf );return _bacf ,nil ;};_fdfg =_gfcbd .Get (0);_aggc ,_cceda =_fdfg .(*PdfObjectName );if !_cceda {return nil ,_dca .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _ggff ,_gegfc :=_aefaa .Load (_aggc .String ());_gegfc {return _ggff .(StreamEncoder ),nil ;};switch *_aggc {case StreamEncodingFilterNameFlate :return _fed (streamObj ,nil );case StreamEncodingFilterNameLZW :return _cbgd (streamObj ,nil );case StreamEncodingFilterNameDCT :return _cfdc (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _cfbe (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _bfgc (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _fegg (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_dca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_aggc );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_decd *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_edef :=MakeDict ();_edef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_decd .GetFilterName ()));return _edef ;};

// Remove removes an element specified by key.
func (_gfcf *PdfObjectDictionary )Remove (key PdfObjectName ){_afdbd :=-1;for _bgggd ,_efcgb :=range _gfcf ._edaeb {if _efcgb ==key {_afdbd =_bgggd ;break ;};};if _afdbd >=0{_gfcf ._edaeb =append (_gfcf ._edaeb [:_afdbd ],_gfcf ._edaeb [_afdbd +1:]...);
delete (_gfcf ._cgaag ,key );};};func _dgfde (_abag *PdfObjectDictionary )(_afgb *_eg .ImageBase ){var (_aaacd *PdfObjectInteger ;_aafc bool ;);if _aaacd ,_aafc =_abag .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_aafc {_afgb =&_eg .ImageBase {Width :int (*_aaacd )};
}else {return nil ;};if _aaacd ,_aafc =_abag .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_aafc {_afgb .Height =int (*_aaacd );};if _aaacd ,_aafc =_abag .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_aafc {_afgb .BitsPerComponent =int (*_aaacd );};if _aaacd ,_aafc =_abag .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_aafc {_afgb .ColorComponents =int (*_aaacd );};return _afgb ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_bebg :=&ASCIIHexEncoder {};return _bebg };

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_aaeb *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_g .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_cdbefa ,_fbeg :=_aaeb .getNumbersOfUpdatedObjects (prevParser );if _fbeg !=nil {return nil ,_fbeg ;};_dbbab :=make (map[int64 ]PdfObject );for _ ,_cfcb :=range _cdbefa {if _edfbb ,_abbda :=_aaeb .LookupByNumber (_cfcb );_abbda ==nil {_dbbab [int64 (_cfcb )]=_edfbb ;
}else {return nil ,_abbda ;};};return _dbbab ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// DecodeStream implements ASCII85 stream decoding.
func (_ddfg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ddfg .DecodeBytes (streamObj .Stream );};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_accf *FlateEncoder )SetPredictor (columns int ){_accf .Predictor =11;_accf .Columns =columns };

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fdgged string ;_bggf bool ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_dbeg []StreamEncoder };

// Read implementation of Read interface.
func (_egdd *limitedReadSeeker )Read (p []byte )(_adca int ,_dfga error ){_ecca ,_dfga :=_egdd ._fecf .Seek (0,_de .SeekCurrent );if _dfga !=nil {return 0,_dfga ;};_gebe :=_egdd ._cbad -_ecca ;if _gebe ==0{return 0,_de .EOF ;};if _fffe :=int64 (len (p ));
_fffe < _gebe {_gebe =_fffe ;};_afeb :=make ([]byte ,_gebe );_adca ,_dfga =_egdd ._fecf .Read (_afeb );copy (p ,_afeb );return _adca ,_dfga ;};func (_acae *PdfParser )skipComments ()error {if _ ,_bbgg :=_acae .skipSpaces ();_bbgg !=nil {return _bbgg ;};
_fcfc :=true ;for {_beca ,_dbgea :=_acae ._gega .Peek (1);if _dbgea !=nil {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_dbgea .Error ());return _dbgea ;};if _fcfc &&_beca [0]!='%'{return nil ;};_fcfc =false ;if (_beca [0]!='\r')&&(_beca [0]!='\n'){_acae ._gega .ReadByte ();
}else {break ;};};return _acae .skipComments ();};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gadb :=PdfObjectString {_fdgged :s };return &_gadb };

// GetFilterName returns the name of the encoding filter.
func (_fggb *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };var _gfge =_ec .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_abac *JBIG2Encoder )encodeImage (_cfbd _c .Image )([]byte ,error ){const _cebfe ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";
_gadd ,_ffbe :=GoImageToJBIG2 (_cfbd ,JB2ImageAutoThreshold );if _ffbe !=nil {return nil ,_ace .Wrap (_ffbe ,_cebfe ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _ffbe =_abac .AddPageImage (_gadd ,&_abac .DefaultPageSettings );_ffbe !=nil {return nil ,_ace .Wrap (_ffbe ,_cebfe ,"");};return _abac .Encode ();};

// String returns a descriptive information string about the encryption method used.
func (_efg *PdfCrypt )String ()string {if _efg ==nil {return "";};_cdge :=_efg ._dce .Filter +"\u0020\u002d\u0020";if _efg ._dce .V ==0{_cdge +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _efg ._dce .V ==1{_cdge +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _efg ._dce .V ==2{_cdge +=_dca .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_efg ._dce .Length );}else if _efg ._dce .V ==3{_cdge +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _efg ._dce .V >=4{_cdge +=_dca .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_efg ._gdce ,_efg ._gfe );
_cdge +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ffg ,_gbf :=range _efg ._eede {_cdge +=_dca .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ffg ,_gbf .Name (),_gbf .KeyLength ());
};};_cefb :=_efg .GetAccessPermissions ();_cdge +=_dca .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cefb );return _cdge ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cfeb *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_aggd Version )String ()string {return _dca .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_aggd .Major ,_aggd .Minor );};type objectCache map[int ]PdfObject ;

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_ggfb *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ggfb .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};func (_abcd *PdfParser )checkLinearizedInformation (_cfag *PdfObjectDictionary )(bool ,error ){var _agdf error ;_abcd ._gacf ,_agdf =GetNumberAsInt64 (_cfag .Get ("\u004c"));if _agdf !=nil {return false ,_agdf ;};_agdf =_abcd .seekToEOFMarker (_abcd ._gacf );
switch _agdf {case nil :return true ,nil ;case _fefb :return false ,nil ;default:return false ,_agdf ;};};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_bfa *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cbaa _ed .Buffer ;for _cbca :=0;_cbca < len (data );_cbca +=4{_gde :=data [_cbca ];_bcgb :=1;_bafea :=byte (0);if _cbca +1< len (data ){_bafea =data [_cbca +1];_bcgb ++;};_ggeb :=byte (0);
if _cbca +2< len (data ){_ggeb =data [_cbca +2];_bcgb ++;};_dffg :=byte (0);if _cbca +3< len (data ){_dffg =data [_cbca +3];_bcgb ++;};_edbe :=(uint32 (_gde )<<24)|(uint32 (_bafea )<<16)|(uint32 (_ggeb )<<8)|uint32 (_dffg );if _edbe ==0{_cbaa .WriteByte ('z');
}else {_ceedc :=_bfa .base256Tobase85 (_edbe );for _ ,_bbfeb :=range _ceedc [:_bcgb +1]{_cbaa .WriteByte (_bbfeb +'!');};};};_cbaa .WriteString ("\u007e\u003e");return _cbaa .Bytes (),nil ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_dcca float64 ,_fabef bool ){_gccc ,_fabef :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fabef {return float64 (*_gccc ),true ;};return 0,false ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_ddde *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _ggadb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _dbfc :=_ddde .AddPageImage (img ,&_ddde .DefaultPageSettings );
_dbfc !=nil {return nil ,_ace .Wrap (_dbfc ,_ggadb ,"");};return _ddde .Encode ();};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _eddd :=obj .(type ){case *PdfObjectFloat :return float64 (*_eddd ),nil ;case *PdfObjectInteger :return float64 (*_eddd ),nil ;case *PdfObjectReference :_bdeca :=TraceToDirectObject (obj );
return GetNumberAsFloat (_bdeca );case *PdfIndirectObject :return GetNumberAsFloat (_eddd .PdfObject );};return 0,ErrNotANumber ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_edee *PdfObjectFloat ,_agebb bool ){_edee ,_agebb =TraceToDirectObject (obj ).(*PdfObjectFloat );return _edee ,_agebb ;};func (_faacg *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_de .SeekStart {offset +=_faacg ._beab ;
};_bacg ,_dceb :=_faacg ._bcbe .Seek (offset ,whence );if _dceb !=nil {return _bacg ,_dceb ;};if whence ==_de .SeekCurrent {_bacg -=_faacg ._beab ;};if _bacg < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _bacg ,nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_cbgc *PdfParser )Inspect ()(map[string ]int ,error ){return _cbgc .inspect ()};func (_bae *PdfCrypt )checkAccessRights (_eagf []byte )(bool ,_af .Permissions ,error ){_aaaa :=_bae .securityHandler ();_efgb ,_eeb ,_fcdd :=_aaaa .Authenticate (&_bae ._ebb ,_eagf );
if _fcdd !=nil {return false ,0,_fcdd ;}else if _eeb ==0||len (_efgb )==0{return false ,0,nil ;};return true ,_eeb ,nil ;};var _fgab =_ec .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");
func _abf (_fcg *_ad .FilterDict ,_egf *PdfObjectDictionary )error {if _ffee ,_bee :=_egf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bee {if _bgf :=string (*_ffee );_bgf !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_cb .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bgf );
};};_fgb ,_fcde :=_egf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_fcde {return _dca .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_fcg .CFM =string (*_fgb );if _ecb ,_fdb :=_egf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_fdb {_fcg .AuthEvent =_af .AuthEvent (*_ecb );}else {_fcg .AuthEvent =_af .EventDocOpen ;};if _dgd ,_gbcb :=_egf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_gbcb {_fcg .Length =int (*_dgd );};return nil ;};func (_acaac *PdfParser )traceStreamLength (_fgdd PdfObject )(PdfObject ,error ){_eeab ,_abgg :=_fgdd .(*PdfObjectReference );if _abgg {_bda ,_ddgca :=_acaac ._ccbe [_eeab .ObjectNumber ];if _ddgca &&_bda {_cb .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_acaac ._ccbe [_eeab .ObjectNumber ]=true ;};_dacf ,_bcccb :=_acaac .Resolve (_fgdd );if _bcccb !=nil {return nil ,_bcccb ;
};_cb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dacf );if _abgg {_acaac ._ccbe [_eeab .ObjectNumber ]=false ;};return _dacf ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_cdaa *PdfParser )GetXrefTable ()XrefTable {return _cdaa ._fffef };

// UpdateParams updates the parameter values of the encoder.
func (_cbfd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_ddae *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ddae ._agbgb ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ddae ._agbgb [i ]=obj ;return nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_cfec *JBIG2Encoder )Encode ()(_faga []byte ,_cfgg error ){const _bbdf ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _cfec ._efed ==nil {return nil ,_ace .Errorf (_bbdf ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_cfec ._efed .FullHeaders =_cfec .DefaultPageSettings .FileMode ;_faga ,_cfgg =_cfec ._efed .Encode ();if _cfgg !=nil {return nil ,_ace .Wrap (_cfgg ,_bbdf ,"");};return _faga ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ffgfd *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_bgba :=range _ffgfd ._dbeg {_bgba .UpdateParams (params );};};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_efed :_db .InitEncodeDocument (false )}};

// Len returns the number of elements in the array.
func (_cbaba *PdfObjectArray )Len ()int {if _cbaba ==nil {return 0;};return len (_cbaba ._dcbf );};func _eaf (_eefg _de .ReadSeeker ,_fbdg int64 )(*offsetReader ,error ){_cbab :=&offsetReader {_bcbe :_eefg ,_beab :_fbdg };_ ,_fecg :=_cbab .Seek (0,_de .SeekStart );
return _cbab ,_fecg ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_adbc *_eg .ImageBase ;};type offsetReader struct{_bcbe _de .ReadSeeker ;_beab int64 ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _de .ReadSeeker )(*PdfParser ,error ){_gcgbc :=&PdfParser {_ecgd :rs ,ObjCache :make (objectCache ),_ccbe :map[int64 ]bool {},_aadfg :make ([]int64 ,0),_gcgb :make (map[*PdfParser ]*PdfParser )};_becf ,_bfbce ,_geff :=_gcgbc .parsePdfVersion ();
if _geff !=nil {_cb .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_geff );return nil ,_geff ;};_gcgbc ._dcad .Major =_becf ;_gcgbc ._dcad .Minor =_bfbce ;
if _gcgbc ._bga ,_geff =_gcgbc .loadXrefs ();_geff !=nil {_cb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_geff );return nil ,_geff ;
};_cb .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gcgbc ._bga );_ddccg ,_geff :=_gcgbc .parseLinearizedDictionary ();if _geff !=nil {return nil ,_geff ;};if _ddccg !=nil {_gcgbc ._aaec ,_geff =_gcgbc .checkLinearizedInformation (_ddccg );
if _geff !=nil {return nil ,_geff ;};};if len (_gcgbc ._fffef .ObjectMap )==0{return nil ,_dca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_gcgbc ._bbfb =len (_gcgbc ._aadfg );if _gcgbc ._aaec &&_gcgbc ._bbfb !=0{_gcgbc ._bbfb --;};_gcgbc ._bcga =make ([]*PdfParser ,_gcgbc ._bbfb );return _gcgbc ,nil ;};var _fgfcb =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");


// WriteString outputs the object as it is to be written to file.
func (_dggff *PdfObjectInteger )WriteString ()string {return _f .FormatInt (int64 (*_dggff ),10)};func (_dbb *PdfCrypt )saveCryptFilters (_efc *PdfObjectDictionary )error {if _dbb ._dce .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_ecc :=MakeDict ();_efc .Set ("\u0043\u0046",_ecc );for _egcf ,_dee :=range _dbb ._eede {if _egcf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bgc :=_ffgf (_dee ,"");_ecc .Set (PdfObjectName (_egcf ),_bgc );};_efc .Set ("\u0053\u0074\u0072\u0046",MakeName (_dbb ._gfe ));
_efc .Set ("\u0053\u0074\u006d\u0046",MakeName (_dbb ._gdce ));return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gebd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_fdbeb *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_agbgb []PdfObject ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_deacf *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _deacf .DecodeBytes (streamObj .Stream );};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dbc *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dbc .isEncrypted (obj ){return nil ;};switch _aba :=obj .(type ){case *PdfIndirectObject :_dbc ._ffe [_aba ]=true ;_cb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aba .ObjectNumber ,_aba .GenerationNumber );
_eac :=_aba .ObjectNumber ;_cdf :=_aba .GenerationNumber ;_abfe :=_dbc .Encrypt (_aba .PdfObject ,_eac ,_cdf );if _abfe !=nil {return _abfe ;};return nil ;case *PdfObjectStream :_dbc ._ffe [_aba ]=true ;_efec :=_aba .PdfObjectDictionary ;if _bbd ,_eceb :=_efec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_eceb &&*_bbd =="\u0058\u0052\u0065\u0066"{return nil ;};_ecba :=_aba .ObjectNumber ;_dff :=_aba .GenerationNumber ;_cb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ecba ,_dff );
_bggc :=_cfeg ;if _dbc ._dce .V >=4{_bggc =_dbc ._gdce ;_cb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dbc ._gdce );if _fab ,_fba :=_efec .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_fba {if _dbd ,_fce :=GetName (_fab .Get (0));_fce {if *_dbd =="\u0043\u0072\u0079p\u0074"{_bggc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eef ,_dgfd :=_efec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_dgfd {if _aab ,_eagd :=_eef .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_eagd {if _ ,_abec :=_dbc ._eede [string (*_aab )];_abec {_cb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_aab );
_bggc =string (*_aab );};};};};};};_cb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bggc );if _bggc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ggfe :=_dbc .Encrypt (_aba .PdfObjectDictionary ,_ecba ,_dff );
if _ggfe !=nil {return _ggfe ;};_fee ,_ggfe :=_dbc .makeKey (_bggc ,uint32 (_ecba ),uint32 (_dff ),_dbc ._ceef );if _ggfe !=nil {return _ggfe ;};_aba .Stream ,_ggfe =_dbc .encryptBytes (_aba .Stream ,_bggc ,_fee );if _ggfe !=nil {return _ggfe ;};_efec .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aba .Stream ))));
return nil ;case *PdfObjectString :_cb .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gcad :=_cfeg ;if _dbc ._dce .V >=4{_cb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dbc ._gfe );
if _dbc ._gfe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gcad =_dbc ._gfe ;};_dcbd ,_gdfb :=_dbc .makeKey (_gcad ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dbc ._ceef );if _gdfb !=nil {return _gdfb ;};_bcc :=_aba .Str ();_deff :=make ([]byte ,len (_bcc ));
for _fdbc :=0;_fdbc < len (_bcc );_fdbc ++{_deff [_fdbc ]=_bcc [_fdbc ];};_cb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_deff ,_deff );_deff ,_gdfb =_dbc .encryptBytes (_deff ,_gcad ,_dcbd );
if _gdfb !=nil {return _gdfb ;};_aba ._fdgged =string (_deff );return nil ;case *PdfObjectArray :for _ ,_fdg :=range _aba .Elements (){_beef :=_dbc .Encrypt (_fdg ,parentObjNum ,parentGenNum );if _beef !=nil {return _beef ;};};return nil ;case *PdfObjectDictionary :_gacd :=false ;
if _egd :=_aba .Get ("\u0054\u0079\u0070\u0065");_egd !=nil {_bed ,_cebf :=_egd .(*PdfObjectName );if _cebf &&*_bed =="\u0053\u0069\u0067"{_gacd =true ;};};for _ ,_eacf :=range _aba .Keys (){_afd :=_aba .Get (_eacf );if _gacd &&string (_eacf )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_eacf )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_eacf )!="\u0050\u0072\u0065\u0076"&&string (_eacf )!="\u004c\u0061\u0073\u0074"{_bbfc :=_dbc .Encrypt (_afd ,parentObjNum ,parentGenNum );if _bbfc !=nil {return _bbfc ;};};};return nil ;
};return nil ;};func _gfa (_bfd *_af .StdEncryptDict ,_fdc *PdfObjectDictionary )error {R ,_cefc :=_fdc .Get ("\u0052").(*PdfObjectInteger );if !_cefc {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bfd .R =int (*R );O ,_cefc :=_fdc .GetString ("\u004f");if !_cefc {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _bfd .R ==5||_bfd .R ==6{if len (O )< 48{return _dca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _dca .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_bfd .O =[]byte (O );U ,_cefc :=_fdc .GetString ("\u0055");if !_cefc {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bfd .R ==5||_bfd .R ==6{if len (U )< 48{return _dca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_cb .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bfd .U =[]byte (U );if _bfd .R >=5{OE ,_dbg :=_fdc .GetString ("\u004f\u0045");
if !_dbg {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _dca .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_bfd .OE =[]byte (OE );UE ,_dbg :=_fdc .GetString ("\u0055\u0045");if !_dbg {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _dca .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bfd .UE =[]byte (UE );};P ,_cefc :=_fdc .Get ("\u0050").(*PdfObjectInteger );if !_cefc {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_bfd .P =_af .Permissions (*P );if _bfd .R ==6{Perms ,_abca :=_fdc .GetString ("\u0050\u0065\u0072m\u0073");if !_abca {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _dca .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bfd .Perms =[]byte (Perms );};if _fgf ,_aded :=_fdc .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_aded {_bfd .EncryptMetadata =bool (*_fgf );}else {_bfd .EncryptMetadata =true ;};return nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_bgffe *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_ggbc ,_cade :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cade ==nil {_bgffe .BitsPerComponent =int (_ggbc );
};_fbg ,_cade :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cade ==nil {_bgffe .Width =int (_fbg );};_bede ,_cade :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cade ==nil {_bgffe .Height =int (_bede );
};_aefa ,_cade :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cade ==nil {_bgffe .ColorComponents =int (_aefa );};};

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_gcag *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _gcag ._bbfb ==0{return nil ,_g .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _cgaa ,_eca :=_gcag ._gcgb [_gcag ];
_eca {return _cgaa ,nil ;};_abgc ,_efdg :=_gcag .GetPreviousRevisionReadSeeker ();if _efdg !=nil {return nil ,_efdg ;};_fcdg ,_efdg :=NewParser (_abgc );_fcdg ._gcgb =_gcag ._gcgb ;if _efdg !=nil {return nil ,_efdg ;};_gcag ._gcgb [_gcag ]=_fcdg ;return _fcdg ,nil ;
};

// Clear resets the dictionary to an empty state.
func (_ffeaa *PdfObjectDictionary )Clear (){_ffeaa ._edaeb =[]PdfObjectName {};_ffeaa ._cgaag =map[PdfObjectName ]PdfObject {};_ffeaa ._fbcc =&_e .Mutex {};};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_eefb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_defd error ){const _ddfbb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _eefb ==nil {return _ace .Error (_ddfbb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_eefb .DefaultPageSettings ;};if _eefb ._efed ==nil {_eefb ._efed =_db .InitEncodeDocument (settings .FileMode );
};if _defd =settings .Validate ();_defd !=nil {return _ace .Wrap (_defd ,_ddfbb ,"");};_dbff ,_defd :=img .toBitmap ();if _defd !=nil {return _ace .Wrap (_defd ,_ddfbb ,"");};switch settings .Compression {case JB2Generic :if _defd =_eefb ._efed .AddGenericPage (_dbff ,settings .DuplicatedLinesRemoval );
_defd !=nil {return _ace .Wrap (_defd ,_ddfbb ,"");};case JB2SymbolCorrelation :return _ace .Error (_ddfbb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _ace .Error (_ddfbb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _ace .Error (_ddfbb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_fdce *PdfCrypt )authenticate (_def []byte )(bool ,error ){_fdce ._cba =false ;
_ggac :=_fdce .securityHandler ();_ebdbg ,_aaff ,_egfd :=_ggac .Authenticate (&_fdce ._ebb ,_def );if _egfd !=nil {return false ,_egfd ;}else if _aaff ==0||len (_ebdbg )==0{return false ,nil ;};_fdce ._cba =true ;_fdce ._ceef =_ebdbg ;return true ,nil ;
};func (_bbb *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_aafed :=MakeDict ();_aafed .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_aafed .Set ("\u0056",MakeInteger (int64 (_bbb ._dce .V )));
_aafed .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bbb ._dce .Length )));return _aafed ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgee *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ffde :=MakeDict ();_ffde .Set ("\u004b",MakeInteger (int64 (_fgee .K )));_ffde .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgee .Columns )));if _fgee .BlackIs1 {_ffde .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fgee .BlackIs1 ));
};if _fgee .EncodedByteAlign {_ffde .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fgee .EncodedByteAlign ));};if _fgee .EndOfLine &&_fgee .K >=0{_ffde .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fgee .EndOfLine ));
};if _fgee .Rows !=0&&!_fgee .EndOfBlock {_ffde .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fgee .Rows )));};if !_fgee .EndOfBlock {_ffde .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fgee .EndOfBlock ));};if _fgee .DamagedRowsBeforeError !=0{_ffde .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fgee .DamagedRowsBeforeError )));
};return _ffde ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dced *PdfParser )IsEncrypted ()(bool ,error ){if _dced ._agf !=nil {return true ,nil ;}else if _dced ._bga ==nil {return false ,nil ;};_cb .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_gdda :=_dced ._bga .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _gdda ==nil {return false ,nil ;};_cb .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_geda *PdfObjectDictionary ;);switch _ffga :=_gdda .(type ){case *PdfObjectDictionary :_geda =_ffga ;
case *PdfObjectReference :_cb .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_ffga );_bfcd ,_aaaf :=_dced .LookupByReference (*_ffga );_cb .Log .Trace ("\u0031\u003a\u0020%\u0071",_bfcd );
if _aaaf !=nil {return false ,_aaaf ;};_cedg ,_gcbb :=_bfcd .(*PdfIndirectObject );if !_gcbb {_cb .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_cgeb ,_gcbb :=_cedg .PdfObject .(*PdfObjectDictionary );_dced ._ffdg =_cedg ;_cb .Log .Trace ("\u0032\u003a\u0020%\u0071",_cgeb );if !_gcbb {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_geda =_cgeb ;case *PdfObjectNull :_cb .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_dca .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_ffga );};_gegf ,_bbab :=PdfCryptNewDecrypt (_dced ,_geda ,_dced ._bga );if _bbab !=nil {return false ,_bbab ;
};for _ ,_cadd :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bccgb :=_dced ._bga .Get (PdfObjectName (_cadd ));if _bccgb ==nil {continue ;};switch _eeeg :=_bccgb .(type ){case *PdfObjectReference :_gegf ._gca [int (_eeeg .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_gegf ._cef [_eeeg ]=true ;_gegf ._gca [int (_eeeg .ObjectNumber )]=struct{}{};};};_dced ._agf =_gegf ;_cb .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_gegf );
return true ,nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_egfa *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_faca *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _cebe []int ;for _ ,_aaece :=range _faca .Elements (){if _fgce ,_eeba :=_aaece .(*PdfObjectInteger );_eeba {_cebe =append (_cebe ,int (*_fgce ));}else {return nil ,ErrTypeError ;};};return _cebe ,nil ;
};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_fedd :=PdfObjectString {_fdgged :s ,_bggf :true };return &_fedd ;};

// WriteString outputs the object as it is to be written to file.
func (_cafea *PdfObjectArray )WriteString ()string {var _acff _gcd .Builder ;_acff .WriteString ("\u005b");for _ccda ,_fbfd :=range _cafea .Elements (){_acff .WriteString (_fbfd .WriteString ());if _ccda < (_cafea .Len ()-1){_acff .WriteString ("\u0020");
};};_acff .WriteString ("\u005d");return _acff .String ();};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_agef *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bdbd []byte ;_cb .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_deaf :=0;_aede :=false ;for _deaf < len (encoded )&&!_aede {_ebc :=[5]byte {0,0,0,0,0};
_abbf :=0;_bebd :=0;_aaab :=4;for _bebd < 5+_abbf {if _deaf +_bebd ==len (encoded ){break ;};_dgbg :=encoded [_deaf +_bebd ];if IsWhiteSpace (_dgbg ){_abbf ++;_bebd ++;continue ;}else if _dgbg =='~'&&_deaf +_bebd +1< len (encoded )&&encoded [_deaf +_bebd +1]=='>'{_aaab =(_bebd -_abbf )-1;
if _aaab < 0{_aaab =0;};_aede =true ;break ;}else if _dgbg >='!'&&_dgbg <='u'{_dgbg -='!';}else if _dgbg =='z'&&_bebd -_abbf ==0{_aaab =4;_bebd ++;break ;}else {_cb .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ebc [_bebd -_abbf ]=_dgbg ;_bebd ++;};_deaf +=_bebd ;for _dadd :=_aaab +1;_dadd < 5;_dadd ++{_ebc [_dadd ]=84;
};_cfgee :=uint32 (_ebc [0])*85*85*85*85+uint32 (_ebc [1])*85*85*85+uint32 (_ebc [2])*85*85+uint32 (_ebc [3])*85+uint32 (_ebc [4]);_cbeb :=[]byte {byte ((_cfgee >>24)&0xff),byte ((_cfgee >>16)&0xff),byte ((_cfgee >>8)&0xff),byte (_cfgee &0xff)};_bdbd =append (_bdbd ,_cbeb [:_aaab ]...);
};_cb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_cb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bdbd );
return _bdbd ,nil ;};func (_cbc *PdfCrypt )makeKey (_bfb string ,_baf ,_aag uint32 ,_aafef []byte )([]byte ,error ){_gcfg ,_bdee :=_cbc ._eede [_bfb ];if !_bdee {return nil ,_dca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bfb );
};return _gcfg .MakeKey (_baf ,_aag ,_aafef );};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _de .ReadSeeker )(_aecb *PdfParser ,_efaf error ){_aecb =&PdfParser {_ecgd :rs ,ObjCache :make (objectCache ),_ccbe :map[int64 ]bool {},_bgda :true ,_gcgb :make (map[*PdfParser ]*PdfParser )};if _efaf =_aecb .parseDetailedHeader ();
_efaf !=nil {return nil ,_efaf ;};if _aecb ._bga ,_efaf =_aecb .loadXrefs ();_efaf !=nil {_cb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_efaf );
return nil ,_efaf ;};_cb .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_aecb ._bga );if len (_aecb ._fffef .ObjectMap )==0{return nil ,_dca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _aecb ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// Validate validates the page settings for the JBIG2 encoder.
func (_gaga JBIG2EncoderSettings )Validate ()error {const _agd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _gaga .Threshold < 0||_gaga .Threshold > 1.0{return _ace .Errorf (_agd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_gaga .Threshold );
};if _gaga .ResolutionX < 0{return _ace .Errorf (_agd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gaga .ResolutionX );
};if _gaga .ResolutionY < 0{return _ace .Errorf (_agd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gaga .ResolutionY );
};if _gaga .DefaultPixelValue !=0&&_gaga .DefaultPixelValue !=1{return _ace .Errorf (_agd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_gaga .DefaultPixelValue );
};if _gaga .Compression !=JB2Generic {return _ace .Errorf (_agd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_fca .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcbb *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_ffa :=MakeDict ();_ffa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fcbb .GetFilterName ()));return _ffa ;};var _cfff =_ec .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");


// UpdateParams updates the parameter values of the encoder.
func (_bdfd *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_bcgd ,_gbba :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gbba ==nil {_bdfd .ColorComponents =int (_bcgd );
};_cefbg ,_gbba :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gbba ==nil {_bdfd .BitsPerComponent =int (_cefbg );};_gabab ,_gbba :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _gbba ==nil {_bdfd .Width =int (_gabab );};_eadf ,_gbba :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gbba ==nil {_bdfd .Height =int (_eadf );};_bccfe ,_gbba :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _gbba ==nil {_bdfd .Quality =int (_bccfe );};_efdae ,_dgab :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _dgab {_bdfd .Decode ,_gbba =_efdae .ToFloat64Array ();if _gbba !=nil {_cb .Log .Error ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u006f\u006ev\u0065\u0072\u0074\u0069\u006e\u0067\u0020de\u0063\u006f\u0064\u0065 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006eto\u0020\u0061r\u0072\u0061\u0079\u0073\u003a\u0020\u0025\u0076",_gbba );
};};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ggb *FlateEncoder )MakeDecodeParams ()PdfObject {if _ggb .Predictor > 1{_febg :=MakeDict ();_febg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ggb .Predictor )));if _ggb .BitsPerComponent !=8{_febg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ggb .BitsPerComponent )));
};if _ggb .Columns !=1{_febg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ggb .Columns )));};if _ggb .Colors !=1{_febg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ggb .Colors )));};return _febg ;};return nil ;
};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_debd *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _adbe _eg .Gray ;switch len (data ){case _debd .Rows *_debd .Columns :_baab ,_faaf :=_eg .NewImage (_debd .Columns ,_debd .Rows ,8,1,data ,nil ,nil );if _faaf !=nil {return nil ,_faaf ;
};_adbe =_baab .(_eg .Gray );case (_debd .Columns *_debd .Rows )+7>>3:_aebe ,_aegc :=_eg .NewImage (_debd .Columns ,_debd .Rows ,1,1,data ,nil ,nil );if _aegc !=nil {return nil ,_aegc ;};_gbd :=_aebe .(*_eg .Monochrome );if _aegc =_gbd .AddPadding ();_aegc !=nil {return nil ,_aegc ;
};_adbe =_gbd ;default:if len (data )< _eg .BytesPerLine (_debd .Columns ,1,1)*_debd .Rows {return nil ,_g .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_ccgd ,_cfda :=_eg .NewImage (_debd .Columns ,_debd .Rows ,1,1,data ,nil ,nil );if _cfda !=nil {return nil ,_cfda ;};_aadd :=_ccgd .(*_eg .Monochrome );_adbe =_aadd ;};_abbb :=make ([][]byte ,_debd .Rows );for _aadf :=0;_aadf < _debd .Rows ;_aadf ++{_adega :=make ([]byte ,_debd .Columns );
for _bbbe :=0;_bbbe < _debd .Columns ;_bbbe ++{_ecfg :=_adbe .GrayAt (_bbbe ,_aadf );_adega [_bbbe ]=_ecfg .Y >>7;};_abbb [_aadf ]=_adega ;};_abgfe :=&_b .Encoder {K :_debd .K ,Columns :_debd .Columns ,EndOfLine :_debd .EndOfLine ,EndOfBlock :_debd .EndOfBlock ,BlackIs1 :_debd .BlackIs1 ,DamagedRowsBeforeError :_debd .DamagedRowsBeforeError ,Rows :_debd .Rows ,EncodedByteAlign :_debd .EncodedByteAlign };
return _abgfe .Encode (_abbb ),nil ;};func _cfbe (_ddfb *PdfObjectStream ,_edae *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};const _gffc =32<<(^uint (0)>>63);func _bedg (_dfggg ,_feed ,_fdca int )error {if _feed < 0||_feed > _dfggg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _fdca < _feed {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _fdca > _dfggg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// ParserMetadata gets the pdf parser metadata.
func (_bcb *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_bcb ._bgda {return ParserMetadata {},_dca .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _bcb ._dbcb ,nil ;};

// String returns a string describing `null`.
func (_gafdb *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func (_eade *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){_eade .skipSpaces ();const _cdd =20;_gege ,_ :=_eade ._gega .Peek (_cdd );
for _bebf :=0;_bebf < 2;_bebf ++{if _eade ._gdcf ==0{_eade ._gdcf =_eade .GetFileOffset ();};if _cfff .Match (_gege ){_cb .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_cb .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gege ));return _eade .parseXrefStream (nil );};if _acdd .Match (_gege ){_cb .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _eade .parseXrefTable ();};_gfee :=_eade .GetFileOffset ();if _eade ._gdcf ==0{_eade ._gdcf =_gfee ;};_eade .SetFileOffset (_gfee -_cdd );defer _eade .SetFileOffset (_gfee );_efgg ,_ :=_eade ._gega .Peek (_cdd );_gege =append (_efgg ,_gege ...);
};_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _effb :=_eade .repairSeekXrefMarker ();_effb !=nil {_cb .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_effb );return nil ,_effb ;};return _eade .parseXrefTable ();};const _gbabf =6;

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_gcbd *PdfParser )GetTrailer ()*PdfObjectDictionary {return _gcbd ._bga };

// WriteString outputs the object as it is to be written to file.
func (_ecbbg *PdfObjectDictionary )WriteString ()string {var _dafeb _gcd .Builder ;_dafeb .WriteString ("\u003c\u003c");for _ ,_gcfcb :=range _ecbbg ._edaeb {_bbga :=_ecbbg ._cgaag [_gcfcb ];_dafeb .WriteString (_gcfcb .WriteString ());_dafeb .WriteString ("\u0020");
_dafeb .WriteString (_bbga .WriteString ());};_dafeb .WriteString ("\u003e\u003e");return _dafeb .String ();};func (_aacc *PdfParser )parseXrefStream (_cfca *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _cfca !=nil {_cb .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_cfca );
_aacc ._ecgd .Seek (int64 (*_cfca ),_de .SeekStart );_aacc ._gega =_da .NewReader (_aacc ._ecgd );};_cbbfc :=_aacc .GetFileOffset ();_dfde ,_agagc :=_aacc .ParseIndirectObject ();if _agagc !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_cb .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dfde );
_gdcgg ,_eeda :=_dfde .(*PdfObjectStream );if !_eeda {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_egca :=_gdcgg .PdfObjectDictionary ;
_bfbb ,_eeda :=_gdcgg .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_eeda {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bfbb )> 8388607{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bfbb );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_acgac :=_gdcgg .PdfObjectDictionary .Get ("\u0057");_acfe ,_eeda :=_acgac .(*PdfObjectArray );if !_eeda {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_ggga :=_acfe .Len ();if _ggga !=3{_cb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_ggga );
return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _fbga []int64 ;for _dggc :=0;_dggc < 3;
_dggc ++{_cdgd ,_dbagb :=GetInt (_acfe .Get (_dggc ));if !_dbagb {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_fbga =append (_fbga ,int64 (*_cdgd ));};_feeeg ,_agagc :=DecodeStream (_gdcgg );
if _agagc !=nil {_cb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_agagc );return nil ,_agagc ;};_badfe :=int (_fbga [0]);
_ffea :=int (_fbga [0]+_fbga [1]);_adfg :=int (_fbga [0]+_fbga [1]+_fbga [2]);_deabf :=int (_fbga [0]+_fbga [1]+_fbga [2]);if _badfe < 0||_ffea < 0||_adfg < 0{_cb .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_badfe ,_ffea ,_adfg );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _deabf ==0{_cb .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _egca ,nil ;};_dfcb :=len (_feeeg )/_deabf ;_dfdeb :=0;_feea :=_gdcgg .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _bcdc []int ;if _feea !=nil {_cb .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_feea );_gfdeb ,_dcdca :=_feea .(*PdfObjectArray );
if !_dcdca {_cb .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _gfdeb .Len ()%2!=0{_cb .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dfdeb =0;_caeb ,_ccc :=_gfdeb .ToIntegerArray ();if _ccc !=nil {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_ccc );
return nil ,_ccc ;};for _ccge :=0;_ccge < len (_caeb );_ccge +=2{_cgga :=_caeb [_ccge ];_aceb :=_caeb [_ccge +1];for _acfeg :=0;_acfeg < _aceb ;_acfeg ++{_bcdc =append (_bcdc ,_cgga +_acfeg );};_dfdeb +=_aceb ;};}else {for _cbgf :=0;_cbgf < int (*_bfbb );
_cbgf ++{_bcdc =append (_bcdc ,_cbgf );};_dfdeb =int (*_bfbb );};if _dfcb ==_dfdeb +1{_cb .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_febag :=_dfdeb -1;for _ ,_dfce :=range _bcdc {if _dfce > _febag {_febag =_dfce ;};};_bcdc =append (_bcdc ,_febag +1);_dfdeb ++;};if _dfcb !=len (_bcdc ){_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_dfcb ,len (_bcdc ));
return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_cb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_dfdeb );
_cb .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_bcdc );_gdab :=func (_fggab []byte )int64 {var _bbaa int64 ;for _dgagg :=0;_dgagg < len (_fggab );_dgagg ++{_bbaa +=int64 (_fggab [_dgagg ])*(1<<uint (8*(len (_fggab )-_dgagg -1)));
};return _bbaa ;};_cb .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_feeeg ));_fffa :=0;for _aefd :=0;_aefd < len (_feeeg );_aefd +=_deabf {_acaa :=_bedg (len (_feeeg ),_aefd ,_aefd +_badfe );
if _acaa !=nil {_cb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acaa );return nil ,_acaa ;};_deda :=_feeeg [_aefd :_aefd +_badfe ];_acaa =_bedg (len (_feeeg ),_aefd +_badfe ,_aefd +_ffea );
if _acaa !=nil {_cb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acaa );return nil ,_acaa ;};_dbae :=_feeeg [_aefd +_badfe :_aefd +_ffea ];_acaa =_bedg (len (_feeeg ),_aefd +_ffea ,_aefd +_adfg );
if _acaa !=nil {_cb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_acaa );return nil ,_acaa ;};_fbgag :=_feeeg [_aefd +_ffea :_aefd +_adfg ];_gcgc :=_gdab (_deda );
_adbd :=_gdab (_dbae );_cfedg :=_gdab (_fbgag );if _fbga [0]==0{_gcgc =1;};if _fffa >=len (_bcdc ){_cb .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_cgaf :=_bcdc [_fffa ];_fffa ++;_cb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_cgaf ,_deda );_cb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_cgaf ,_dbae );_cb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_cgaf ,_fbgag );
_cb .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_cgaf ,_gcgc ,_adbd ,_cfedg );if _gcgc ==0{_cb .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _gcgc ==1{_cb .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dbae );if _adbd ==_cbbfc {_cb .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_cgaf ,_gdcgg .ObjectNumber );
_cgaf =int (_gdcgg .ObjectNumber );};if _debab ,_cafe :=_aacc ._fffef .ObjectMap [_cgaf ];!_cafe ||int (_cfedg )> _debab .Generation {_fdbd :=XrefObject {ObjectNumber :_cgaf ,XType :XrefTypeTableEntry ,Offset :_adbd ,Generation :int (_cfedg )};_aacc ._fffef .ObjectMap [_cgaf ]=_fdbd ;
};}else if _gcgc ==2{_cb .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_abdf :=_aacc ._fffef .ObjectMap [_cgaf ];!_abdf {_ggeac :=XrefObject {ObjectNumber :_cgaf ,XType :XrefTypeObjectStream ,OsObjNumber :int (_adbd ),OsObjIndex :int (_cfedg )};
_aacc ._fffef .ObjectMap [_cgaf ]=_ggeac ;_cb .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_ggeac );};}else {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _aacc ._cacf ==nil {_bdfa :=XrefTypeObjectStream ;_aacc ._cacf =&_bdfa ;};return _egca ,nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bfcc *PdfParser )IsAuthenticated ()bool {return _bfcc ._agf ._cba };

// GetXrefType returns the type of the first xref object (table or stream).
func (_bdggc *PdfParser )GetXrefType ()*xrefType {return _bdggc ._cacf };

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_eeefg :=_ed .NewReader ([]byte (txt ));_agcb :=&PdfParser {ObjCache :objectCache {},_ecgd :_eeefg ,_gega :_da .NewReader (_eeefg ),_baeb :int64 (len (txt )),_ccbe :map[int64 ]bool {},_gcgb :make (map[*PdfParser ]*PdfParser )};
_agcb ._fffef .ObjectMap =make (map[int ]XrefObject );return _agcb ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_agbgb :objects };};func (_bgbc *PdfParser )xrefNextObjectOffset (_abab int64 )int64 {_gfbad :=int64 (0);if len (_bgbc ._fffef .ObjectMap )==0{return 0;};if len (_bgbc ._fffef ._ge )==0{_cdde :=0;
for _ ,_gada :=range _bgbc ._fffef .ObjectMap {if _gada .Offset > 0{_cdde ++;};};if _cdde ==0{return 0;};_bgbc ._fffef ._ge =make ([]XrefObject ,_cdde );_ffeg :=0;for _ ,_dgdc :=range _bgbc ._fffef .ObjectMap {if _dgdc .Offset > 0{_bgbc ._fffef ._ge [_ffeg ]=_dgdc ;
_ffeg ++;};};_gg .Slice (_bgbc ._fffef ._ge ,func (_cbcbc ,_cgfe int )bool {return _bgbc ._fffef ._ge [_cbcbc ].Offset < _bgbc ._fffef ._ge [_cgfe ].Offset });};_facc :=_gg .Search (len (_bgbc ._fffef ._ge ),func (_aggga int )bool {return _bgbc ._fffef ._ge [_aggga ].Offset >=_abab });
if _facc < len (_bgbc ._fffef ._ge ){_gfbad =_bgbc ._fffef ._ge [_facc ].Offset ;};return _gfbad ;};var _eaff =_ec .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// Append appends PdfObject(s) to the streams.
func (_bfdd *PdfObjectStreams )Append (objects ...PdfObject ){if _bfdd ==nil {_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_bfdd ._agbgb =append (_bfdd ._agbgb ,objects ...);};func _bfgc (_gffd *PdfObjectStream ,_geca *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_fagfg :=NewCCITTFaxEncoder ();_dgca :=_gffd .PdfObjectDictionary ;if _dgca ==nil {return _fagfg ,nil ;
};if _geca ==nil {_dbbf :=TraceToDirectObject (_dgca .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dbbf !=nil {switch _dacg :=_dbbf .(type ){case *PdfObjectDictionary :_geca =_dacg ;case *PdfObjectArray :if _dacg .Len ()==1{if _gaedf ,_bcde :=GetDict (_dacg .Get (0));
_bcde {_geca =_gaedf ;};};default:_cb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dbbf );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _geca ==nil {_cb .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dbbf );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _ecgb ,_dfc :=GetNumberAsInt64 (_geca .Get ("\u004b"));_dfc ==nil {_fagfg .K =int (_ecgb );};if _cda ,_dabcc :=GetNumberAsInt64 (_geca .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_dabcc ==nil {_fagfg .Columns =int (_cda );}else {_fagfg .Columns =1728;
};if _ecbb ,_cfdbg :=GetNumberAsInt64 (_geca .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cfdbg ==nil {_fagfg .BlackIs1 =_ecbb > 0;}else {if _gabf ,_dge :=GetBoolVal (_geca .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dge {_fagfg .BlackIs1 =_gabf ;
}else {if _fddg ,_agbb :=GetArray (_geca .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_agbb {_dbcec ,_bcbf :=_fddg .ToIntegerArray ();if _bcbf ==nil {_fagfg .BlackIs1 =_dbcec [0]==1&&_dbcec [1]==0;};};};};if _aadb ,_dffe :=GetNumberAsInt64 (_geca .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_dffe ==nil {_fagfg .EncodedByteAlign =_aadb > 0;}else {if _eccbe ,_edcd :=GetBoolVal (_geca .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_edcd {_fagfg .EncodedByteAlign =_eccbe ;};};if _cfa ,_fdgge :=GetNumberAsInt64 (_geca .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_fdgge ==nil {_fagfg .EndOfLine =_cfa > 0;}else {if _dfba ,_abga :=GetBoolVal (_geca .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_abga {_fagfg .EndOfLine =_dfba ;};};if _dde ,_dbdf :=GetNumberAsInt64 (_geca .Get ("\u0052\u006f\u0077\u0073"));
_dbdf ==nil {_fagfg .Rows =int (_dde );};_fagfg .EndOfBlock =true ;if _dccd ,_edfe :=GetNumberAsInt64 (_geca .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edfe ==nil {_fagfg .EndOfBlock =_dccd > 0;}else {if _fdcg ,_ggd :=GetBoolVal (_geca .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_ggd {_fagfg .EndOfBlock =_fdcg ;};};if _gda ,_agac :=GetNumberAsInt64 (_geca .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_agac !=nil {_fagfg .DamagedRowsBeforeError =int (_gda );
};_cb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_geca .String ());return _fagfg ,nil ;};func (_bgdaa *PdfParser )parsePdfVersion ()(int ,int ,error ){var _dade int64 =20;_dcgd :=make ([]byte ,_dade );
_bgdaa ._ecgd .Seek (0,_de .SeekStart );_bgdaa ._ecgd .Read (_dcgd );var _eaeac error ;var _dcbac ,_ceeg int ;if _edbd :=_cgfg .FindStringSubmatch (string (_dcgd ));len (_edbd )< 3{if _dcbac ,_ceeg ,_eaeac =_bgdaa .seekPdfVersionTopDown ();_eaeac !=nil {_cb .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_eaeac ;};_bgdaa ._ecgd ,_eaeac =_eaf (_bgdaa ._ecgd ,_bgdaa .GetFileOffset ()-8);if _eaeac !=nil {return 0,0,_eaeac ;};}else {if _dcbac ,_eaeac =_f .Atoi (_edbd [1]);_eaeac !=nil {return 0,0,_eaeac ;};if _ceeg ,_eaeac =_f .Atoi (_edbd [2]);
_eaeac !=nil {return 0,0,_eaeac ;};_bgdaa .SetFileOffset (0);};_bgdaa ._gega =_da .NewReader (_bgdaa ._ecgd );_cb .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_dcbac ,_ceeg );return _dcbac ,_ceeg ,nil ;
};func (_ca *PdfParser )lookupByNumber (_fgd int ,_gdc bool )(PdfObject ,bool ,error ){_geb ,_adeg :=_ca .ObjCache [_fgd ];if _adeg {_cb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fgd );
return _geb ,false ,nil ;};if _ca ._dafe ==nil {_ca ._dafe =map[int ]bool {};};if _ca ._dafe [_fgd ]{_cb .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_fgd );
return nil ,false ,_g .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_ca ._dafe [_fgd ]=true ;defer delete (_ca ._dafe ,_fgd );
_egc ,_adeg :=_ca ._fffef .ObjectMap [_fgd ];if !_adeg {_cb .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _deae PdfObjectNull ;return &_deae ,false ,nil ;};_cb .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fgd );if _egc .XType ==XrefTypeTableEntry {_cb .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_egc .ObjectNumber );
_cb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_egc .Generation );_cb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_egc .Offset );_ca ._ecgd .Seek (_egc .Offset ,_de .SeekStart );
_ca ._gega =_da .NewReader (_ca ._ecgd );_dcg ,_eed :=_ca .ParseIndirectObject ();if _eed !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_eed );
if _gdc {_cb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_gaf ,_eec :=_ca .repairRebuildXrefsTopDown ();
if _eec !=nil {_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_eec );return nil ,false ,_eec ;};_ca ._fffef =*_gaf ;return _ca .lookupByNumber (_fgd ,false );
};return nil ,false ,_eed ;};if _gdc {_dcd ,_ ,_ :=_ggae (_dcg );if int (_dcd )!=_fgd {_cb .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_dae :=_ca .rebuildXrefTable ();
if _dae !=nil {return nil ,false ,_dae ;};_ca .ObjCache =objectCache {};return _ca .lookupByNumberWrapper (_fgd ,false );};};_cb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ca .ObjCache [_fgd ]=_dcg ;
return _dcg ,false ,nil ;}else if _egc .XType ==XrefTypeObjectStream {_cb .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_cb .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_cb .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_egc .OsObjNumber ,_egc .OsObjIndex );
if _egc .OsObjNumber ==_fgd {_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_dfg :=_ca ._fffef .ObjectMap [_egc .OsObjNumber ];_dfg {_gdf ,_cfb :=_ca .lookupObjectViaOS (_egc .OsObjNumber ,_fgd );if _cfb !=nil {_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_cfb );
return nil ,true ,_cfb ;};_cb .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ca .ObjCache [_fgd ]=_gdf ;if _ca ._agf !=nil {_ca ._agf ._cef [_gdf ]=true ;};return _gdf ,true ,nil ;};_cb .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetRevisionNumber returns the current version of the Pdf document.
func (_cafa *PdfParser )GetRevisionNumber ()int {return _cafa ._bbfb };

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_dgbbc *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dgbbc ._dcbf ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dgbbc ._dcbf [i ]=obj ;return nil ;};func (_gebdc *PdfParser )parseObject ()(PdfObject ,error ){_cb .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_gebdc .skipSpaces ();for {_dfbf ,_fbfg :=_gebdc ._gega .Peek (2);if _fbfg !=nil {if _fbfg !=_de .EOF ||len (_dfbf )==0{return nil ,_fbfg ;};if len (_dfbf )==1{_dfbf =append (_dfbf ,' ');};};_cb .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_dfbf ));
if _dfbf [0]=='/'{_aeeb ,_gdcdf :=_gebdc .parseName ();_cb .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_aeeb );return &_aeeb ,_gdcdf ;}else if _dfbf [0]=='('{_cb .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_cbgb ,_dccg :=_gebdc .parseString ();return _cbgb ,_dccg ;}else if _dfbf [0]=='['{_cb .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cedb ,_ecfe :=_gebdc .parseArray ();return _cedb ,_ecfe ;}else if (_dfbf [0]=='<')&&(_dfbf [1]=='<'){_cb .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_fecda ,_eadb :=_gebdc .ParseDict ();return _fecda ,_eadb ;}else if _dfbf [0]=='<'{_cb .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ecee ,_bdce :=_gebdc .parseHexString ();return _ecee ,_bdce ;}else if _dfbf [0]=='%'{_gebdc .readComment ();
_gebdc .skipSpaces ();}else {_cb .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_dfbf ,_ =_gebdc ._gega .Peek (15);_bcae :=string (_dfbf );_cb .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_bcae );
if (len (_bcae )> 3)&&(_bcae [:4]=="\u006e\u0075\u006c\u006c"){_debe ,_gbgae :=_gebdc .parseNull ();return &_debe ,_gbgae ;}else if (len (_bcae )> 4)&&(_bcae [:5]=="\u0066\u0061\u006cs\u0065"){_dcab ,_ceea :=_gebdc .parseBool ();return &_dcab ,_ceea ;}else if (len (_bcae )> 3)&&(_bcae [:4]=="\u0074\u0072\u0075\u0065"){_degeg ,_adbb :=_gebdc .parseBool ();
return &_degeg ,_adbb ;};_bebb :=_dcge .FindStringSubmatch (_bcae );if len (_bebb )> 1{_dfbf ,_ =_gebdc ._gega .ReadBytes ('R');_cb .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_dfbf [:]));_efcg ,_fbgg :=_acfg (string (_dfbf ));
_efcg ._fdbeb =_gebdc ;return &_efcg ,_fbgg ;};_fbaa :=_cdbef .FindStringSubmatch (_bcae );if len (_fbaa )> 1{_cb .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_eaae ,_ccag :=_gebdc .parseNumber ();return _eaae ,_ccag ;};
_fbaa =_adff .FindStringSubmatch (_bcae );if len (_fbaa )> 1{_cb .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_cb .Log .Trace ("\u0025\u0020\u0073",_fbaa );_acbe ,_gdcg :=_gebdc .parseNumber ();
return _acbe ,_gdcg ;};_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_bcae );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dce encryptDict ;_ebb _af .StdEncryptDict ;_eaeg string ;_ceef []byte ;_cef map[PdfObject ]bool ;_ffe map[PdfObject ]bool ;_cba bool ;_eede cryptFilters ;_gdce string ;_gfe string ;_aff *PdfParser ;_gca map[int ]struct{};};func (_fbed *PdfParser )parseName ()(PdfObjectName ,error ){var _aggf _ed .Buffer ;
_dcfe :=false ;for {_geef ,_dfab :=_fbed ._gega .Peek (1);if _dfab ==_de .EOF {break ;};if _dfab !=nil {return PdfObjectName (_aggf .String ()),_dfab ;};if !_dcfe {if _geef [0]=='/'{_dcfe =true ;_fbed ._gega .ReadByte ();}else if _geef [0]=='%'{_fbed .readComment ();
_fbed .skipSpaces ();}else {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_geef ,_geef );return PdfObjectName (_aggf .String ()),_dca .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_geef [0]);
};}else {if IsWhiteSpace (_geef [0]){break ;}else if (_geef [0]=='/')||(_geef [0]=='[')||(_geef [0]=='(')||(_geef [0]==']')||(_geef [0]=='<')||(_geef [0]=='>'){break ;}else if _geef [0]=='#'{_fcaf ,_dcbde :=_fbed ._gega .Peek (3);if _dcbde !=nil {return PdfObjectName (_aggf .String ()),_dcbde ;
};_febf ,_dcbde :=_cd .DecodeString (string (_fcaf [1:3]));if _dcbde !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_aggf .WriteByte ('#');_fbed ._gega .Discard (1);continue ;};_fbed ._gega .Discard (3);_aggf .Write (_febf );}else {_fdab ,_ :=_fbed ._gega .ReadByte ();_aggf .WriteByte (_fdab );};};};return PdfObjectName (_aggf .String ()),nil ;};func (_dcef *ASCII85Encoder )base256Tobase85 (_dbgg uint32 )[5]byte {_accga :=[5]byte {0,0,0,0,0};
_gfda :=_dbgg ;for _gcde :=0;_gcde < 5;_gcde ++{_abbe :=uint32 (1);for _ffgfc :=0;_ffgfc < 4-_gcde ;_ffgfc ++{_abbe *=85;};_ebf :=_gfda /_abbe ;_gfda =_gfda %_abbe ;_accga [_gcde ]=byte (_ebf );};return _accga ;};const JB2ImageAutoThreshold =-1.0;

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_cceb *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_cb .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_abcf :=MakeDict ();_abcf ._ecgbf =_cceb ;_aaba ,_ :=_cceb ._gega .ReadByte ();
if _aaba !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_aaba ,_ =_cceb ._gega .ReadByte ();if _aaba !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_cceb .skipSpaces ();_cceb .skipComments ();_dgfbe ,_dbbbc :=_cceb ._gega .Peek (2);if _dbbbc !=nil {return nil ,_dbbbc ;};_cb .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_dgfbe ),string (_dgfbe ));
if (_dgfbe [0]=='>')&&(_dgfbe [1]=='>'){_cb .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_cceb ._gega .ReadByte ();_cceb ._gega .ReadByte ();break ;};_cb .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_bgggc ,_dbbbc :=_cceb .parseName ();_cb .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_bgggc );if _dbbbc !=nil {_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dbbbc );
return nil ,_dbbbc ;};if len (_bgggc )> 4&&_bgggc [len (_bgggc )-4:]=="\u006e\u0075\u006c\u006c"{_gdaa :=_bgggc [0:len (_bgggc )-4];_cb .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_bgggc );
_cb .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_gdaa );_cceb .skipSpaces ();_dgbgc ,_ :=_cceb ._gega .Peek (1);if _dgbgc [0]=='/'{_abcf .Set (_gdaa ,MakeNull ());continue ;};};
_cceb .skipSpaces ();_fada ,_dbbbc :=_cceb .parseObject ();if _dbbbc !=nil {return nil ,_dbbbc ;};_abcf .Set (_bgggc ,_fada );if _cb .Log .IsLogLevel (_cb .LogLevelTrace ){_cb .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_bgggc ,_fada .String ());
};};_cb .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _abcf ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func _beec (_acce *PdfObjectStream )(*MultiEncoder ,error ){_adef :=NewMultiEncoder ();
_deg :=_acce .PdfObjectDictionary ;if _deg ==nil {return _adef ,nil ;};var _acdc *PdfObjectDictionary ;var _gfdae []PdfObject ;_agad :=_deg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _agad !=nil {_ggbf ,_fdgf :=_agad .(*PdfObjectDictionary );
if _fdgf {_acdc =_ggbf ;};_cbcc ,_bgce :=_agad .(*PdfObjectArray );if _bgce {for _ ,_ecfc :=range _cbcc .Elements (){_ecfc =TraceToDirectObject (_ecfc );if _gbff ,_fbca :=_ecfc .(*PdfObjectDictionary );_fbca {_gfdae =append (_gfdae ,_gbff );}else {_gfdae =append (_gfdae ,MakeDict ());
};};};};_agad =_deg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _agad ==nil {return nil ,_dca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_gcga ,_eadg :=_agad .(*PdfObjectArray );if !_eadg {return nil ,_dca .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _gfcb ,_dcbb :=range _gcga .Elements (){_fcf ,_becb :=_dcbb .(*PdfObjectName );if !_becb {return nil ,_dca .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _aegeb PdfObject ;if _acdc !=nil {_aegeb =_acdc ;}else {if len (_gfdae )> 0{if _gfcb >=len (_gfdae ){return nil ,_dca .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_aegeb =_gfdae [_gfcb ];};};var _fgeg *PdfObjectDictionary ;if _edfc ,_affad :=_aegeb .(*PdfObjectDictionary );_affad {_fgeg =_edfc ;};_cb .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_fcf ,_aegeb ,_fgeg );
if *_fcf ==StreamEncodingFilterNameFlate {_dfae ,_bcdb :=_fed (_acce ,_fgeg );if _bcdb !=nil {return nil ,_bcdb ;};_adef .AddEncoder (_dfae );}else if *_fcf ==StreamEncodingFilterNameLZW {_caedd ,_cgg :=_cbgd (_acce ,_fgeg );if _cgg !=nil {return nil ,_cgg ;
};_adef .AddEncoder (_caedd );}else if *_fcf ==StreamEncodingFilterNameASCIIHex {_efeg :=NewASCIIHexEncoder ();_adef .AddEncoder (_efeg );}else if *_fcf ==StreamEncodingFilterNameASCII85 {_bgb :=NewASCII85Encoder ();_adef .AddEncoder (_bgb );}else if *_fcf ==StreamEncodingFilterNameDCT {_faaa ,_gee :=_cfdc (_acce ,_adef );
if _gee !=nil {return nil ,_gee ;};_adef .AddEncoder (_faaa );_cb .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_cb .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_adef );
}else if *_fcf ==StreamEncodingFilterNameCCITTFax {_dcgf ,_fegc :=_bfgc (_acce ,_fgeg );if _fegc !=nil {return nil ,_fegc ;};_adef .AddEncoder (_dcgf );}else {_cb .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_fcf );
return nil ,_dca .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _adef ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _edaad (o ,0,traversed );};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_fdae []byte ,_ffab bool ){_deffb ,_ffab :=TraceToDirectObject (obj ).(*PdfObjectString );if _ffab {return _deffb .Bytes (),true ;};return ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egbf *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func _aeebd (_ggdad int )int {if _ggdad < 0{return -_ggdad ;};return _ggdad ;};

// GetFilterName returns the name of the encoding filter.
func (_eebe *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// GetFilterName returns the name of the encoding filter.
func (_ecg *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_efed *_db .Document ;

// Globals are the JBIG2 global segments.
Globals _dea .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dcbdf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dcbdf .PdfObjectDictionary =encoder .MakeStreamDict ();_cdcg ,_cbeab :=encoder .EncodeBytes (contents );
if _cbeab !=nil {return nil ,_cbeab ;};_dcbdf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cdcg ))));_dcbdf .Stream =_cdcg ;return _dcbdf ,nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_afe *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _afe .isDecrypted (obj ){return nil ;};switch _dfbg :=obj .(type ){case *PdfIndirectObject :_afe ._cef [_dfbg ]=true ;_cb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_dfbg .ObjectNumber ,_dfbg .GenerationNumber );
_efda :=_dfbg .ObjectNumber ;_eda :=_dfbg .GenerationNumber ;_cgbd :=_afe .Decrypt (_dfbg .PdfObject ,_efda ,_eda );if _cgbd !=nil {return _cgbd ;};return nil ;case *PdfObjectStream :_afe ._cef [_dfbg ]=true ;_bcea :=_dfbg .PdfObjectDictionary ;if _afe ._ebb .R !=5{if _cfc ,_fcgg :=_bcea .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_fcgg &&*_cfc =="\u0058\u0052\u0065\u0066"{return nil ;};};_ccb :=_dfbg .ObjectNumber ;_eaa :=_dfbg .GenerationNumber ;_cb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ccb ,_eaa );
_fffc :=_cfeg ;if _afe ._dce .V >=4{_fffc =_afe ._gdce ;_cb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_afe ._gdce );if _fef ,_cdbe :=_bcea .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cdbe {if _gafe ,_aga :=GetName (_fef .Get (0));_aga {if *_gafe =="\u0043\u0072\u0079p\u0074"{_fffc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aaac ,_cec :=_bcea .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_cec {if _bbc ,_gaed :=_aaac .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gaed {if _ ,_decb :=_afe ._eede [string (*_bbc )];_decb {_cb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bbc );
_fffc =string (*_bbc );};};};};};};_cb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fffc );if _fffc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_adgd :=_afe .Decrypt (_bcea ,_ccb ,_eaa );
if _adgd !=nil {return _adgd ;};_aaeg ,_adgd :=_afe .makeKey (_fffc ,uint32 (_ccb ),uint32 (_eaa ),_afe ._ceef );if _adgd !=nil {return _adgd ;};_dfbg .Stream ,_adgd =_afe .decryptBytes (_dfbg .Stream ,_fffc ,_aaeg );if _adgd !=nil {return _adgd ;};_bcea .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dfbg .Stream ))));
return nil ;case *PdfObjectString :_cb .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gff :=_cfeg ;if _afe ._dce .V >=4{_cb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_afe ._gfe );
if _afe ._gfe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gff =_afe ._gfe ;};_ddb ,_gac :=_afe .makeKey (_gff ,uint32 (parentObjNum ),uint32 (parentGenNum ),_afe ._ceef );if _gac !=nil {return _gac ;};_edc :=_dfbg .Str ();_acd :=make ([]byte ,len (_edc ));
for _add :=0;_add < len (_edc );_add ++{_acd [_add ]=_edc [_add ];};if len (_acd )> 0{_cb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_acd ,_acd );
_acd ,_gac =_afe .decryptBytes (_acd ,_gff ,_ddb );if _gac !=nil {return _gac ;};};_dfbg ._fdgged =string (_acd );return nil ;case *PdfObjectArray :for _ ,_affa :=range _dfbg .Elements (){_bbfe :=_afe .Decrypt (_affa ,parentObjNum ,parentGenNum );if _bbfe !=nil {return _bbfe ;
};};return nil ;case *PdfObjectDictionary :_fega :=false ;if _bgg :=_dfbg .Get ("\u0054\u0079\u0070\u0065");_bgg !=nil {_dfa ,_agc :=_bgg .(*PdfObjectName );if _agc &&*_dfa =="\u0053\u0069\u0067"{_fega =true ;};};for _ ,_fbf :=range _dfbg .Keys (){_ffd :=_dfbg .Get (_fbf );
if _fega &&string (_fbf )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fbf )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fbf )!="\u0050\u0072\u0065\u0076"&&string (_fbf )!="\u004c\u0061\u0073\u0074"{_eccb :=_afe .Decrypt (_ffd ,parentObjNum ,parentGenNum );
if _eccb !=nil {return _eccb ;};};};return nil ;};return nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_abgaf *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_abgaf .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_ddgb *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_bab *PdfCrypt )isEncrypted (_ffec PdfObject )bool {_ ,_fcb :=_bab ._ffe [_ffec ];if _fcb {_cb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_cb .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_eabe *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cb .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_cb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eabe .Predictor );
_cbae ,_addag :=_eabe .DecodeBytes (streamObj .Stream );if _addag !=nil {return nil ,_addag ;};_cb .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_cb .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_cbae ),_cbae );
if _eabe .Predictor > 1{if _eabe .Predictor ==2{_cb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bea :=_eabe .Columns *_eabe .Colors ;if _bea < 1{return []byte {},nil ;};_bedd :=len (_cbae )/_bea ;if len (_cbae )%_bea !=0{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbae ),_bea );};if _bea %_eabe .Colors !=0{return nil ,_dca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_bea ,_eabe .Colors );
};if _bea > len (_cbae ){_cb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bea ,len (_cbae ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cbae ),_cbae );
_abb :=_ed .NewBuffer (nil );for _acea :=0;_acea < _bedd ;_acea ++{_fgff :=_cbae [_bea *_acea :_bea *(_acea +1)];for _gagc :=_eabe .Colors ;_gagc < _bea ;_gagc ++{_fgff [_gagc ]=byte (int (_fgff [_gagc ]+_fgff [_gagc -_eabe .Colors ])%256);};_abb .Write (_fgff );
};_fac :=_abb .Bytes ();_cb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fac ),_fac );return _fac ,nil ;}else if _eabe .Predictor >=10&&_eabe .Predictor <=15{_cb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_dace :=_eabe .Columns *_eabe .Colors +1;if _dace < 1{return []byte {},nil ;};_bac :=len (_cbae )/_dace ;if len (_cbae )%_dace !=0{return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbae ),_dace );
};if _dace > len (_cbae ){_cb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dace ,len (_cbae ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_afef :=_ed .NewBuffer (nil );_cb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_eabe .Columns );
_cb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cbae ),_dace ,_bac );_abef :=make ([]byte ,_dace );for _eff :=0;_eff < _dace ;_eff ++{_abef [_eff ]=0;};for _fgbb :=0;
_fgbb < _bac ;_fgbb ++{_cbfa :=_cbae [_dace *_fgbb :_dace *(_fgbb +1)];_fda :=_cbfa [0];switch _fda {case 0:case 1:for _dbce :=2;_dbce < _dace ;_dbce ++{_cbfa [_dbce ]=byte (int (_cbfa [_dbce ]+_cbfa [_dbce -1])%256);};case 2:for _addc :=1;_addc < _dace ;
_addc ++{_cbfa [_addc ]=byte (int (_cbfa [_addc ]+_abef [_addc ])%256);};default:_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fda );
return nil ,_dca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fda );};for _edce :=0;_edce < _dace ;_edce ++{_abef [_edce ]=_cbfa [_edce ];};_afef .Write (_cbfa [1:]);
};_bbee :=_afef .Bytes ();return _bbee ,nil ;}else {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_eabe .Predictor );
return nil ,_dca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_eabe .Predictor );};};return _cbae ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cdgf *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_cag :=MakeDict ();_cag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cdgf .GetFilterName ()));_cdef :=_cdgf .MakeDecodeParams ();if _cdef !=nil {_cag .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cdef );
};_cag .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cdgf .EarlyChange )));return _cag ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_eaec *JBIG2Encoder )EncodeImage (img _c .Image )([]byte ,error ){return _eaec .encodeImage (img )};func _cbgd (_edeg *PdfObjectStream ,_cceg *PdfObjectDictionary )(*LZWEncoder ,error ){_gbb :=NewLZWEncoder ();_ddf :=_edeg .PdfObjectDictionary ;if _ddf ==nil {return _gbb ,nil ;
};if _cceg ==nil {_dadc :=TraceToDirectObject (_ddf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dadc !=nil {if _gfd ,_dgdg :=_dadc .(*PdfObjectDictionary );_dgdg {_cceg =_gfd ;}else if _fea ,_aeg :=_dadc .(*PdfObjectArray );
_aeg {if _fea .Len ()==1{if _cbeg ,_gfff :=GetDict (_fea .Get (0));_gfff {_cceg =_cbeg ;};};};if _cceg ==nil {_cb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dadc );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_cge :=_ddf .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _cge !=nil {_abed ,_egff :=_cge .(*PdfObjectInteger );
if !_egff {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_cge );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_abed !=0&&*_abed !=1{return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_gbb .EarlyChange =int (*_abed );}else {_gbb .EarlyChange =1;};if _cceg ==nil {return _gbb ,nil ;};if _faee ,_edaa :=GetIntVal (_cceg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_edaa {if _faee ==0||_faee ==1{_gbb .EarlyChange =_faee ;
}else {_cb .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_faee );};};_cge =_cceg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _cge !=nil {_bdgg ,_dac :=_cge .(*PdfObjectInteger );if !_dac {_cb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cge );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gbb .Predictor =int (*_bdgg );};_cge =_cceg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _cge !=nil {_aeee ,_ccfa :=_cge .(*PdfObjectInteger );if !_ccfa {_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_dca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gbb .BitsPerComponent =int (*_aeee );};if _gbb .Predictor > 1{_gbb .Columns =1;_cge =_cceg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _cge !=nil {_cbfc ,_cbcb :=_cge .(*PdfObjectInteger );if !_cbcb {return nil ,_dca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gbb .Columns =int (*_cbfc );
};_gbb .Colors =1;_cge =_cceg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cge !=nil {_fgg ,_ecf :=_cge .(*PdfObjectInteger );if !_ecf {return nil ,_dca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_gbb .Colors =int (*_fgg );};};_cb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cceg .String ());return _gbb ,nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_daage :=MakeArray ();for _ ,_cbff :=range vals {_daage .Append (MakeInteger (_cbff ));};return _daage ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abge *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dgcb *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ffef _c .Image ;if _dgcb .ColorComponents ==1&&_dgcb .BitsPerComponent ==8{_ffef =&_c .Gray {Rect :_c .Rect (0,0,_dgcb .Width ,_dgcb .Height ),Pix :data ,Stride :_eg .BytesPerLine (_dgcb .Width ,_dgcb .BitsPerComponent ,_dgcb .ColorComponents )};
}else {var _dbag error ;_ffef ,_dbag =_eg .NewImage (_dgcb .Width ,_dgcb .Height ,_dgcb .BitsPerComponent ,_dgcb .ColorComponents ,data ,nil ,nil );if _dbag !=nil {return nil ,_dbag ;};};_fbfb :=_ab .Options {};_fbfb .Quality =_dgcb .Quality ;var _fga _ed .Buffer ;
if _eabf :=_ab .Encode (&_fga ,_ffef ,&_fbfb );_eabf !=nil {return nil ,_eabf ;};return _fga .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cdfa *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// WriteString outputs the object as it is to be written to file.
func (_abfea *PdfIndirectObject )WriteString ()string {var _bbae _gcd .Builder ;_bbae .WriteString (_f .FormatInt (_abfea .ObjectNumber ,10));_bbae .WriteString ("\u0020\u0030\u0020\u0052");return _bbae .String ();};

// GetFilterName returns the name of the encoding filter.
func (_geg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_dc .Model ;Bounds ()_c .Rectangle ;At (_dbbb ,_fbd int )_dc .Color ;Set (_ecbc ,_fafg int ,_faea _dc .Color );};type objectStream struct{N int ;_abc []byte ;_dd map[int ]int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_addab *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cb .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fecdg ,_efgfb :=NewEncoderFromStream (streamObj );if _efgfb !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_efgfb );
return nil ,_efgfb ;};_cb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_fecdg );_egede ,_efgfb :=_fecdg .DecodeStream (streamObj );if _efgfb !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_efgfb );
return nil ,_efgfb ;};return _egede ,nil ;};func (_ebbf *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ebbf ._fffef .ObjectMap =make (map[int ]XrefObject );_ebbf ._aeab =make (objectStreams );_gegda ,_eafb :=_ebbf ._ecgd .Seek (0,_de .SeekEnd );
if _eafb !=nil {return nil ,_eafb ;};_cb .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_gegda );_ebbf ._baeb =_gegda ;_eafb =_ebbf .seekToEOFMarker (_gegda );if _eafb !=nil {_cb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_eafb );
return nil ,_eafb ;};_gabd ,_eafb :=_ebbf ._ecgd .Seek (0,_de .SeekCurrent );if _eafb !=nil {return nil ,_eafb ;};var _bdeg int64 =64;_ffba :=_gabd -_bdeg ;if _ffba < 0{_ffba =0;};_ ,_eafb =_ebbf ._ecgd .Seek (_ffba ,_de .SeekStart );if _eafb !=nil {return nil ,_eafb ;
};_fecdc :=make ([]byte ,_bdeg );_ ,_eafb =_ebbf ._ecgd .Read (_fecdc );if _eafb !=nil {_cb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_eafb );
return nil ,_eafb ;};_bdcd :=_gfge .FindStringSubmatch (string (_fecdc ));if len (_bdcd )< 2{_cb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};if len (_bdcd )> 2{_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_fecdc );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");
};_bgge ,_ :=_f .ParseInt (_bdcd [1],10,64);_cb .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_bgge );if _bgge > _gegda {_cb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");
_cb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_bgge ,_eafb =_ebbf .repairLocateXref ();if _eafb !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_eafb ;};};_ebbf ._ecgd .Seek (_bgge ,_de .SeekStart );_ebbf ._gega =_da .NewReader (_ebbf ._ecgd );_fffdd ,_eafb :=_ebbf .parseXref ();if _eafb !=nil {return nil ,_eafb ;};_gdgd :=_fffdd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _gdgd !=nil {_cegb ,_cced :=_gdgd .(*PdfObjectInteger );
if !_cced {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_eafb =_ebbf .parseXrefStream (_cegb );if _eafb !=nil {return nil ,_eafb ;};};var _acgc []int64 ;_faab :=func (_ggbg int64 ,_bgdbg []int64 )bool {for _ ,_fgba :=range _bgdbg {if _fgba ==_ggbg {return true ;
};};return false ;};_gdgd =_fffdd .Get ("\u0050\u0072\u0065\u0076");for _gdgd !=nil {_fcff ,_fccag :=_gdgd .(*PdfObjectInteger );if !_fccag {_cb .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_gdgd );
return _fffdd ,nil ;};_fde :=*_fcff ;_cb .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_fde );_ebbf ._ecgd .Seek (int64 (_fde ),_de .SeekStart );
_ebbf ._gega =_da .NewReader (_ebbf ._ecgd );_ebgd ,_faeb :=_ebbf .parseXref ();if _faeb !=nil {_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_cb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_ebbf ._aadfg =append (_ebbf ._aadfg ,int64 (_fde ));
_gdgd =_ebgd .Get ("\u0050\u0072\u0065\u0076");if _gdgd !=nil {_bfeeg :=*(_gdgd .(*PdfObjectInteger ));if _faab (int64 (_bfeeg ),_acgc ){_cb .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_acgc =append (_acgc ,int64 (_bfeeg ));};};return _fffdd ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ccac *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_gfgc :=PdfIndirectObject {};_gfgc ._fdbeb =_ccac ;_cb .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_dacga ,_dadce :=_ccac ._gega .Peek (20);
if _dadce !=nil {if _dadce !=_de .EOF {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_gfgc ,_dadce ;
};};_cb .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dacga ));_dafb :=_cfff .FindStringSubmatchIndex (string (_dacga ));if len (_dafb )< 6{if _dadce ==_de .EOF {return nil ,_dadce ;
};_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dacga ));
return &_gfgc ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ccac ._gega .Discard (_dafb [0]);_cb .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_dafb );_gaedg :=_dafb [1]-_dafb [0];_gcade :=make ([]byte ,_gaedg );_ ,_dadce =_ccac .ReadAtLeast (_gcade ,_gaedg );if _dadce !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dadce );
return nil ,_dadce ;};_cb .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gcade );_beba :=_cfff .FindStringSubmatch (string (_gcade ));if len (_beba )< 3{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcade ));
return &_gfgc ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_afdf ,_ :=_f .Atoi (_beba [1]);_cfdf ,_ :=_f .Atoi (_beba [2]);_gfgc .ObjectNumber =int64 (_afdf );_gfgc .GenerationNumber =int64 (_cfdf );for {_bfaeb ,_ecfad :=_ccac ._gega .Peek (2);if _ecfad !=nil {return &_gfgc ,_ecfad ;};_cb .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bfaeb ),string (_bfaeb ));
if IsWhiteSpace (_bfaeb [0]){_ccac .skipSpaces ();}else if _bfaeb [0]=='%'{_ccac .skipComments ();}else if (_bfaeb [0]=='<')&&(_bfaeb [1]=='<'){_cb .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_gfgc .PdfObject ,_ecfad =_ccac .ParseDict ();
_cb .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_ecfad );if _ecfad !=nil {return &_gfgc ,_ecfad ;};_cb .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_bfaeb [0]=='/')||(_bfaeb [0]=='(')||(_bfaeb [0]=='[')||(_bfaeb [0]=='<'){_gfgc .PdfObject ,_ecfad =_ccac .parseObject ();if _ecfad !=nil {return &_gfgc ,_ecfad ;};_cb .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _bfaeb [0]==']'{_cb .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_ccac ._gega .Discard (1);}else {if _bfaeb [0]=='e'{_addg ,_gaeg :=_ccac .readTextLine ();if _gaeg !=nil {return nil ,_gaeg ;};if len (_addg )>=6&&_addg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bfaeb [0]=='s'{_bfaeb ,_ =_ccac ._gega .Peek (10);
if string (_bfaeb [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_bbaca :=6;if len (_bfaeb )> 6{if IsWhiteSpace (_bfaeb [_bbaca ])&&_bfaeb [_bbaca ]!='\r'&&_bfaeb [_bbaca ]!='\n'{_cb .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_ccac ._dbcb ._eea =true ;_bbaca ++;};if _bfaeb [_bbaca ]=='\r'{_bbaca ++;if _bfaeb [_bbaca ]=='\n'{_bbaca ++;};}else if _bfaeb [_bbaca ]=='\n'{_bbaca ++;}else {_ccac ._dbcb ._eea =true ;};};_ccac ._gega .Discard (_bbaca );_adgf ,_ddcaf :=_gfgc .PdfObject .(*PdfObjectDictionary );
if !_ddcaf {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_adgf );
_ebba ,_cebb :=_ccac .traceStreamLength (_adgf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _cebb !=nil {_cb .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_cebb );
return nil ,_cebb ;};_cb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ebba );_bdeb ,_bbffg :=_ebba .(*PdfObjectInteger );if !_bbffg {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_fcef :=*_bdeb ;if _fcef < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bgaf :=_ccac .GetFileOffset ();
_debb :=_ccac .xrefNextObjectOffset (_bgaf );if _bgaf +int64 (_fcef )> _debb &&_debb > _bgaf {_cb .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bgaf +int64 (_fcef ));_cb .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_debb );
_efea :=_debb -_bgaf -17;if _efea < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_cb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_efea );_fcef =PdfObjectInteger (_efea );
_adgf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_efea ));};if int64 (_fcef )> _ccac ._baeb {_cb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cfede :=make ([]byte ,_fcef );
_ ,_cebb =_ccac .ReadAtLeast (_cfede ,int (_fcef ));if _cebb !=nil {_cb .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cfede ),_cfede );_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cebb );
return nil ,_cebb ;};_ecd :=PdfObjectStream {};_ecd .Stream =_cfede ;_ecd .PdfObjectDictionary =_gfgc .PdfObject .(*PdfObjectDictionary );_ecd .ObjectNumber =_gfgc .ObjectNumber ;_ecd .GenerationNumber =_gfgc .GenerationNumber ;_ecd .PdfObjectReference ._fdbeb =_ccac ;
_ccac .skipSpaces ();_ccac ._gega .Discard (9);_ccac .skipSpaces ();return &_ecd ,nil ;};};_gfgc .PdfObject ,_ecfad =_ccac .parseObject ();if _gfgc .PdfObject ==nil {_cb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_gfgc .PdfObject =MakeNull ();};return &_gfgc ,_ecfad ;};};if _gfgc .PdfObject ==nil {_cb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_gfgc .PdfObject =MakeNull ();};_cb .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_gfgc ,nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_aabc bool ,_debfe bool ){_ceec ,_debfe :=TraceToDirectObject (obj ).(*PdfObjectBool );if _debfe {return bool (*_ceec ),true ;};return false ,false ;};func (_bfgcf *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_ddab ,_bddda :=_bfgcf ._ecgd .Seek (0,_de .SeekEnd );
if _bddda !=nil {return nil ,_bddda ;};var _abfd int64 ;var _efba int64 =2048;for _abfd < _ddab -4{if _ddab <=(_efba +_abfd ){_efba =_ddab -_abfd ;};_ ,_agbac :=_bfgcf ._ecgd .Seek (_abfd ,_de .SeekStart );if _agbac !=nil {return nil ,_agbac ;};_ccfae :=make ([]byte ,_efba );
_ ,_agbac =_bfgcf ._ecgd .Read (_ccfae );if _agbac !=nil {return nil ,_agbac ;};_cb .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_ccfae ));
_gcdb :=_cfff .FindAllStringIndex (string (_ccfae ),-1);if _gcdb !=nil {_ggda :=_gcdb [0];_cb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gcdb );_ ,_bbad :=_bfgcf ._ecgd .Seek (int64 (_ggda [0]),_de .SeekStart );if _bbad !=nil {return nil ,_bbad ;
};_bfgcf ._gega =_da .NewReader (_bfgcf ._ecgd );_bgaa ,_bbad :=_bfgcf .ParseIndirectObject ();if _bbad !=nil {return nil ,nil ;};if _egddg ,_dafd :=GetIndirect (_bgaa );_dafd {if _dcfd ,_agfc :=GetDict (_egddg .PdfObject );_agfc {if _cacc :=_dcfd .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_cacc !=nil {return _dcfd ,nil ;};return nil ,nil ;};};return nil ,nil ;};_abfd +=_efba -4;};return nil ,_g .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_gcac *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dcac :=_ed .NewReader (encoded );var _aaga []byte ;for {_badb ,_eeca :=_dcac .ReadByte ();if _eeca !=nil {return nil ,_eeca ;};if _badb > 128{_dcacd ,_ffc :=_dcac .ReadByte ();
if _ffc !=nil {return nil ,_ffc ;};for _feag :=0;_feag < 257-int (_badb );_feag ++{_aaga =append (_aaga ,_dcacd );};}else if _badb < 128{for _bgfd :=0;_bgfd < int (_badb )+1;_bgfd ++{_edgb ,_fbee :=_dcac .ReadByte ();if _fbee !=nil {return nil ,_fbee ;
};_aaga =append (_aaga ,_edgb );};}else {break ;};};return _aaga ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_adda *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cb .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_cgbc :=_ed .NewReader (encoded );_edag ,_fefa :=_fc .NewReader (_cgbc );if _fefa !=nil {_cb .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fefa );_cb .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_fefa ;};defer _edag .Close ();var _efaa _ed .Buffer ;_efaa .ReadFrom (_edag );return _efaa .Bytes (),nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cccf *PdfIndirectObject ,_ggdf bool ){obj =ResolveReference (obj );_cccf ,_ggdf =obj .(*PdfIndirectObject );return _cccf ,_ggdf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aacg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_ecbce :=MakeDict ();_ecbce .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_aacg .GetFilterArray ());for _ ,_deadc :=range _aacg ._dbeg {_geeg :=_deadc .MakeStreamDict ();for _ ,_dege :=range _geeg .Keys (){_fegd :=_geeg .Get (_dege );
if _dege !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_dege !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_ecbce .Set (_dege ,_fegd );};};};_acdge :=_aacg .MakeDecodeParams ();if _acdge !=nil {_ecbce .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_acdge );
};return _ecbce ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_dbdfa *MultiEncoder )AddEncoder (encoder StreamEncoder ){_dbdfa ._dbeg =append (_dbdfa ._dbeg ,encoder );};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_ffacd *PdfParser )Decrypt (password []byte )(bool ,error ){if _ffacd ._agf ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fbec ,_agca :=_ffacd ._agf .authenticate (password );
if _agca !=nil {return false ,_agca ;};if !_fbec {_fbec ,_agca =_ffacd ._agf .authenticate ([]byte (""));};return _fbec ,_agca ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_geeb :=PdfObjectNull {};return &_geeb };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_becbe int ,_gfcd bool ){_bffc ,_gfcd :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _gfcd &&_bffc !=nil {return int (*_bffc ),true ;};return 0,false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cga *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// UpdateParams updates the parameter values of the encoder.
func (_fcge *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dccgc *PdfObjectString ,_gffed bool ){_dccgc ,_gffed =TraceToDirectObject (obj ).(*PdfObjectString );return _dccgc ,_gffed ;};func (_adcbb *PdfParser )seekToEOFMarker (_bgca int64 )error {var _bebda int64 ;var _bafa int64 =2048;
for _bebda < _bgca -4{if _bgca <=(_bafa +_bebda ){_bafa =_bgca -_bebda ;};_ ,_gdbd :=_adcbb ._ecgd .Seek (_bgca -_bebda -_bafa ,_de .SeekStart );if _gdbd !=nil {return _gdbd ;};_deee :=make ([]byte ,_bafa );_adcbb ._ecgd .Read (_deee );_cb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_deee ));
_dcdb :=_eaff .FindAllStringIndex (string (_deee ),-1);if _dcdb !=nil {_eedg :=_dcdb [len (_dcdb )-1];_cb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dcdb );_fbad :=_bgca -_bebda -_bafa +int64 (_eedg [0]);_adcbb ._ecgd .Seek (_fbad ,_de .SeekStart );
return nil ;};_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_bebda +=_bafa -4;};_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _fefb ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdff *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gfbd *JBIG2Encoder )DecodeGlobals (encoded []byte )(_dea .Globals ,error ){return _dea .DecodeGlobals (encoded );};var _cdbef =_ec .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");
func (_baga *FlateEncoder )postDecodePredict (_edea []byte )([]byte ,error ){if _baga .Predictor > 1{if _baga .Predictor ==2{_cb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cb .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_baga .Colors );
_fec :=_baga .Columns *_baga .Colors ;if _fec < 1{return []byte {},nil ;};_dbdd :=len (_edea )/_fec ;if len (_edea )%_fec !=0{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_edea ),_fec );};if _fec %_baga .Colors !=0{return nil ,_dca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fec ,_baga .Colors );
};if _fec > len (_edea ){_cb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fec ,len (_edea ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_edea ),_edea );
_dbga :=_ed .NewBuffer (nil );for _cfea :=0;_cfea < _dbdd ;_cfea ++{_eced :=_edea [_fec *_cfea :_fec *(_cfea +1)];for _dcc :=_baga .Colors ;_dcc < _fec ;_dcc ++{_eced [_dcc ]+=_eced [_dcc -_baga .Colors ];};_dbga .Write (_eced );};_dcaa :=_dbga .Bytes ();
_cb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dcaa ),_dcaa );return _dcaa ,nil ;}else if _baga .Predictor >=10&&_baga .Predictor <=15{_cb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_bcdd :=_baga .Columns *_baga .Colors +1;_fdd :=len (_edea )/_bcdd ;if len (_edea )%_bcdd !=0{return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_edea ),_bcdd );
};if _bcdd > len (_edea ){_cb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bcdd ,len (_edea ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aeeg :=_ed .NewBuffer (nil );_cb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_baga .Columns );
_cb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_edea ),_bcdd ,_fdd );_fdgg :=make ([]byte ,_bcdd );for _cede :=0;_cede < _bcdd ;_cede ++{_fdgg [_cede ]=0;
};_accg :=_baga .Colors ;for _gedb :=0;_gedb < _fdd ;_gedb ++{_ddbb :=_edea [_bcdd *_gedb :_bcdd *(_gedb +1)];_bagb :=_ddbb [0];switch _bagb {case _gfga :case _fgfc :for _ggge :=1+_accg ;_ggge < _bcdd ;_ggge ++{_ddbb [_ggge ]+=_ddbb [_ggge -_accg ];};case _egee :for _ggee :=1;
_ggee < _bcdd ;_ggee ++{_ddbb [_ggee ]+=_fdgg [_ggee ];};case _cgdb :for _bdg :=1;_bdg < _accg +1;_bdg ++{_ddbb [_bdg ]+=_fdgg [_bdg ]/2;};for _fedb :=_accg +1;_fedb < _bcdd ;_fedb ++{_ddbb [_fedb ]+=byte ((int (_ddbb [_fedb -_accg ])+int (_fdgg [_fedb ]))/2);
};case _abgd :for _cebfg :=1;_cebfg < _bcdd ;_cebfg ++{var _cffa ,_bffa ,_cfega byte ;_bffa =_fdgg [_cebfg ];if _cebfg >=_accg +1{_cffa =_ddbb [_cebfg -_accg ];_cfega =_fdgg [_cebfg -_accg ];};_ddbb [_cebfg ]+=_faeeg (_cffa ,_bffa ,_cfega );};default:_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_bagb ,_gedb );
return nil ,_dca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bagb );};copy (_fdgg ,_ddbb );_aeeg .Write (_ddbb [1:]);};_efgbe :=_aeeg .Bytes ();return _efgbe ,nil ;
}else {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_baga .Predictor );return nil ,_dca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_baga .Predictor );
};};return _edea ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ebdd :=&PdfIndirectObject {};_ebdd .PdfObject =obj ;return _ebdd ;};

// DecodeStream implements ASCII hex decoding.
func (_fcbbg *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fcbbg .DecodeBytes (streamObj .Stream );};

// HeaderCommentBytes gets the header comment bytes.
func (_ddcc ParserMetadata )HeaderCommentBytes ()[4]byte {return _ddcc ._aafg };

// WriteString outputs the object as it is to be written to file.
func (_egcb *PdfObjectStreams )WriteString ()string {var _agcd _gcd .Builder ;_agcd .WriteString (_f .FormatInt (_egcb .ObjectNumber ,10));_agcd .WriteString ("\u0020\u0030\u0020\u0052");return _agcd .String ();};

// Append appends PdfObject(s) to the array.
func (_dacd *PdfObjectArray )Append (objects ...PdfObject ){if _dacd ==nil {_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_dacd ._dcbf =append (_dacd ._dcbf ,objects ...);};func _gec (_dec *_af .StdEncryptDict ,_feb *PdfObjectDictionary ){_feb .Set ("\u0052",MakeInteger (int64 (_dec .R )));_feb .Set ("\u0050",MakeInteger (int64 (_dec .P )));_feb .Set ("\u004f",MakeStringFromBytes (_dec .O ));
_feb .Set ("\u0055",MakeStringFromBytes (_dec .U ));if _dec .R >=5{_feb .Set ("\u004f\u0045",MakeStringFromBytes (_dec .OE ));_feb .Set ("\u0055\u0045",MakeStringFromBytes (_dec .UE ));_feb .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_dec .EncryptMetadata ));
if _dec .R > 5{_feb .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_dec .Perms ));};};};const _bebfc =10;

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_fccg *PdfObjectStream ,_ceeb bool ){obj =ResolveReference (obj );_fccg ,_ceeb =obj .(*PdfObjectStream );return _fccg ,_ceeb ;};const (DefaultJPEGQuality =75;);

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_bdaa :=MakeArray ();for _ ,_dagc :=range vals {_bdaa .Append (MakeFloat (_dagc ));};return _bdaa ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_dbba :=&ASCII85Encoder {};return _dbba };var _aefaa _e .Map ;

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_eegb *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_geae :=data ;var _acf error ;for _aebc :=len (_eegb ._dbeg )-1;_aebc >=0;_aebc --{_ebcf :=_eegb ._dbeg [_aebc ];_geae ,_acf =_ebcf .EncodeBytes (_geae );if _acf !=nil {return nil ,_acf ;
};};return _geae ,nil ;};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_ded ParserMetadata )HasEOLAfterHeader ()bool {return _ded ._acc };

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_daef ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _daef ._fgdc };

// WriteString outputs the object as it is to be written to file.
func (_cccd *PdfObjectName )WriteString ()string {var _dfgf _ed .Buffer ;if len (*_cccd )> 127{_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cccd );};_dfgf .WriteString ("\u002f");
for _ddbg :=0;_ddbg < len (*_cccd );_ddbg ++{_adac :=(*_cccd )[_ddbg ];if !IsPrintable (_adac )||_adac =='#'||IsDelimiter (_adac ){_dfgf .WriteString (_dca .Sprintf ("\u0023\u0025\u002e2\u0078",_adac ));}else {_dfgf .WriteByte (_adac );};};return _dfgf .String ();
};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_dccf :=PdfObjectFloat (val );return &_dccf };func (_dfcg *limitedReadSeeker )getError (_dfaec int64 )error {switch {case _dfaec < 0:return _dca .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_dfaec );
case _dfaec > _dfcg ._cbad :return _dca .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_dfaec );};return nil ;};func _acfg (_ecfac string )(PdfObjectReference ,error ){_ffbc :=PdfObjectReference {};
_cdcf :=_dcge .FindStringSubmatch (_ecfac );if len (_cdcf )< 3{_cb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _ffbc ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};_cea ,_ :=_f .Atoi (_cdcf [1]);_bbfg ,_ :=_f .Atoi (_cdcf [2]);_ffbc .ObjectNumber =int64 (_cea );_ffbc .GenerationNumber =int64 (_bbfg );return _ffbc ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_aagcb *PdfObjectBool ,_egdf bool ){_aagcb ,_egdf =TraceToDirectObject (obj ).(*PdfObjectBool );return _aagcb ,_egdf ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_efdb :=MakeArray ();for _ ,_bcgba :=range vals {_efdb .Append (MakeInteger (int64 (_bcgba )));};return _efdb ;};func (_fede *PdfParser )readTextLine ()(string ,error ){var _cbd _ed .Buffer ;for {_afcab ,_cgdg :=_fede ._gega .Peek (1);
if _cgdg !=nil {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cgdg .Error ());return _cbd .String (),_cgdg ;};if (_afcab [0]!='\r')&&(_afcab [0]!='\n'){_efdac ,_ :=_fede ._gega .ReadByte ();_cbd .WriteByte (_efdac );}else {break ;
};};return _cbd .String (),nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_gfbe *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _gaegg []float64 ;for _ ,_gfad :=range _gfbe .Elements (){_eggf ,_gaafc :=GetNumberAsFloat (TraceToDirectObject (_gfad ));if _gaafc !=nil {return nil ,_dca .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_gaegg =append (_gaegg ,_eggf );};return _gaegg ,nil ;};func (_gccga *PdfParser )skipSpaces ()(int ,error ){_beda :=0;for {_gefc ,_aagc :=_gccga ._gega .ReadByte ();if _aagc !=nil {return 0,_aagc ;};if IsWhiteSpace (_gefc ){_beda ++;}else {_gccga ._gega .UnreadByte ();
break ;};};return _beda ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_cfbdd *PdfParser )GetXrefOffset ()int64 {return _cfbdd ._gdcf };

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func _bggb (_bgfb PdfObject ,_ffbb int )PdfObject {if _ffbb > _bebfc {_cb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bebfc );
return MakeNull ();};switch _acbd :=_bgfb .(type ){case *PdfIndirectObject :_bgfb =_bggb ((*_acbd ).PdfObject ,_ffbb +1);case *PdfObjectArray :for _fcafd ,_bgbg :=range (*_acbd )._dcbf {(*_acbd )._dcbf [_fcafd ]=_bggb (_bgbg ,_ffbb +1);};case *PdfObjectDictionary :for _abcg ,_adfag :=range (*_acbd )._cgaag {(*_acbd )._cgaag [_abcg ]=_bggb (_adfag ,_ffbb +1);
};_gg .Slice ((*_acbd )._edaeb ,func (_babg ,_cbfbd int )bool {return (*_acbd )._edaeb [_babg ]< (*_acbd )._edaeb [_cbfbd ]});};return _bgfb ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_fcfb string ,_bcdca bool ){_caccb ,_bcdca :=TraceToDirectObject (obj ).(*PdfObjectString );if _bcdca {return _caccb .Str (),true ;};return ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_gb *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_deb ,_gf :=obj .(*PdfObjectReference );if !_gf {return obj ,nil ;};_efe :=_gb .GetFileOffset ();defer func (){_gb .SetFileOffset (_efe )}();_bg ,_ege :=_gb .LookupByReference (*_deb );if _ege !=nil {return nil ,_ege ;
};_cfe ,_gbc :=_bg .(*PdfIndirectObject );if !_gbc {return _bg ,nil ;};_bg =_cfe .PdfObject ;_ ,_gf =_bg .(*PdfObjectReference );if _gf {return _cfe ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _bg ,nil ;};

// HasNonConformantStream implements core.ParserMetadata.
func (_dgc ParserMetadata )HasNonConformantStream ()bool {return _dgc ._eea };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_beeca string ,_cggb bool ){_bfce ,_cggb :=TraceToDirectObject (obj ).(*PdfObjectName );if _cggb {return string (*_bfce ),true ;};return ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _bggb (obj ,0)};func _bebad (_bdbfg ,_gagg PdfObject ,_cbfb int )bool {if _cbfb > _bebfc {_cb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bebfc );
return false ;};if _bdbfg ==nil &&_gagg ==nil {return true ;}else if _bdbfg ==nil ||_gagg ==nil {return false ;};if _gc .TypeOf (_bdbfg )!=_gc .TypeOf (_gagg ){return false ;};switch _acfd :=_bdbfg .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_acfd ==*(_gagg .(*PdfObjectName ));case *PdfObjectString :return *_acfd ==*(_gagg .(*PdfObjectString ));case *PdfObjectInteger :return *_acfd ==*(_gagg .(*PdfObjectInteger ));case *PdfObjectBool :return *_acfd ==*(_gagg .(*PdfObjectBool ));
case *PdfObjectFloat :return *_acfd ==*(_gagg .(*PdfObjectFloat ));case *PdfIndirectObject :return _bebad (TraceToDirectObject (_bdbfg ),TraceToDirectObject (_gagg ),_cbfb +1);case *PdfObjectArray :_dcdd :=_gagg .(*PdfObjectArray );if len ((*_acfd )._dcbf )!=len ((*_dcdd )._dcbf ){return false ;
};for _edbae ,_dceba :=range (*_acfd )._dcbf {if !_bebad (_dceba ,(*_dcdd )._dcbf [_edbae ],_cbfb +1){return false ;};};return true ;case *PdfObjectDictionary :_gdaf :=_gagg .(*PdfObjectDictionary );_cfdbc ,_acbbd :=(*_acfd )._cgaag ,(*_gdaf )._cgaag ;
if len (_cfdbc )!=len (_acbbd ){return false ;};for _cgc ,_ecae :=range _cfdbc {_geced ,_dcga :=_acbbd [_cgc ];if !_dcga ||!_bebad (_ecae ,_geced ,_cbfb +1){return false ;};};return true ;case *PdfObjectStream :_eecg :=_gagg .(*PdfObjectStream );return _bebad ((*_acfd ).PdfObjectDictionary ,(*_eecg ).PdfObjectDictionary ,_cbfb +1);
default:_cb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_bdbfg );
};return false ;};func (_bcff *offsetReader )Read (p []byte )(_gfaf int ,_gdd error ){return _bcff ._bcbe .Read (p )};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bfdcg *PdfObjectName ,_gcagc bool ){_bfdcg ,_gcagc =TraceToDirectObject (obj ).(*PdfObjectName );return _bfdcg ,_gcagc ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_faafa *PdfObjectStreams )Elements ()[]PdfObject {if _faafa ==nil {return nil ;};return _faafa ._agbgb ;};func (_ggde *PdfParser )rebuildXrefTable ()error {_aeec :=XrefTable {};_aeec .ObjectMap =map[int ]XrefObject {};_dged :=make ([]int ,0,len (_ggde ._fffef .ObjectMap ));
for _gddg :=range _ggde ._fffef .ObjectMap {_dged =append (_dged ,_gddg );};_gg .Ints (_dged );for _ ,_bafd :=range _dged {_gcdc :=_ggde ._fffef .ObjectMap [_bafd ];_cggbd ,_ ,_ddcec :=_ggde .lookupByNumberWrapper (_bafd ,false );if _ddcec !=nil {_cb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ddcec );
_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_gdfd ,_eega :=_ggde .repairRebuildXrefsTopDown ();if _eega !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_eega );
return _eega ;};_ggde ._fffef =*_gdfd ;_cb .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_faeg ,_bcee ,_ddcec :=_ggae (_cggbd );if _ddcec !=nil {return _ddcec ;
};_gcdc .ObjectNumber =int (_faeg );_gcdc .Generation =int (_bcee );_aeec .ObjectMap [int (_faeg )]=_gcdc ;};_ggde ._fffef =_aeec ;_cb .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_be (_ggde ._fffef );
return nil ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// String returns a string describing `stream`.
func (_bbfeg *PdfObjectStream )String ()string {return _dca .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_bbfeg .ObjectNumber ,_bbfeg .PdfObjectDictionary );};func (_beaf *PdfObjectInteger )String ()string {return _dca .Sprintf ("\u0025\u0064",*_beaf )};
const (_gfga =0;_fgfc =1;_egee =2;_cgdb =3;_abgd =4;);

// UpdateParams updates the parameter values of the encoder.
func (_ebdg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bfga ,_bgdb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bgdb ==nil {_ebdg .Predictor =int (_bfga );};_fgdg ,_bgdb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _bgdb ==nil {_ebdg .BitsPerComponent =int (_fgdg );};_fgcc ,_bgdb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bgdb ==nil {_ebdg .Columns =int (_fgcc );};_faac ,_bgdb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _bgdb ==nil {_ebdg .Colors =int (_faac );};_dbfd ,_bgdb :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bgdb ==nil {_ebdg .EarlyChange =int (_dbfd );};};func (_ebae *PdfParser )parseArray ()(*PdfObjectArray ,error ){_badf :=MakeArray ();
_ebae ._gega .ReadByte ();for {_ebae .skipSpaces ();_gebcg ,_bdff :=_ebae ._gega .Peek (1);if _bdff !=nil {return _badf ,_bdff ;};if _gebcg [0]==']'{_ebae ._gega .ReadByte ();break ;};_effa ,_bdff :=_ebae .parseObject ();if _bdff !=nil {return _badf ,_bdff ;
};_badf .Append (_effa );};return _badf ,nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_fddd :=MultiEncoder {};_fddd ._dbeg =[]StreamEncoder {};return &_fddd ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_eabg *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _eabg .Predictor !=1{return nil ,_dca .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _eabg .EarlyChange ==1{return nil ,_dca .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _eadd _ed .Buffer ;_gecd :=_abe .NewWriter (&_eadd ,_abe .MSB ,8);_gecd .Write (data );_gecd .Close ();return _eadd .Bytes (),nil ;};var _dcge =_ec .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gffg :=&PdfObjectDictionary {};_gffg ._cgaag =map[PdfObjectName ]PdfObject {};_gffg ._edaeb =[]PdfObjectName {};_gffg ._fbcc =&_e .Mutex {};return _gffg ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_gggc *JBIG2Image )ToGoImage ()(_c .Image ,error ){const _aece ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _gggc .Data ==nil {return nil ,_ace .Error (_aece ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _gggc .Width ==0||_gggc .Height ==0{return nil ,_ace .Error (_aece ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_ffac ,_acag :=_eg .NewImage (_gggc .Width ,_gggc .Height ,1,1,_gggc .Data ,nil ,nil );if _acag !=nil {return nil ,_acag ;};return _ffac ,nil ;};func _feefd (_ccbd _de .ReadSeeker ,_beabc int64 )(*limitedReadSeeker ,error ){_ ,_fbbb :=_ccbd .Seek (0,_de .SeekStart );
if _fbbb !=nil {return nil ,_fbbb ;};return &limitedReadSeeker {_fecf :_ccbd ,_cbad :_beabc },nil ;};func (_ebfc *PdfParser )repairLocateXref ()(int64 ,error ){_deecd :=int64 (1000);_ebfc ._ecgd .Seek (-_deecd ,_de .SeekCurrent );_eeeab ,_cfgd :=_ebfc ._ecgd .Seek (0,_de .SeekCurrent );
if _cfgd !=nil {return 0,_cfgd ;};_dgcc :=make ([]byte ,_deecd );_ebfc ._ecgd .Read (_dgcc );_dfaf :=_fgab .FindAllStringIndex (string (_dgcc ),-1);if len (_dfaf )< 1{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_adadg :=int64 (_dfaf [len (_dfaf )-1][0]);_caca :=_eeeab +_adadg ;return _caca ,nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_afefa :=TraceToDirectObject (obj ).(*PdfObjectNull );return _afefa ;};func (_gbag *PdfParser )inspect ()(map[string ]int ,error ){_cb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_cb .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_degb :=map[string ]int {};_fbaae :=0;_cccb :=0;var _ffegg []int ;for _babb :=range _gbag ._fffef .ObjectMap {_ffegg =append (_ffegg ,_babb );};_gg .Ints (_ffegg );_eggdd :=0;
for _ ,_beabg :=range _ffegg {_dcbdb :=_gbag ._fffef .ObjectMap [_beabg ];if _dcbdb .ObjectNumber ==0{continue ;};_fbaae ++;_cb .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_cb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_dcbdb .ObjectNumber );
_gecb ,_egbg :=_gbag .LookupByNumber (_dcbdb .ObjectNumber );if _egbg !=nil {_cb .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_dcbdb .ObjectNumber ,_egbg );
_cccb ++;continue ;};_cb .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_gecb );_geac ,_geaf :=_gecb .(*PdfIndirectObject );if _geaf {_cb .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_dcbdb .ObjectNumber ,_geac );
_agggab ,_bdcgg :=_geac .PdfObject .(*PdfObjectDictionary );if _bdcgg {if _adffb ,_eceg :=_agggab .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eceg {_ccbda :=string (*_adffb );_cb .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ccbda );
_ ,_afgba :=_degb [_ccbda ];if _afgba {_degb [_ccbda ]++;}else {_degb [_ccbda ]=1;};}else if _bfca ,_geegb :=_agggab .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_geegb {_gafb :=string (*_bfca );_cb .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_gafb );
_ ,_debbf :=_degb [_gafb ];if _debbf {_degb [_gafb ]++;}else {_degb [_gafb ]=1;};};if _cfcae ,_cdgg :=_agggab .Get ("\u0053").(*PdfObjectName );_cdgg &&*_cfcae =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_abdef :=_degb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _abdef {_degb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_degb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _addf ,_ccacb :=_gecb .(*PdfObjectStream );_ccacb {if _gcce ,_fbdb :=_addf .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_fbdb {_cb .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_gcce );_ggaeg :=string (*_gcce );_degb [_ggaeg ]++;};}else {_acbb ,_adcfc :=_gecb .(*PdfObjectDictionary );
if _adcfc {_ceecg ,_fcafe :=_acbb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fcafe {_cbabd :=string (*_ceecg );_cb .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_cbabd );_degb [_cbabd ]++;};
};_cb .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_dcbdb .ObjectNumber ,_gecb );};_eggdd ++;};_cb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_cb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_cb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_fbaae );_cb .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_cccb );
for _aafa ,_cfdab :=range _degb {_cb .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_aafa ,_cfdab );};_cb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_gbag ._fffef .ObjectMap )< 1{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_dca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_egaf ,_gbaab :=_degb ["\u0046\u006f\u006e\u0074"];
if !_gbaab ||_egaf < 2{_cb .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_cb .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _degb ,nil ;};func (_dgba *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dgba ._gega .ReadByte ();var _fgga _ed .Buffer ;for {_afaf ,_gccb :=_dgba ._gega .Peek (1);if _gccb !=nil {return MakeString (""),_gccb ;};if _afaf [0]=='>'{_dgba ._gega .ReadByte ();
break ;};_bbcb ,_ :=_dgba ._gega .ReadByte ();if _dgba ._bgda {if _ed .IndexByte (_fgfcb ,_bbcb )==-1{_dgba ._dbcb ._bbe =true ;};};if !IsWhiteSpace (_bbcb ){_fgga .WriteByte (_bbcb );};};if _fgga .Len ()%2==1{_dgba ._dbcb ._ceda =true ;_fgga .WriteRune ('0');
};_ecbf ,_ :=_cd .DecodeString (_fgga .String ());return MakeHexString (string (_ecbf )),nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_gacdg *PdfObjectString )Str ()string {return _gacdg ._fdgged };

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_gag :=&LZWEncoder {};_gag .Predictor =1;_gag .BitsPerComponent =8;_gag .Colors =1;_gag .Columns =1;_gag .EarlyChange =1;return _gag ;};func _afcg (_ecfab _eg .Image )*JBIG2Image {_gbge :=_ecfab .Base ();return &JBIG2Image {Data :_gbge .Data ,Width :_gbge .Width ,Height :_gbge .Height ,HasPadding :true };
};

// WriteString outputs the object as it is to be written to file.
func (_aebd *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bca *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_eagdg *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gdcd _ed .Buffer ;_bdec :=_ed .NewReader (encoded );var _agg _de .ReadCloser ;if _eagdg .EarlyChange ==1{_agg =_dab .NewReader (_bdec ,_dab .MSB ,8);}else {_agg =_abe .NewReader (_bdec ,_abe .MSB ,8);
};defer _agg .Close ();if _ ,_ecfa :=_gdcd .ReadFrom (_agg );_ecfa !=nil {if _ecfa !=_de .ErrUnexpectedEOF ||_gdcd .Len ()==0{return nil ,_ecfa ;};_cb .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ecfa );
};return _gdcd .Bytes (),nil ;};

// String returns a string representation of the *PdfObjectString.
func (_gdbe *PdfObjectString )String ()string {return _gdbe ._fdgged };func _ffgf (_edfg _ad .Filter ,_fff _af .AuthEvent )*PdfObjectDictionary {if _fff ==""{_fff =_af .EventDocOpen ;};_gfb :=MakeDict ();_gfb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_gfb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fff )));_gfb .Set ("\u0043\u0046\u004d",MakeName (_edfg .Name ()));_gfb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_edfg .KeyLength ())));return _gfb ;};


// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_adcd *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adcd .DecodeBytes (streamObj .Stream );};func (_bbacc *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_bbacc ._ecgd .Seek (0,_de .SeekStart );_bbacc ._gega =_da .NewReader (_bbacc ._ecgd );
_ccagd :=20;_gacdf :=make ([]byte ,_ccagd );for {_aabe ,_ccad :=_bbacc ._gega .ReadByte ();if _ccad !=nil {if _ccad ==_de .EOF {break ;}else {return 0,0,_ccad ;};};if IsDecimalDigit (_aabe )&&_gacdf [_ccagd -1]=='.'&&IsDecimalDigit (_gacdf [_ccagd -2])&&_gacdf [_ccagd -3]=='-'&&_gacdf [_ccagd -4]=='F'&&_gacdf [_ccagd -5]=='D'&&_gacdf [_ccagd -6]=='P'{_aedb :=int (_gacdf [_ccagd -2]-'0');
_abbg :=int (_aabe -'0');return _aedb ,_abbg ,nil ;};_gacdf =append (_gacdf [1:_ccagd ],_aabe );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_cffcd :=PdfObjectInteger (val );return &_cffcd };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_da .Reader )(PdfObject ,error ){_eacfd :=false ;_bebgg :=true ;var _ddfgc _ed .Buffer ;for {if _cb .Log .IsLogLevel (_cb .LogLevelTrace ){_cb .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ddfgc .String ());
};_gbbc ,_bebfa :=buf .Peek (1);if _bebfa ==_de .EOF {break ;};if _bebfa !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_bebfa );return nil ,_bebfa ;};if _bebgg &&(_gbbc [0]=='-'||_gbbc [0]=='+'){_egea ,_ :=buf .ReadByte ();
_ddfgc .WriteByte (_egea );_bebgg =false ;}else if IsDecimalDigit (_gbbc [0]){_adedf ,_ :=buf .ReadByte ();_ddfgc .WriteByte (_adedf );}else if _gbbc [0]=='.'{_dcce ,_ :=buf .ReadByte ();_ddfgc .WriteByte (_dcce );_eacfd =true ;}else if _gbbc [0]=='e'||_gbbc [0]=='E'{_bfea ,_ :=buf .ReadByte ();
_ddfgc .WriteByte (_bfea );_eacfd =true ;_bebgg =true ;}else {break ;};};var _baba PdfObject ;if _eacfd {_egedb ,_cagf :=_f .ParseFloat (_ddfgc .String (),64);if _cagf !=nil {_cb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ddfgc .String (),_cagf );
_egedb =0.0;};_gacg :=PdfObjectFloat (_egedb );_baba =&_gacg ;}else {_acda ,_gecc :=_f .ParseInt (_ddfgc .String (),10,64);if _gecc !=nil {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ddfgc .String (),_gecc );
_acda =0;};_abfa :=PdfObjectInteger (_acda );_baba =&_abfa ;};return _baba ,nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_cb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_acfb ,_fdad :=NewEncoderFromStream (streamObj );if _fdad !=nil {_cb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fdad );
return _fdad ;};if _afdfe ,_afgd :=_acfb .(*LZWEncoder );_afgd {_afdfe .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_cb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_acfb );
_cbfeg ,_fdad :=_acfb .EncodeBytes (streamObj .Stream );if _fdad !=nil {_cb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fdad );return _fdad ;
};streamObj .Stream =_cbfeg ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbfeg ))));return nil ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;
EFF string ;CF map[string ]_ad .FilterDict ;};

// String returns the state of the bool as "true" or "false".
func (_fbcgg *PdfObjectBool )String ()string {if *_fbcgg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_gbeg *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bfae ,_bcba :=_b .NewDecoder (encoded ,_b .DecodeOptions {Columns :_gbeg .Columns ,Rows :_gbeg .Rows ,K :_gbeg .K ,EncodedByteAligned :_gbeg .EncodedByteAlign ,BlackIsOne :_gbeg .BlackIs1 ,EndOfBlock :_gbeg .EndOfBlock ,EndOfLine :_gbeg .EndOfLine ,DamagedRowsBeforeError :_gbeg .DamagedRowsBeforeError });
if _bcba !=nil {return nil ,_bcba ;};_baeae ,_bcba :=_fd .ReadAll (_bfae );if _bcba !=nil {return nil ,_bcba ;};return _baeae ,nil ;};func (_cefcf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cefcf ._ccdb {return nil ,_dca .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_cefcf ._ccdb =true ;_cefcf ._ecgd .Seek (0,_de .SeekStart );_cefcf ._gega =_da .NewReader (_cefcf ._ecgd );_babd :=20;_ffbed :=make ([]byte ,_babd );_cgdd :=XrefTable {};_cgdd .ObjectMap =make (map[int ]XrefObject );for {_gafdd ,_gaag :=_cefcf ._gega .ReadByte ();
if _gaag !=nil {if _gaag ==_de .EOF {break ;}else {return nil ,_gaag ;};};if _gafdd =='j'&&_ffbed [_babd -1]=='b'&&_ffbed [_babd -2]=='o'&&IsWhiteSpace (_ffbed [_babd -3]){_gbad :=_babd -4;for IsWhiteSpace (_ffbed [_gbad ])&&_gbad > 0{_gbad --;};if _gbad ==0||!IsDecimalDigit (_ffbed [_gbad ]){continue ;
};for IsDecimalDigit (_ffbed [_gbad ])&&_gbad > 0{_gbad --;};if _gbad ==0||!IsWhiteSpace (_ffbed [_gbad ]){continue ;};for IsWhiteSpace (_ffbed [_gbad ])&&_gbad > 0{_gbad --;};if _gbad ==0||!IsDecimalDigit (_ffbed [_gbad ]){continue ;};for IsDecimalDigit (_ffbed [_gbad ])&&_gbad > 0{_gbad --;
};if _gbad ==0{continue ;};_eedgd :=_cefcf .GetFileOffset ()-int64 (_babd -_gbad );_cegg :=append (_ffbed [_gbad +1:],_gafdd );_cebg ,_dfgg ,_febc :=_cdefe (string (_cegg ));if _febc !=nil {_cb .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_febc );
return nil ,_febc ;};if _ecdb ,_fface :=_cgdd .ObjectMap [_cebg ];!_fface ||_ecdb .Generation < _dfgg {_dgbd :=XrefObject {};_dgbd .XType =XrefTypeTableEntry ;_dgbd .ObjectNumber =_cebg ;_dgbd .Generation =_dfgg ;_dgbd .Offset =_eedgd ;_cgdd .ObjectMap [_cebg ]=_dgbd ;
};};_ffbed =append (_ffbed [1:_babd ],_gafdd );};_cefcf ._dafe =nil ;return &_cgdd ,nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_cfdce :=PdfObjectName (s );return &_cfdce };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dega *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_eegd :=MakeDict ();_eegd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dega .GetFilterName ()));return _eegd ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ecfec *PdfObjectDictionary ,_dcabb bool ){_ecfec ,_dcabb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ecfec ,_dcabb ;};func _bgbbf (_acad PdfObject )(*float64 ,error ){switch _abea :=_acad .(type ){case *PdfObjectFloat :_bbef :=float64 (*_abea );
return &_bbef ,nil ;case *PdfObjectInteger :_gfab :=float64 (*_abea );return &_gfab ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func _ggae (_dfeb PdfObject )(int64 ,int64 ,error ){if _cc ,_aaea :=_dfeb .(*PdfIndirectObject );_aaea {return _cc .ObjectNumber ,_cc .GenerationNumber ,nil ;};if _adb ,_ceb :=_dfeb .(*PdfObjectStream );_ceb {return _adb .ObjectNumber ,_adb .GenerationNumber ,nil ;
};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_fagf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fagf .DecodeBytes (streamObj .Stream );};func (_abbd *PdfParser )parseString ()(*PdfObjectString ,error ){_abbd ._gega .ReadByte ();var _abde _ed .Buffer ;_bfdc :=1;
for {_dgag ,_eeef :=_abbd ._gega .Peek (1);if _eeef !=nil {return MakeString (_abde .String ()),_eeef ;};if _dgag [0]=='\\'{_abbd ._gega .ReadByte ();_fdfc ,_cdgfa :=_abbd ._gega .ReadByte ();if _cdgfa !=nil {return MakeString (_abde .String ()),_cdgfa ;
};if IsOctalDigit (_fdfc ){_efee ,_agdg :=_abbd ._gega .Peek (2);if _agdg !=nil {return MakeString (_abde .String ()),_agdg ;};var _dbddc []byte ;_dbddc =append (_dbddc ,_fdfc );for _ ,_gaff :=range _efee {if IsOctalDigit (_gaff ){_dbddc =append (_dbddc ,_gaff );
}else {break ;};};_abbd ._gega .Discard (len (_dbddc )-1);_cb .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dbddc );_acga ,_agdg :=_f .ParseUint (string (_dbddc ),8,32);if _agdg !=nil {return MakeString (_abde .String ()),_agdg ;
};_abde .WriteByte (byte (_acga ));continue ;};switch _fdfc {case 'n':_abde .WriteRune ('\n');case 'r':_abde .WriteRune ('\r');case 't':_abde .WriteRune ('\t');case 'b':_abde .WriteRune ('\b');case 'f':_abde .WriteRune ('\f');case '(':_abde .WriteRune ('(');
case ')':_abde .WriteRune (')');case '\\':_abde .WriteRune ('\\');};continue ;}else if _dgag [0]=='('{_bfdc ++;}else if _dgag [0]==')'{_bfdc --;if _bfdc ==0{_abbd ._gega .ReadByte ();break ;};};_efde ,_ :=_abbd ._gega .ReadByte ();_abde .WriteByte (_efde );
};return MakeString (_abde .String ()),nil ;};func (_gcfca *PdfObjectFloat )String ()string {return _dca .Sprintf ("\u0025\u0066",*_gcfca )};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _gdec :=obj .(type ){case *PdfObjectFloat :_cb .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_gdec ),nil ;case *PdfObjectInteger :return int64 (*_gdec ),nil ;case *PdfObjectReference :_fccc :=TraceToDirectObject (obj );return GetNumberAsInt64 (_fccc );case *PdfIndirectObject :return GetNumberAsInt64 (_gdec .PdfObject );};return 0,ErrNotANumber ;
};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_eeac []float64 ,_gaaa error ){for _ ,_dbffa :=range objects {_afcae ,_gffe :=GetNumberAsFloat (_dbffa );if _gffe !=nil {return nil ,_gffe ;};_eeac =append (_eeac ,_afcae );};return _eeac ,nil ;};

// SetImage sets the image base for given flate encoder.
func (_dba *FlateEncoder )SetImage (img *_eg .ImageBase ){_dba ._adbc =img };

// Elements returns a slice of the PdfObject elements in the array.
func (_cgde *PdfObjectArray )Elements ()[]PdfObject {if _cgde ==nil {return nil ;};return _cgde ._dcbf ;};

// UpdateParams updates the parameter values of the encoder.
func (_feba *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _gfae ,_eedc :=obj .(*PdfObjectReference );_eedc {obj =_gfae .Resolve ();};_fcgag ,_ddgbb :=obj .(*PdfIndirectObject );_bfda :=0;for _ddgbb {obj =_fcgag .PdfObject ;_fcgag ,_ddgbb =GetIndirect (obj );
_bfda ++;if _bfda > _bebfc {_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_bebfc );
return nil ;};};return obj ;};func _fegg (_cbaea *PdfObjectStream ,_bbgf *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _efgf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_beee :=NewJBIG2Encoder ();_fbcg :=_cbaea .PdfObjectDictionary ;if _fbcg ==nil {return _beee ,nil ;};if _bbgf ==nil {_gbabb :=_fbcg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gbabb !=nil {switch _bdbf :=_gbabb .(type ){case *PdfObjectDictionary :_bbgf =_bdbf ;
case *PdfObjectArray :if _bdbf .Len ()==1{if _bcac ,_abdg :=GetDict (_bdbf .Get (0));_abdg {_bbgf =_bcac ;};};default:_cb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_gbabb );
return nil ,_ace .Errorf (_efgf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bdbf );};};};if _bbgf ==nil {return _beee ,nil ;};_beee .UpdateParams (_bbgf );
_eee ,_gfde :=GetStream (_bbgf .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_gfde {return _beee ,nil ;};var _gfed error ;_beee .Globals ,_gfed =_dea .DecodeGlobals (_eee .Stream );if _gfed !=nil {_gfed =_ace .Wrap (_gfed ,_efgf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gfed );return nil ,_gfed ;};return _beee ,nil ;};

// Seek implementation of Seek interface.
func (_addd *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _fdga int64 ;switch whence {case _de .SeekStart :_fdga =offset ;case _de .SeekCurrent :_bdbfc ,_dgce :=_addd ._fecf .Seek (0,_de .SeekCurrent );if _dgce !=nil {return 0,_dgce ;
};_fdga =_bdbfc +offset ;case _de .SeekEnd :_fdga =_addd ._cbad +offset ;};if _fecc :=_addd .getError (_fdga );_fecc !=nil {return 0,_fecc ;};if _ ,_gccg :=_addd ._fecf .Seek (_fdga ,_de .SeekStart );_gccg !=nil {return 0,_gccg ;};return _fdga ,nil ;};


// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gadff *PdfObjectArray )Get (i int )PdfObject {if _gadff ==nil ||i >=len (_gadff ._dcbf )||i < 0{return nil ;};return _gadff ._dcbf [i ];};func (_bge *PdfCrypt )encryptBytes (_bdb []byte ,_bdd string ,_ebg []byte )([]byte ,error ){_cb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_agaa ,_ccd :=_bge ._eede [_bdd ];if !_ccd {return nil ,_dca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bdd );};return _agaa .EncryptBytes (_bdb ,_ebg );};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};func (_cfgf *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ceab :=_cfgf ._gega .Discard (4);return PdfObjectNull {},_ceab ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_bgd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bgd .Predictor !=1&&_bgd .Predictor !=11{_cb .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _bgd .Predictor ==11{_fad :=_bgd .Columns ;_ada :=len (data )/_fad ;if len (data )%_fad !=0{_cb .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cfcgc :=_ed .NewBuffer (nil );_fcbca :=make ([]byte ,_fad );for _gcfd :=0;_gcfd < _ada ;_gcfd ++{_gbe :=data [_fad *_gcfd :_fad *(_gcfd +1)];
_fcbca [0]=_gbe [0];for _dbcd :=1;_dbcd < _fad ;_dbcd ++{_fcbca [_dbcd ]=byte (int (_gbe [_dbcd ]-_gbe [_dbcd -1])%256);};_cfcgc .WriteByte (1);_cfcgc .Write (_fcbca );};data =_cfcgc .Bytes ();};var _cbef _ed .Buffer ;_dda :=_fc .NewWriter (&_cbef );_dda .Write (data );
_dda .Close ();return _cbef .Bytes (),nil ;};func _be (_gba XrefTable ){_cb .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_cb .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cebd :=0;for _ ,_ff :=range _gba .ObjectMap {_cb .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cebd +1,_ff .ObjectNumber ,_ff .Generation ,_ff .Offset );
_cebd ++;};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cebdf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_eggd *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_eggd .setWithLock (key ,val ,true );};

// Len returns the number of elements in the streams.
func (_eeae *PdfObjectStreams )Len ()int {if _eeae ==nil {return 0;};return len (_eeae ._agbgb );};func (_aad *PdfCrypt )loadCryptFilters (_fgbf *PdfObjectDictionary )error {_aad ._eede =cryptFilters {};_dbe :=_fgbf .Get ("\u0043\u0046");_dbe =TraceToDirectObject (_dbe );
if _cfg ,_feg :=_dbe .(*PdfObjectReference );_feg {_dad ,_cbf :=_aad ._aff .LookupByReference (*_cfg );if _cbf !=nil {_cb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _cbf ;};_dbe =TraceToDirectObject (_dad );};_aac ,_ddc :=_dbe .(*PdfObjectDictionary );if !_ddc {_cb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_dbe );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_bfg :=range _aac .Keys (){_fgc :=_aac .Get (_bfg );if _gdg ,_cgb :=_fgc .(*PdfObjectReference );_cgb {_gaa ,_bce :=_aad ._aff .LookupByReference (*_gdg );if _bce !=nil {_cb .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _bce ;};_fgc =TraceToDirectObject (_gaa );};_ead ,_eab :=_fgc .(*PdfObjectDictionary );if !_eab {return _dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_bfg ,_fgc );
};if _bfg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _ddg _ad .FilterDict ;if _gbfd :=_abf (&_ddg ,_ead );_gbfd !=nil {return _gbfd ;};_dga ,_ba :=_ad .NewFilter (_ddg );if _ba !=nil {return _ba ;};_aad ._eede [string (_bfg )]=_dga ;};_aad ._eede ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ad .NewIdentity ();
_aad ._gfe ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gge ,_ebe :=_fgbf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ebe {if _ ,_dfb :=_aad ._eede [string (*_gge )];!_dfb {return _dca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gge );
};_aad ._gfe =string (*_gge );};_aad ._gdce ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ece ,_bec :=_fgbf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_bec {if _ ,_bfee :=_aad ._eede [string (*_ece )];!_bfee {return _dca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ece );
};_aad ._gdce =string (*_ece );};return nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_agabc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_cabc :=_agabc .Get (key );if _cabc ==nil {return "",false ;};_gdbc ,_ddbf :=_cabc .(*PdfObjectString );if !_ddbf {return "",false ;};return _gdbc .Str (),true ;};

// Clear resets the array to an empty state.
func (_dedd *PdfObjectArray )Clear (){_dedd ._dcbf =[]PdfObject {}};func _cfdc (_bbcf *PdfObjectStream ,_eead *MultiEncoder )(*DCTEncoder ,error ){_gecdf :=NewDCTEncoder ();_cfed :=_bbcf .PdfObjectDictionary ;if _cfed ==nil {return _gecdf ,nil ;};_dgg :=_bbcf .Stream ;
if _eead !=nil {_afca ,_dfaa :=_eead .DecodeBytes (_dgg );if _dfaa !=nil {return nil ,_dfaa ;};_dgg =_afca ;};_aedc :=_ed .NewReader (_dgg );_bggg ,_ccdf :=_ab .DecodeConfig (_aedc );if _ccdf !=nil {_cb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_ccdf );
return nil ,_ccdf ;};switch _bggg .ColorModel {case _dc .RGBAModel :_gecdf .BitsPerComponent =8;_gecdf .ColorComponents =3;_gecdf .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _dc .RGBA64Model :_gecdf .BitsPerComponent =16;_gecdf .ColorComponents =3;
_gecdf .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};case _dc .GrayModel :_gecdf .BitsPerComponent =8;_gecdf .ColorComponents =1;_gecdf .Decode =[]float64 {0.0,1.0};case _dc .Gray16Model :_gecdf .BitsPerComponent =16;_gecdf .ColorComponents =1;_gecdf .Decode =[]float64 {0.0,1.0};
case _dc .CMYKModel :_gecdf .BitsPerComponent =8;_gecdf .ColorComponents =4;_gecdf .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0};case _dc .YCbCrModel :_gecdf .BitsPerComponent =8;_gecdf .ColorComponents =3;_gecdf .Decode =[]float64 {0.0,1.0,0.0,1.0,0.0,1.0};
default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_gecdf .Width =_bggg .Width ;_gecdf .Height =_bggg .Height ;_cb .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gecdf );
_gecdf .Quality =DefaultJPEGQuality ;_edg ,_gaeb :=GetArray (_cfed .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));if _gaeb {_cca ,_edfbe :=_edg .ToFloat64Array ();if _edfbe !=nil {return _gecdf ,_edfbe ;};_gecdf .Decode =_cca ;};return _gecdf ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};func (_cff *PdfCrypt )isDecrypted (_fbe PdfObject )bool {_ ,_dcf :=_cff ._cef [_fbe ];if _dcf {_cb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _aec :=_fbe .(type ){case *PdfObjectStream :if _cff ._ebb .R !=5{if _dcgb ,_bdf :=_aec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bdf &&*_dcgb =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dcf =_cff ._gca [int (_aec .ObjectNumber )];
_dcf {return true ;};switch _gcfc :=_aec .PdfObject .(type ){case *PdfObjectDictionary :_aef :=true ;for _ ,_bcg :=range _cae {if _gcfc .Get (_bcg )==nil {_aef =false ;break ;};};if _aef {return true ;};};};_cb .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};func (_gade *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_gade ._gega )};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bebad (obj1 ,obj2 ,0)};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_gbcc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cb .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_cb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gbcc .Predictor );
if _gbcc .BitsPerComponent !=8{return nil ,_dca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_gbcc .BitsPerComponent );
};_faf ,_cce :=_gbcc .DecodeBytes (streamObj .Stream );if _cce !=nil {return nil ,_cce ;};_faf ,_cce =_gbcc .postDecodePredict (_faf );if _cce !=nil {return nil ,_cce ;};return _faf ,nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_dcbf []PdfObject };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _c .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _agbg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ace .Error (_agbg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_acdbb uint8 ;_cfebd _eg .Image ;_adcdf error ;);if bwThreshold ==JB2ImageAutoThreshold {_cfebd ,_adcdf =_eg .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ace .Error (_agbg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_acdbb =uint8 (255*bwThreshold );_cfebd ,_adcdf =_eg .MonochromeThresholdConverter (_acdbb ).Convert (i );};if _adcdf !=nil {return nil ,_adcdf ;};return _afcg (_cfebd ),nil ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_efa ParserMetadata )HasInvalidSubsectionHeader ()bool {return _efa ._dcag };func _bbbf ()string {return _cb .Version };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_aeba *PdfObjectStreams ,_daded bool ){_aeba ,_daded =obj .(*PdfObjectStreams );return _aeba ,_daded ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_fcbc *PdfParser )parseDetailedHeader ()(_gfc error ){_fcbc ._ecgd .Seek (0,_de .SeekStart );_fcbc ._gega =_da .NewReader (_fcbc ._ecgd );_dgfe :=20;_cbb :=make ([]byte ,_dgfe );var (_fceg bool ;_abg int ;);for {_bba ,_gaaf :=_fcbc ._gega .ReadByte ();
if _gaaf !=nil {if _gaaf ==_de .EOF {break ;}else {return _gaaf ;};};if IsDecimalDigit (_bba )&&_cbb [_dgfe -1]=='.'&&IsDecimalDigit (_cbb [_dgfe -2])&&_cbb [_dgfe -3]=='-'&&_cbb [_dgfe -4]=='F'&&_cbb [_dgfe -5]=='D'&&_cbb [_dgfe -6]=='P'&&_cbb [_dgfe -7]=='%'{_fcbc ._dcad =Version {Major :int (_cbb [_dgfe -2]-'0'),Minor :int (_bba -'0')};
_fcbc ._dbcb ._dabc =_abg -7;_fceg =true ;break ;};_abg ++;_cbb =append (_cbb [1:_dgfe ],_bba );};if !_fceg {return _dca .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_ccf ,_gfc :=_fcbc ._gega .ReadByte ();
if _gfc ==_de .EOF {return _dca .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _gfc !=nil {return _gfc ;};_fcbc ._dbcb ._acc =_ccf =='\n';_ccf ,_gfc =_fcbc ._gega .ReadByte ();
if _gfc !=nil {return _dca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gfc );};if _ccf !='%'{return nil ;};_bccf :=make ([]byte ,4);_ ,_gfc =_fcbc ._gega .Read (_bccf );
if _gfc !=nil {return _dca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_gfc );};_fcbc ._dbcb ._aafg =[4]byte {_bccf [0],_bccf [1],_bccf [2],_bccf [3]};
return nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cgaag map[PdfObjectName ]PdfObject ;_edaeb []PdfObjectName ;_fbcc *_e .Mutex ;_ecgbf *PdfParser ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ceg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _dea .DecodeBytes (encoded ,_edf .Parameters {},_ceg .Globals );};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ddea *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_ggcf :=n ;_gbga :=0;_bccc :=0;for _ggcf > 0{_eegbc ,_dbfa :=_ddea ._gega .Read (p [_gbga :]);if _dbfa !=nil {_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_eegbc ,_bccc ,_dbfa .Error ());
return _gbga ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bccc ++;_gbga +=_eegbc ;_ggcf -=_eegbc ;};return _gbga ,nil ;};func (_fabe *PdfCrypt )generateParams (_dfea ,_cdc []byte )error {_cgdf :=_fabe .securityHandler ();
_febe ,_dgdb :=_cgdf .GenerateParams (&_fabe ._ebb ,_cdc ,_dfea );if _dgdb !=nil {return _dgdb ;};_fabe ._ceef =_febe ;return nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func _faeeg (_adcfe ,_affd ,_gecaf uint8 )uint8 {_agde :=int (_gecaf );_eddc :=int (_affd )-_agde ;_gbaf :=int (_adcfe )-_agde ;_agde =_acb (_eddc +_gbaf );_eddc =_acb (_eddc );
_gbaf =_acb (_gbaf );if _eddc <=_gbaf &&_eddc <=_agde {return _adcfe ;}else if _gbaf <=_agde {return _affd ;};return _gecaf ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bcaf *MultiEncoder )GetFilterArray ()*PdfObjectArray {_dead :=make ([]PdfObject ,len (_bcaf ._dbeg ));for _effff ,_eefa :=range _bcaf ._dbeg {_dead [_effff ]=MakeName (_eefa .GetFilterName ());};return MakeArray (_dead ...);};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fa *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ef ,_ ,_cee :=_fa .lookupByNumberWrapper (objNumber ,true );return _ef ,_cee ;};

// WriteString outputs the object as it is to be written to file.
func (_faccb *PdfObjectString )WriteString ()string {var _baca _ed .Buffer ;if _faccb ._bggf {_cbdd :=_cd .EncodeToString (_faccb .Bytes ());_baca .WriteString ("\u003c");_baca .WriteString (_cbdd );_baca .WriteString ("\u003e");return _baca .String ();
};_fbadd :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_baca .WriteString ("\u0028");for _baacb :=0;_baacb < len (_faccb ._fdgged );
_baacb ++{_fbgb :=_faccb ._fdgged [_baacb ];if _bcafd ,_beddg :=_fbadd [_fbgb ];_beddg {_baca .WriteString (_bcafd );}else {_baca .WriteByte (_fbgb );};};_baca .WriteString ("\u0029");return _baca .String ();};

// GetParser returns the parser for lazy-loading or compare references.
func (_bbfbe *PdfObjectReference )GetParser ()*PdfParser {return _bbfbe ._fdbeb };

// String returns a string representation of `name`.
func (_cecd *PdfObjectName )String ()string {return string (*_cecd )};

// GetFilterName returns the name of the encoding filter.
func (_cab *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;Decode []float64 ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gbdd *PdfObjectArray ,_deec bool ){_gbdd ,_deec =TraceToDirectObject (obj ).(*PdfObjectArray );return _gbdd ,_deec ;};

// GetFilterName returns the name of the encoding filter.
func (_afdd *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bbg *PdfCrypt )GetAccessPermissions ()_af .Permissions {return _bbg ._ebb .P };

// LookupByReference looks up a PdfObject by a reference.
func (_ebdb *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_cb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _ebdb .LookupByNumber (int (ref .ObjectNumber ));
};var _adff =_ec .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dcdc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gaab :=encoded ;var _bdba error ;for _ ,_bagd :=range _dcdc ._dbeg {_cb .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_bagd ,_bagd );
_gaab ,_bdba =_bagd .DecodeBytes (_gaab );if _bdba !=nil {return nil ,_bdba ;};};return _gaab ,nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_ega *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_ega ._fbcc .Lock ();defer _ega ._fbcc .Unlock ();_agefb ,_dggcg :=_ega ._cgaag [key ];if !_dggcg {return nil ;};return _agefb ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func _edaad (_ddeb PdfObject ,_cebgf int ,_ggacg map[PdfObject ]struct{})error {_cb .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_cebgf );
if _ ,_beced :=_ggacg [_ddeb ];_beced {_cb .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ggacg [_ddeb ]=struct{}{};switch _edge :=_ddeb .(type ){case *PdfIndirectObject :_fbcgf :=_edge ;
_cb .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fbcgf );_cb .Log .Trace ("\u002d\u0020\u0025\u0073",_fbcgf .PdfObject );return _edaad (_fbcgf .PdfObject ,_cebgf +1,_ggacg );case *PdfObjectStream :_bdga :=_edge ;return _edaad (_bdga .PdfObjectDictionary ,_cebgf +1,_ggacg );
case *PdfObjectDictionary :_ggdd :=_edge ;_cb .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_ggdd );for _ ,_dece :=range _ggdd .Keys (){_faec :=_ggdd .Get (_dece );if _ceabd ,_dbeb :=_faec .(*PdfObjectReference );_dbeb {_aage :=_ceabd .Resolve ();
_ggdd .Set (_dece ,_aage );_ceff :=_edaad (_aage ,_cebgf +1,_ggacg );if _ceff !=nil {return _ceff ;};}else {_addaa :=_edaad (_faec ,_cebgf +1,_ggacg );if _addaa !=nil {return _addaa ;};};};return nil ;case *PdfObjectArray :_gfedg :=_edge ;_cb .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_gfedg );
for _gecg ,_ebbb :=range _gfedg .Elements (){if _beabcc ,_dfgb :=_ebbb .(*PdfObjectReference );_dfgb {_dagb :=_beabcc .Resolve ();_gfedg .Set (_gecg ,_dagb );_fcbe :=_edaad (_dagb ,_cebgf +1,_ggacg );if _fcbe !=nil {return _fcbe ;};}else {_abgag :=_edaad (_ebbb ,_cebgf +1,_ggacg );
if _abgag !=nil {return _abgag ;};};};return nil ;case *PdfObjectReference :_cb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_aea ParserMetadata )HasInvalidHexRunes ()bool {return _aea ._bbe };

// UpdateParams updates the parameter values of the encoder.
func (_faed *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _decc ,_edaf :=GetNumberAsInt64 (params .Get ("\u004b"));_edaf ==nil {_faed .K =int (_decc );};if _caee ,_ddfa :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_ddfa ==nil {_faed .Columns =int (_caee );}else if _caee ,_ddfa =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_ddfa ==nil {_faed .Columns =int (_caee );};if _fcgf ,_fagg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_fagg ==nil {_faed .BlackIs1 =_fcgf > 0;}else {if _dceg ,_abgf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_abgf {_faed .BlackIs1 =_dceg ;}else {if _fbae ,_aaag :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_aaag {_bafg ,_adfd :=_fbae .ToIntegerArray ();if _adfd ==nil {_faed .BlackIs1 =_bafg [0]==1&&_bafg [1]==0;};};};};if _fcga ,_caed :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_caed ==nil {_faed .EncodedByteAlign =_fcga > 0;}else {if _efff ,_egde :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_egde {_faed .EncodedByteAlign =_efff ;};};if _ebcd ,_eeaa :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_eeaa ==nil {_faed .EndOfLine =_ebcd > 0;}else {if _bfba ,_cbce :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cbce {_faed .EndOfLine =_bfba ;};};if _ffag ,_gggfd :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_gggfd ==nil {_faed .Rows =int (_ffag );}else if _ffag ,_gggfd =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_gggfd ==nil {_faed .Rows =int (_ffag );};if _bbdb ,_cged :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_cged ==nil {_faed .EndOfBlock =_bbdb > 0;}else {if _efge ,_feee :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_feee {_faed .EndOfBlock =_efge ;};};if _bdcg ,_fcbbc :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_fcbbc !=nil {_faed .DamagedRowsBeforeError =int (_bdcg );};};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gfgaa *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_egda :=MakeDict ();_egda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfgaa .GetFilterName ()));_egda .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfgaa .MakeDecodeParams ());
return _egda ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_adad *PdfParser )CheckAccessRights (password []byte )(bool ,_af .Permissions ,error ){if _adad ._agf ==nil {return true ,_af .PermOwner ,nil ;};return _adad ._agf .checkAccessRights (password );};

// String returns a string describing `ref`.
func (_eddg *PdfObjectReference )String ()string {return _dca .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_eddg .ObjectNumber ,_eddg .GenerationNumber );};

// PdfVersion returns version of the PDF file.
func (_fabf *PdfParser )PdfVersion ()Version {return _fabf ._dcad };var _cgfg =_ec .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// UpdateParams updates the parameter values of the encoder.
func (_gfg *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_addb ,_acee :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _acee ==nil {_gfg .Predictor =int (_addb );};_egg ,_acee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _acee ==nil {_gfg .BitsPerComponent =int (_egg );};_fcgd ,_acee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _acee ==nil {_gfg .Columns =int (_fcgd );};_cac ,_acee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _acee ==nil {_gfg .Colors =int (_cac );};};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_fbgf *PdfParser )GetCrypter ()*PdfCrypt {return _fbgf ._agf };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_baecb *JBIG2Encoder )DecodeImages (encoded []byte )([]_c .Image ,error ){const _ffff ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_gad ,_cfba :=_edf .Decode (encoded ,_edf .Parameters {},_baecb .Globals .ToDocumentGlobals ());
if _cfba !=nil {return nil ,_ace .Wrap (_cfba ,_ffff ,"");};_bcfa ,_cfba :=_gad .PageNumber ();if _cfba !=nil {return nil ,_ace .Wrap (_cfba ,_ffff ,"");};_fgfg :=[]_c .Image {};var _ecbe _c .Image ;for _bfaec :=1;_bfaec <=_bcfa ;_bfaec ++{_ecbe ,_cfba =_gad .DecodePageImage (_bfaec );
if _cfba !=nil {return nil ,_ace .Wrapf (_cfba ,_ffff ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bfaec );};_fgfg =append (_fgfg ,_ecbe );};return _fgfg ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ecdf *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _bage :=val .(type ){case *PdfObjectName :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectDictionary :if _bage !=nil {_ecdf .Set (key ,val );
};case *PdfObjectStream :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectString :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectNull :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectInteger :if _bage !=nil {_ecdf .Set (key ,val );
};case *PdfObjectArray :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectBool :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectFloat :if _bage !=nil {_ecdf .Set (key ,val );};case *PdfObjectReference :if _bage !=nil {_ecdf .Set (key ,val );
};case *PdfIndirectObject :if _bage !=nil {_ecdf .Set (key ,val );};default:_cb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_baac *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _baac ._ffdg };

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_bbfbf *PdfParser )GetPreviousRevisionReadSeeker ()(_de .ReadSeeker ,error ){if _cdfe :=_bbfbf .seekToEOFMarker (_bbfbf ._baeb -_gbabf );_cdfe !=nil {return nil ,_cdfe ;};_ccfc ,_gbda :=_bbfbf ._ecgd .Seek (0,_de .SeekCurrent );if _gbda !=nil {return nil ,_gbda ;
};_ccfc +=_gbabf ;return _feefd (_bbfbf ._ecgd ,_ccfc );};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_ebag *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ebag .DecodeBytes (streamObj .Stream );};type objectStreams map[int ]objectStream ;

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _fbbd ,_bgdd :=obj .(*PdfObjectReference );_bgdd {return _fbbd .Resolve ();};return obj ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_abfed *PdfObjectString )Bytes ()[]byte {return []byte (_abfed ._fdgged )};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//	renamed to String() as a pretty string to use in debugging etc.
func (_bfc *MultiEncoder )GetFilterName ()string {_dgfg :="";for _baec ,_fgca :=range _bfc ._dbeg {_dgfg +=_fgca .GetFilterName ();if _baec < len (_bfc ._dbeg )-1{_dgfg +="\u0020";};};return _dgfg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gafee *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_gfea *PdfParser )resolveReference (_daag *PdfObjectReference )(PdfObject ,bool ,error ){_bgdae ,_adbcg :=_gfea .ObjCache [int (_daag .ObjectNumber )];if _adbcg {return _bgdae ,true ,nil ;};_dbcbc ,_afbf :=_gfea .LookupByReference (*_daag );
if _afbf !=nil {return nil ,false ,_afbf ;};_gfea .ObjCache [int (_daag .ObjectNumber )]=_dbcbc ;return _dbcbc ,false ,nil ;};func _fed (_fcab *PdfObjectStream ,_cfcg *PdfObjectDictionary )(*FlateEncoder ,error ){_acdb :=NewFlateEncoder ();_gea :=_fcab .PdfObjectDictionary ;
if _gea ==nil {return _acdb ,nil ;};_acdb ._adbc =_dgfde (_gea );if _cfcg ==nil {_agb :=TraceToDirectObject (_gea .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _beb :=_agb .(type ){case *PdfObjectArray :if _beb .Len ()!=1{_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_beb .Len ());
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _gaba ,_cfga :=GetDict (_beb .Get (0));_cfga {_cfcg =_gaba ;};case *PdfObjectDictionary :_cfcg =_beb ;case *PdfObjectNull ,nil :default:_cb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_agb );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cfcg ==nil {return _acdb ,nil ;};_cb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cfcg .String ());
_gafa :=_cfcg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gafa ==nil {_cb .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_defe ,_cdgb :=_gafa .(*PdfObjectInteger );if !_cdgb {_cb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gafa );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_acdb .Predictor =int (*_defe );};_gafa =_cfcg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _gafa !=nil {_eabd ,_cgf :=_gafa .(*PdfObjectInteger );if !_cgf {_cb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_dca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_acdb .BitsPerComponent =int (*_eabd );};if _acdb .Predictor > 1{_acdb .Columns =1;_gafa =_cfcg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _gafa !=nil {_edff ,_ggfa :=_gafa .(*PdfObjectInteger );if !_ggfa {return nil ,_dca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_acdb .Columns =int (*_edff );
};_acdb .Colors =1;_gafa =_cfcg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gafa !=nil {_gafd ,_gbaa :=_gafa .(*PdfObjectInteger );if !_gbaa {return nil ,_dca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_acdb .Colors =int (*_gafd );};};return _acdb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_abacg *PdfObjectBool )WriteString ()string {if *_abacg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func _aaa (_bc int )cryptFilters {return cryptFilters {_cfeg :_ad .NewFilterV2 (_bc )}};type xrefType int ;

// String returns a string describing `streams`.
func (_gbgf *PdfObjectStreams )String ()string {return _dca .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_gbgf .ObjectNumber );};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gcgd *PdfParser )GetObjectNums ()[]int {var _cddef []int ;for _ ,_dccc :=range _gcgd ._fffef .ObjectMap {_cddef =append (_cddef ,_dccc .ObjectNumber );};_gg .Ints (_cddef );return _cddef ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_fgfb *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_fgfb ._fbcc .Lock ();defer _fgfb ._fbcc .Unlock ();for _gabe ,_cddd :=range objmap {_fgfb .setWithLock (PdfObjectName (_gabe ),_cddd ,false );};return _fgfb ;
};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bbfcg *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_adfb :=MakeDict ();_adfb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbfcg .GetFilterName ()));_abad :=_bbfcg .MakeDecodeParams ();if _abad !=nil {_adfb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_abad );
};return _adfb ;};func (_aebf *PdfParser )getNumbersOfUpdatedObjects (_eedee *PdfParser )([]int ,error ){if _eedee ==nil {return nil ,_g .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_aeaa :=_eedee ._baeb ;_abecf :=make ([]int ,0);_agdd :=make (map[int ]interface{});_cgdfd :=make (map[int ]int64 );for _bgbb ,_agec :=range _aebf ._fffef .ObjectMap {if _agec .Offset ==0{if _agec .OsObjNumber !=0{if _dfca ,_ccebg :=_aebf ._fffef .ObjectMap [_agec .OsObjNumber ];
_ccebg {_agdd [_agec .OsObjNumber ]=struct{}{};_cgdfd [_bgbb ]=_dfca .Offset ;}else {return nil ,_g .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_cgdfd [_bgbb ]=_agec .Offset ;};};for _afeff ,_cgdfb :=range _cgdfd {if _ ,_bdegd :=_agdd [_afeff ];
_bdegd {continue ;};if _cgdfb > _aeaa {_abecf =append (_abecf ,_afeff );};};return _abecf ,nil ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_cfaa :=MakeDict ();return _cfaa .Update (objmap );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_bdac *PdfParser )repairSeekXrefMarker ()error {_dceff ,_edfcb :=_bdac ._ecgd .Seek (0,_de .SeekEnd );if _edfcb !=nil {return _edfcb ;};_ggade :=_ec .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");
var _gdba int64 ;var _fcbd int64 =1000;for _gdba < _dceff {if _dceff <=(_fcbd +_gdba ){_fcbd =_dceff -_gdba ;};_ ,_cggc :=_bdac ._ecgd .Seek (-_gdba -_fcbd ,_de .SeekEnd );if _cggc !=nil {return _cggc ;};_fgbe :=make ([]byte ,_fcbd );_bdac ._ecgd .Read (_fgbe );
_cb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fgbe ));_cgdc :=_ggade .FindAllStringIndex (string (_fgbe ),-1);if _cgdc !=nil {_fgda :=_cgdc [len (_cgdc )-1];
_cb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cgdc );_bdac ._ecgd .Seek (-_gdba -_fcbd +int64 (_fgda [0]),_de .SeekEnd );_bdac ._gega =_da .NewReader (_bdac ._ecgd );for {_aagaf ,_agea :=_bdac ._gega .Peek (1);if _agea !=nil {return _agea ;
};_cb .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_aagaf [0],_aagaf [0]);if !IsWhiteSpace (_aagaf [0]){break ;};_bdac ._gega .Discard (1);};return nil ;};_cb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_gdba +=_fcbd ;};_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_afaa *PdfObjectInteger ,_dgbab bool ){_afaa ,_dgbab =TraceToDirectObject (obj ).(*PdfObjectInteger );return _afaa ,_dgbab ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_aefc *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aefc .DecodeBytes (streamObj .Stream );};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_dabf ParserMetadata )HasDataAfterEOF ()bool {return _dabf ._cfd };

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_eacfb *PdfObjectDictionary );EncodeBytes (_fffd []byte )([]byte ,error );DecodeBytes (_efad []byte )([]byte ,error );
DecodeStream (_cdbc *PdfObjectStream )([]byte ,error );};var _acdd =_ec .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// GetFilterName returns the name of the encoding filter.
func (_dag *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// WriteString outputs the object as it is to be written to file.
func (_gbgc *PdfObjectFloat )WriteString ()string {return _f .FormatFloat (float64 (*_gbgc ),'f',-1,64);};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_dfcbf :=PdfObjectBool (val );return &_dfcbf };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_cfbc *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_deab :=_ed .NewReader (encoded );var _bbdd []byte ;for {_bafe ,_egcg :=_deab .ReadByte ();if _egcg !=nil {return nil ,_egcg ;};if _bafe =='>'{break ;};if IsWhiteSpace (_bafe ){continue ;
};if (_bafe >='a'&&_bafe <='f')||(_bafe >='A'&&_bafe <='F')||(_bafe >='0'&&_bafe <='9'){_bbdd =append (_bbdd ,_bafe );}else {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bafe );
return nil ,_dca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bafe );};};if len (_bbdd )%2==1{_bbdd =append (_bbdd ,'0');
};_cb .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bbdd );_aege :=make ([]byte ,_cd .DecodedLen (len (_bbdd )));_ ,_ddfbc :=_cd .Decode (_aege ,_bbdd );if _ddfbc !=nil {return nil ,_ddfbc ;};return _aege ,nil ;};

// String returns a string describing `array`.
func (_fabfd *PdfObjectArray )String ()string {_geec :="\u005b";for _ecebd ,_ebcdf :=range _fabfd .Elements (){_geec +=_ebcdf .String ();if _ecebd < (_fabfd .Len ()-1){_geec +="\u002c\u0020";};};_geec +="\u005d";return _geec ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func (_geag *PdfObjectDictionary )setWithLock (_ggfce PdfObjectName ,_bfgca PdfObject ,_bgef bool ){if _bgef {_geag ._fbcc .Lock ();defer _geag ._fbcc .Unlock ();};_ ,_cacd :=_geag ._cgaag [_ggfce ];if !_cacd {_geag ._edaeb =append (_geag ._edaeb ,_ggfce );
};_geag ._cgaag [_ggfce ]=_bfgca ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgbbc *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _gebdg []int64 ;for _ ,_dbea :=range _bgbbc .Elements (){if _bcbec ,_dgagd :=_dbea .(*PdfObjectInteger );_dgagd {_gebdg =append (_gebdg ,int64 (*_bcbec ));}else {return nil ,ErrTypeError ;
};};return _gebdg ,nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_gce *PdfObjectReference )Resolve ()PdfObject {if _gce ._fdbeb ==nil {return MakeNull ();};_gffb ,_ ,_eegf :=_gce ._fdbeb .resolveReference (_gce );if _eegf !=nil {_cb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_eegf );
return MakeNull ();};if _gffb ==nil {_cb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _gffb ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_adcbe *PdfObjectString )Decoded ()string {if _adcbe ==nil {return "";};_dcea :=[]byte (_adcbe ._fdgged );if len (_dcea )>=2&&_dcea [0]==0xFE&&_dcea [1]==0xFF{return _ggf .UTF16ToString (_dcea [2:]);};return _ggf .PDFDocEncodingToString (_dcea );
};var _gdceg =_ec .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_dgac *PdfParser )readComment ()(string ,error ){var _aggg _ed .Buffer ;_ ,_fecd :=_dgac .skipSpaces ();if _fecd !=nil {return _aggg .String (),_fecd ;
};_bdgb :=true ;for {_cbead ,_cbbf :=_dgac ._gega .Peek (1);if _cbbf !=nil {_cb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cbbf .Error ());return _aggg .String (),_cbbf ;};if _bdgb &&_cbead [0]!='%'{return _aggg .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_bdgb =false ;if (_cbead [0]!='\r')&&(_cbead [0]!='\n'){_dgbb ,_ :=_dgac ._gega .ReadByte ();_aggg .WriteByte (_dgbb );}else {break ;};};return _aggg .String (),nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dccb *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dccb ==nil {return nil ;};return _dccb ._edaeb ;};type limitedReadSeeker struct{_fecf _de .ReadSeeker ;_cbad int64 ;};

// HeaderPosition gets the file header position.
func (_edb ParserMetadata )HeaderPosition ()int {return _edb ._dabc };var _cae =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// WriteString outputs the object as it is to be written to file.
func (_aced *PdfObjectStream )WriteString ()string {var _aega _gcd .Builder ;_aega .WriteString (_f .FormatInt (_aced .ObjectNumber ,10));_aega .WriteString ("\u0020\u0030\u0020\u0052");return _aega .String ();};