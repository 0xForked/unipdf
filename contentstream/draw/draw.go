//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_eb "fmt";_d "github.com/unidoc/unipdf/v3/contentstream";_b "github.com/unidoc/unipdf/v3/core";_ae "github.com/unidoc/unipdf/v3/internal/transform";_c "github.com/unidoc/unipdf/v3/model";_e "math";);

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// Scale scales the vector by the specified factor.
func (_dgac Vector )Scale (factor float64 )Vector {_cca :=_dgac .Magnitude ();_cbd :=_dgac .GetPolarAngle ();_dgac .Dx =factor *_cca *_e .Cos (_cbd );_dgac .Dy =factor *_cca *_e .Sin (_cbd );return _dgac ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_ec :=CubicBezierPath {};_ec .Curves =[]CubicBezierCurve {};return _ec ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_eg CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_eg .Curves =append (_eg .Curves ,curve );return _eg ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_gb BoundingBox )ToPdfRectangle ()*_c .PdfRectangle {return &_c .PdfRectangle {Llx :_gb .X ,Lly :_gb .Y ,Urx :_gb .X +_gb .Width ,Ury :_gb .Y +_gb .Height };};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_cdd Rectangle )ToPdfRectangle ()*_c .PdfRectangle {return &_c .PdfRectangle {Llx :_cdd .X ,Lly :_cdd .Y ,Urx :_cdd .X +_cdd .Width ,Ury :_cdd .Y +_cdd .Height };};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_acg Point )Rotate (theta float64 )Point {_afe :=_ae .NewPoint (_acg .X ,_acg .Y ).Rotate (theta );return NewPoint (_afe .X ,_afe .Y );};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _c .PdfColor ;BorderEnabled bool ;BorderColor _c .PdfColor ;BorderWidth float64 ;};

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_fec Rectangle )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_dceg :=_d .NewContentCreator ();_dceg .Add_q ();if _fec .FillEnabled {_dceg .SetNonStrokingColor (_fec .FillColor );};if _fec .BorderEnabled {_dceg .SetStrokingColor (_fec .BorderColor );
_dceg .Add_w (_fec .BorderWidth );};if len (gsName )> 1{_dceg .Add_gs (_b .PdfObjectName (gsName ));};var (_gga ,_bde =_fec .X ,_fec .Y ;_dbf ,_aa =_fec .Width ,_fec .Height ;_fdc =_e .Abs (_fec .BorderRadiusTopLeft );_aca =_e .Abs (_fec .BorderRadiusTopRight );
_ege =_e .Abs (_fec .BorderRadiusBottomLeft );_dbg =_e .Abs (_fec .BorderRadiusBottomRight );_fcc =0.4477;);_cc :=Path {Points :[]Point {{X :_gga +_dbf -_dbg ,Y :_bde },{X :_gga +_dbf ,Y :_bde +_aa -_aca },{X :_gga +_fdc ,Y :_bde +_aa },{X :_gga ,Y :_bde +_ege }}};
_fdf :=[][7]float64 {{_dbg ,_gga +_dbf -_dbg *_fcc ,_bde ,_gga +_dbf ,_bde +_dbg *_fcc ,_gga +_dbf ,_bde +_dbg },{_aca ,_gga +_dbf ,_bde +_aa -_aca *_fcc ,_gga +_dbf -_aca *_fcc ,_bde +_aa ,_gga +_dbf -_aca ,_bde +_aa },{_fdc ,_gga +_fdc *_fcc ,_bde +_aa ,_gga ,_bde +_aa -_fdc *_fcc ,_gga ,_bde +_aa -_fdc },{_ege ,_gga ,_bde +_ege *_fcc ,_gga +_ege *_fcc ,_bde ,_gga +_ege ,_bde }};
_dceg .Add_m (_gga +_ege ,_bde );for _acd :=0;_acd < 4;_acd ++{_fca :=_cc .Points [_acd ];_dceg .Add_l (_fca .X ,_fca .Y );_bcb :=_fdf [_acd ];if _cfg :=_bcb [0];_cfg !=0{_dceg .Add_c (_bcb [1],_bcb [2],_bcb [3],_bcb [4],_bcb [5],_bcb [6]);};};_dceg .Add_h ();
if _fec .FillEnabled &&_fec .BorderEnabled {_dceg .Add_B ();}else if _fec .FillEnabled {_dceg .Add_f ();}else if _fec .BorderEnabled {_dceg .Add_S ();};_dceg .Add_Q ();return _dceg .Bytes (),_cc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_bc Point )Add (dx ,dy float64 )Point {_bc .X +=dx ;_bc .Y +=dy ;return _bc };

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_efd :=Vector {};_efd .Dx =dx ;_efd .Dy =dy ;return _efd };

// Length returns the number of points in the path.
func (_caa Path )Length ()int {return len (_caa .Points )};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;);

// Offset shifts the Bezier path with the specified offsets.
func (_dbe CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _dd ,_dda :=range _dbe .Curves {_dbe .Curves [_dd ]=_dda .AddOffsetXY (offX ,offY );};return _dbe ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _c .PdfColor ;BorderEnabled bool ;BorderColor _c .PdfColor ;BorderWidth float64 ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_d .ContentCreator ){for _dea ,_fcb :=range path .Points {if _dea ==0{creator .Add_m (_fcb .X ,_fcb .Y );}else {creator .Add_l (_fcb .X ,_fcb .Y );};};};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};func (_gdc Point )String ()string {return _eb .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_gdc .X ,_gdc .Y );};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _c .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _c .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_d .ContentCreator ){for _bfg ,_fgg :=range bpath .Curves {if _bfg ==0{creator .Add_m (_fgg .P0 .X ,_fgg .P0 .Y );};creator .Add_c (_fgg .P1 .X ,_fgg .P1 .Y ,_fgg .P2 .X ,_fgg .P2 .Y ,_fgg .P3 .X ,_fgg .P3 .Y );
};};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_bd Path )GetPointNumber (number int )Point {if number < 1||number > len (_bd .Points ){return Point {};};return _bd .Points [number -1];};

// AppendPoint adds the specified point to the path.
func (_dg Path )AppendPoint (point Point )Path {_dg .Points =append (_dg .Points ,point );return _dg };

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Copy returns a clone of the Bezier path.
func (_gc CubicBezierPath )Copy ()CubicBezierPath {_fd :=CubicBezierPath {};_fd .Curves =append (_fd .Curves ,_gc .Curves ...);return _fd ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_gea CurvePolygon )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_aee :=_d .NewContentCreator ();_aee .Add_q ();_gea .FillEnabled =_gea .FillEnabled &&_gea .FillColor !=nil ;if _gea .FillEnabled {_aee .SetNonStrokingColor (_gea .FillColor );
};_gea .BorderEnabled =_gea .BorderEnabled &&_gea .BorderColor !=nil ;if _gea .BorderEnabled {_aee .SetStrokingColor (_gea .BorderColor );_aee .Add_w (_gea .BorderWidth );};if len (gsName )> 1{_aee .Add_gs (_b .PdfObjectName (gsName ));};_gdcb :=NewCubicBezierPath ();
for _ ,_eaf :=range _gea .Rings {for _dff ,_abg :=range _eaf {if _dff ==0{_aee .Add_m (_abg .P0 .X ,_abg .P0 .Y );}else {_aee .Add_l (_abg .P0 .X ,_abg .P0 .Y );};_aee .Add_c (_abg .P1 .X ,_abg .P1 .Y ,_abg .P2 .X ,_abg .P2 .Y ,_abg .P3 .X ,_abg .P3 .Y );
_gdcb =_gdcb .AppendCurve (_abg );};_aee .Add_h ();};if _gea .FillEnabled &&_gea .BorderEnabled {_aee .Add_B ();}else if _gea .FillEnabled {_aee .Add_f ();}else if _gea .BorderEnabled {_aee .Add_S ();};_aee .Add_Q ();return _aee .Bytes (),_gdcb .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_eca PolyBezierCurve )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){if _eca .BorderColor ==nil {_eca .BorderColor =_c .NewPdfColorDeviceRGB (0,0,0);};_cbf :=NewCubicBezierPath ();for _ ,_bef :=range _eca .Curves {_cbf =_cbf .AppendCurve (_bef );
};_acge :=_d .NewContentCreator ();_acge .Add_q ();_eca .FillEnabled =_eca .FillEnabled &&_eca .FillColor !=nil ;if _eca .FillEnabled {_acge .SetNonStrokingColor (_eca .FillColor );};_acge .SetStrokingColor (_eca .BorderColor );_acge .Add_w (_eca .BorderWidth );
if len (gsName )> 1{_acge .Add_gs (_b .PdfObjectName (gsName ));};for _ea ,_aed :=range _cbf .Curves {if _ea ==0{_acge .Add_m (_aed .P0 .X ,_aed .P0 .Y );}else {_acge .Add_l (_aed .P0 .X ,_aed .P0 .Y );};_acge .Add_c (_aed .P1 .X ,_aed .P1 .Y ,_aed .P2 .X ,_aed .P2 .Y ,_aed .P3 .X ,_aed .P3 .Y );
};if _eca .FillEnabled {_acge .Add_h ();_acge .Add_B ();}else {_acge .Add_S ();};_acge .Add_Q ();return _acge .Bytes (),_cbf .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Magnitude returns the magnitude of the vector.
func (_ggc Vector )Magnitude ()float64 {return _e .Sqrt (_e .Pow (_ggc .Dx ,2.0)+_e .Pow (_ggc .Dy ,2.0))};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_cfa Polygon )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_dcc :=_d .NewContentCreator ();_dcc .Add_q ();_cfa .FillEnabled =_cfa .FillEnabled &&_cfa .FillColor !=nil ;if _cfa .FillEnabled {_dcc .SetNonStrokingColor (_cfa .FillColor );
};_cfa .BorderEnabled =_cfa .BorderEnabled &&_cfa .BorderColor !=nil ;if _cfa .BorderEnabled {_dcc .SetStrokingColor (_cfa .BorderColor );_dcc .Add_w (_cfa .BorderWidth );};if len (gsName )> 1{_dcc .Add_gs (_b .PdfObjectName (gsName ));};_bgf :=NewPath ();
for _ ,_df :=range _cfa .Points {for _ba ,_afb :=range _df {_bgf =_bgf .AppendPoint (_afb );if _ba ==0{_dcc .Add_m (_afb .X ,_afb .Y );}else {_dcc .Add_l (_afb .X ,_afb .Y );};};_dcc .Add_h ();};if _cfa .FillEnabled &&_cfa .BorderEnabled {_dcc .Add_B ();
}else if _cfa .FillEnabled {_dcc .Add_f ();}else if _cfa .BorderEnabled {_dcc .Add_S ();};_dcc .Add_Q ();return _dcc .Bytes (),_bgf .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_dbgf Line )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_ag ,_cdg :=_dbgf .X1 ,_dbgf .X2 ;_ee ,_fed :=_dbgf .Y1 ,_dbgf .Y2 ;_ceb :=_fed -_ee ;_gcbd :=_cdg -_ag ;_bbd :=_e .Atan2 (_ceb ,_gcbd );L :=_e .Sqrt (_e .Pow (_gcbd ,2.0)+_e .Pow (_ceb ,2.0));
_gcbb :=_dbgf .LineWidth ;_fecf :=_e .Pi ;_aae :=1.0;if _gcbd < 0{_aae *=-1.0;};if _ceb < 0{_aae *=-1.0;};VsX :=_aae *(-_gcbb /2*_e .Cos (_bbd +_fecf /2));VsY :=_aae *(-_gcbb /2*_e .Sin (_bbd +_fecf /2)+_gcbb *_e .Sin (_bbd +_fecf /2));V1X :=VsX +_gcbb /2*_e .Cos (_bbd +_fecf /2);
V1Y :=VsY +_gcbb /2*_e .Sin (_bbd +_fecf /2);V2X :=VsX +_gcbb /2*_e .Cos (_bbd +_fecf /2)+L *_e .Cos (_bbd );V2Y :=VsY +_gcbb /2*_e .Sin (_bbd +_fecf /2)+L *_e .Sin (_bbd );V3X :=VsX +_gcbb /2*_e .Cos (_bbd +_fecf /2)+L *_e .Cos (_bbd )+_gcbb *_e .Cos (_bbd -_fecf /2);
V3Y :=VsY +_gcbb /2*_e .Sin (_bbd +_fecf /2)+L *_e .Sin (_bbd )+_gcbb *_e .Sin (_bbd -_fecf /2);V4X :=VsX +_gcbb /2*_e .Cos (_bbd -_fecf /2);V4Y :=VsY +_gcbb /2*_e .Sin (_bbd -_fecf /2);_bdb :=NewPath ();_bdb =_bdb .AppendPoint (NewPoint (V1X ,V1Y ));_bdb =_bdb .AppendPoint (NewPoint (V2X ,V2Y ));
_bdb =_bdb .AppendPoint (NewPoint (V3X ,V3Y ));_bdb =_bdb .AppendPoint (NewPoint (V4X ,V4Y ));_ecg :=_dbgf .LineEndingStyle1 ;_bdbe :=_dbgf .LineEndingStyle2 ;_ffb :=3*_gcbb ;_befa :=3*_gcbb ;_ecb :=(_befa -_gcbb )/2;if _bdbe ==LineEndingStyleArrow {_aag :=_bdb .GetPointNumber (2);
_fcf :=NewVectorPolar (_ffb ,_bbd +_fecf );_ddbc :=_aag .AddVector (_fcf );_dae :=NewVectorPolar (_befa /2,_bbd +_fecf /2);_cec :=NewVectorPolar (_ffb ,_bbd );_afa :=NewVectorPolar (_ecb ,_bbd +_fecf /2);_bf :=_ddbc .AddVector (_afa );_bca :=_cec .Add (_dae .Flip ());
_bec :=_bf .AddVector (_bca );_gbd :=_dae .Scale (2).Flip ().Add (_bca .Flip ());_gfd :=_bec .AddVector (_gbd );_ga :=_ddbc .AddVector (NewVectorPolar (_gcbb ,_bbd -_fecf /2));_eba :=NewPath ();_eba =_eba .AppendPoint (_bdb .GetPointNumber (1));_eba =_eba .AppendPoint (_ddbc );
_eba =_eba .AppendPoint (_bf );_eba =_eba .AppendPoint (_bec );_eba =_eba .AppendPoint (_gfd );_eba =_eba .AppendPoint (_ga );_eba =_eba .AppendPoint (_bdb .GetPointNumber (4));_bdb =_eba ;};if _ecg ==LineEndingStyleArrow {_fcfe :=_bdb .GetPointNumber (1);
_cgb :=_bdb .GetPointNumber (_bdb .Length ());_aec :=NewVectorPolar (_gcbb /2,_bbd +_fecf +_fecf /2);_ace :=_fcfe .AddVector (_aec );_ffbd :=NewVectorPolar (_ffb ,_bbd ).Add (NewVectorPolar (_befa /2,_bbd +_fecf /2));_ecae :=_ace .AddVector (_ffbd );_aaeb :=NewVectorPolar (_ecb ,_bbd -_fecf /2);
_ggb :=_ecae .AddVector (_aaeb );_feg :=NewVectorPolar (_ffb ,_bbd );_gff :=_cgb .AddVector (_feg );_caab :=NewVectorPolar (_ecb ,_bbd +_fecf +_fecf /2);_cged :=_gff .AddVector (_caab );_gbe :=_ace ;_bdg :=NewPath ();_bdg =_bdg .AppendPoint (_ace );_bdg =_bdg .AppendPoint (_ecae );
_bdg =_bdg .AppendPoint (_ggb );for _ ,_bea :=range _bdb .Points [1:len (_bdb .Points )-1]{_bdg =_bdg .AppendPoint (_bea );};_bdg =_bdg .AppendPoint (_gff );_bdg =_bdg .AppendPoint (_cged );_bdg =_bdg .AppendPoint (_gbe );_bdb =_bdg ;};_fga :=_d .NewContentCreator ();
_fga .Add_q ().SetNonStrokingColor (_dbgf .LineColor );if len (gsName )> 1{_fga .Add_gs (_b .PdfObjectName (gsName ));};_bdb =_bdb .Offset (_dbgf .X1 ,_dbgf .Y1 );_daed :=_bdb .GetBoundingBox ();DrawPathWithCreator (_bdb ,_fga );if _dbgf .LineStyle ==LineStyleDashed {_fga .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_fga .Add_f ().Add_Q ();};return _fga .Bytes (),_daed .ToPdfRectangle (),nil ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_dad Polyline )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){if _dad .LineColor ==nil {_dad .LineColor =_c .NewPdfColorDeviceRGB (0,0,0);};_acf :=NewPath ();for _ ,_dfd :=range _dad .Points {_acf =_acf .AppendPoint (_dfd );};_abb :=_d .NewContentCreator ();
_abb .Add_q ().SetStrokingColor (_dad .LineColor ).Add_w (_dad .LineWidth );if len (gsName )> 1{_abb .Add_gs (_b .PdfObjectName (gsName ));};DrawPathWithCreator (_acf ,_abb );_abb .Add_S ();_abb .Add_Q ();return _abb .Bytes (),_acf .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_ca Path )RemovePoint (number int )Path {if number < 1||number > len (_ca .Points ){return _ca ;};_ge :=number -1;_ca .Points =append (_ca .Points [:_ge ],_ca .Points [_ge +1:]...);return _ca ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _c .PdfColor ;LineWidth float64 ;};

// GetBoundingBox returns the bounding box of the path.
func (_ad Path )GetBoundingBox ()BoundingBox {_ddd :=BoundingBox {};_bg :=0.0;_dgb :=0.0;_gd :=0.0;_dee :=0.0;for _cb ,_caaa :=range _ad .Points {if _cb ==0{_bg =_caaa .X ;_dgb =_caaa .X ;_gd =_caaa .Y ;_dee =_caaa .Y ;continue ;};if _caaa .X < _bg {_bg =_caaa .X ;
};if _caaa .X > _dgb {_dgb =_caaa .X ;};if _caaa .Y < _gd {_gd =_caaa .Y ;};if _caaa .Y > _dee {_dee =_caaa .Y ;};};_ddd .X =_bg ;_ddd .Y =_gd ;_ddd .Width =_dgb -_bg ;_ddd .Height =_dee -_gd ;return _ddd ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_gge Vector )GetPolarAngle ()float64 {return _e .Atan2 (_gge .Dy ,_gge .Dx )};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _c .PdfColor ;FillEnabled bool ;FillColor _c .PdfColor ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_ab CubicBezierCurve )GetBounds ()_c .PdfRectangle {_db :=_ab .P0 .X ;_cf :=_ab .P0 .X ;_gf :=_ab .P0 .Y ;_ed :=_ab .P0 .Y ;for _f :=0.0;_f <=1.0;_f +=0.001{Rx :=_ab .P0 .X *_e .Pow (1-_f ,3)+_ab .P1 .X *3*_f *_e .Pow (1-_f ,2)+_ab .P2 .X *3*_e .Pow (_f ,2)*(1-_f )+_ab .P3 .X *_e .Pow (_f ,3);
Ry :=_ab .P0 .Y *_e .Pow (1-_f ,3)+_ab .P1 .Y *3*_f *_e .Pow (1-_f ,2)+_ab .P2 .Y *3*_e .Pow (_f ,2)*(1-_f )+_ab .P3 .Y *_e .Pow (_f ,3);if Rx < _db {_db =Rx ;};if Rx > _cf {_cf =Rx ;};if Ry < _gf {_gf =Ry ;};if Ry > _ed {_ed =Ry ;};};_ac :=_c .PdfRectangle {};
_ac .Llx =_db ;_ac .Lly =_gf ;_ac .Urx =_cf ;_ac .Ury =_ed ;return _ac ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_g :=CubicBezierCurve {};_g .P0 =NewPoint (x0 ,y0 );_g .P1 =NewPoint (x1 ,y1 );_g .P2 =NewPoint (x2 ,y2 );_g .P3 =NewPoint (x3 ,y3 );return _g ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_baf :=Vector {};_baf .Dx =b .X -a .X ;_baf .Dy =b .Y -a .Y ;return _baf ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_be CubicBezierPath )GetBoundingBox ()Rectangle {_cg :=Rectangle {};_dc :=0.0;_edg :=0.0;_dce :=0.0;_af :=0.0;for _de ,_cfe :=range _be .Curves {_ff :=_cfe .GetBounds ();if _de ==0{_dc =_ff .Llx ;_edg =_ff .Urx ;_dce =_ff .Lly ;_af =_ff .Ury ;continue ;
};if _ff .Llx < _dc {_dc =_ff .Llx ;};if _ff .Urx > _edg {_edg =_ff .Urx ;};if _ff .Lly < _dce {_dce =_ff .Lly ;};if _ff .Ury > _af {_af =_ff .Ury ;};};_cg .X =_dc ;_cg .Y =_dce ;_cg .Width =_edg -_dc ;_cg .Height =_af -_dce ;return _cg ;};

// Offset shifts the path with the specified offsets.
func (_fc Path )Offset (offX ,offY float64 )Path {for _fg ,_gfe :=range _fc .Points {_fc .Points [_fg ]=_gfe .Add (offX ,offY );};return _fc ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_bb CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_bb .P0 .X +=offX ;_bb .P1 .X +=offX ;_bb .P2 .X +=offX ;_bb .P3 .X +=offX ;_bb .P0 .Y +=offY ;_bb .P1 .Y +=offY ;_bb .P2 .Y +=offY ;_bb .P3 .Y +=offY ;return _bb ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _c .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _c .PdfColor ;Opacity float64 ;};

// AddVector adds vector to a point.
func (_dga Point )AddVector (v Vector )Point {_dga .X +=v .Dx ;_dga .Y +=v .Dy ;return _dga };const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// Copy returns a clone of the path.
func (_gg Path )Copy ()Path {_dcd :=Path {};_dcd .Points =append (_dcd .Points ,_gg .Points ...);return _dcd ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _c .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_afab BasicLine )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_edd :=_afab .LineWidth ;_gfg :=NewPath ();_gfg =_gfg .AppendPoint (NewPoint (_afab .X1 ,_afab .Y1 ));_gfg =_gfg .AppendPoint (NewPoint (_afab .X2 ,_afab .Y2 ));_beg :=_d .NewContentCreator ();
_aece :=_gfg .GetBoundingBox ();DrawPathWithCreator (_gfg ,_beg );if _afab .LineStyle ==LineStyleDashed {_beg .Add_d ([]int64 {1,1},0);};_beg .SetStrokingColor (_afab .LineColor ).Add_w (_edd ).Add_S ().Add_Q ();return _beg .Bytes (),_aece .ToPdfRectangle (),nil ;
};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_bag :=Vector {};_bag .Dx =length *_e .Cos (theta );_bag .Dy =length *_e .Sin (theta );return _bag ;};

// Add adds the specified vector to the current one and returns the result.
func (_cfeb Vector )Add (other Vector )Vector {_cfeb .Dx +=other .Dx ;_cfeb .Dy +=other .Dy ;return _cfeb ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Flip changes the sign of the vector: -vector.
func (_dfe Vector )Flip ()Vector {_bafe :=_dfe .Magnitude ();_edb :=_dfe .GetPolarAngle ();_dfe .Dx =_bafe *_e .Cos (_edb +_e .Pi );_dfe .Dy =_bafe *_e .Sin (_edb +_e .Pi );return _dfe ;};

// FlipY flips the sign of the Dy component of the vector.
func (_bab Vector )FlipY ()Vector {_bab .Dy =-_bab .Dy ;return _bab };

// FlipX flips the sign of the Dx component of the vector.
func (_bbg Vector )FlipX ()Vector {_bbg .Dx =-_bbg .Dx ;return _bbg };

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_dbd Circle )Draw (gsName string )([]byte ,*_c .PdfRectangle ,error ){_fb :=_dbd .Width /2;_ddb :=_dbd .Height /2;if _dbd .BorderEnabled {_fb -=_dbd .BorderWidth /2;_ddb -=_dbd .BorderWidth /2;};_dcef :=0.551784;_ef :=_fb *_dcef ;_cfd :=_ddb *_dcef ;
_da :=NewCubicBezierPath ();_da =_da .AppendCurve (NewCubicBezierCurve (-_fb ,0,-_fb ,_cfd ,-_ef ,_ddb ,0,_ddb ));_da =_da .AppendCurve (NewCubicBezierCurve (0,_ddb ,_ef ,_ddb ,_fb ,_cfd ,_fb ,0));_da =_da .AppendCurve (NewCubicBezierCurve (_fb ,0,_fb ,-_cfd ,_ef ,-_ddb ,0,-_ddb ));
_da =_da .AppendCurve (NewCubicBezierCurve (0,-_ddb ,-_ef ,-_ddb ,-_fb ,-_cfd ,-_fb ,0));_da =_da .Offset (_fb ,_ddb );if _dbd .BorderEnabled {_da =_da .Offset (_dbd .BorderWidth /2,_dbd .BorderWidth /2);};if _dbd .X !=0||_dbd .Y !=0{_da =_da .Offset (_dbd .X ,_dbd .Y );
};_ce :=_d .NewContentCreator ();_ce .Add_q ();if _dbd .FillEnabled {_ce .SetNonStrokingColor (_dbd .FillColor );};if _dbd .BorderEnabled {_ce .SetStrokingColor (_dbd .BorderColor );_ce .Add_w (_dbd .BorderWidth );};if len (gsName )> 1{_ce .Add_gs (_b .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_da ,_ce );_ce .Add_h ();if _dbd .FillEnabled &&_dbd .BorderEnabled {_ce .Add_B ();}else if _dbd .FillEnabled {_ce .Add_f ();}else if _dbd .BorderEnabled {_ce .Add_S ();};_ce .Add_Q ();_cd :=_da .GetBoundingBox ();if _dbd .BorderEnabled {_cd .Height +=_dbd .BorderWidth ;
_cd .Width +=_dbd .BorderWidth ;_cd .X -=_dbd .BorderWidth /2;_cd .Y -=_dbd .BorderWidth /2;};return _ce .Bytes (),_cd .ToPdfRectangle (),nil ;};

// Rotate rotates the vector by the specified angle.
func (_aedd Vector )Rotate (phi float64 )Vector {_dca :=_aedd .Magnitude ();_ffd :=_aedd .GetPolarAngle ();return NewVectorPolar (_dca ,_ffd +phi );};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _c .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};