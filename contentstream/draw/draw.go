//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_f "fmt";_gd "github.com/unidoc/unipdf/v3/contentstream";_d "github.com/unidoc/unipdf/v3/core";_b "github.com/unidoc/unipdf/v3/internal/transform";_a "github.com/unidoc/unipdf/v3/model";_c "math";);

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_gb Path )RemovePoint (number int )Path {if number < 1||number > len (_gb .Points ){return _gb ;};_ac :=number -1;_gb .Points =append (_gb .Points [:_ac ],_gb .Points [_ac +1:]...);return _gb ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _a .PdfColor ;FillEnabled bool ;FillColor _a .PdfColor ;};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_feg Line )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_ebb ,_eg :=_feg .X1 ,_feg .X2 ;_ebg ,_baa :=_feg .Y1 ,_feg .Y2 ;_dbb :=_baa -_ebg ;_abg :=_eg -_ebb ;_cbf :=_c .Atan2 (_dbb ,_abg );L :=_c .Sqrt (_c .Pow (_abg ,2.0)+_c .Pow (_dbb ,2.0));
_ceee :=_feg .LineWidth ;_dcd :=_c .Pi ;_bb :=1.0;if _abg < 0{_bb *=-1.0;};if _dbb < 0{_bb *=-1.0;};VsX :=_bb *(-_ceee /2*_c .Cos (_cbf +_dcd /2));VsY :=_bb *(-_ceee /2*_c .Sin (_cbf +_dcd /2)+_ceee *_c .Sin (_cbf +_dcd /2));V1X :=VsX +_ceee /2*_c .Cos (_cbf +_dcd /2);
V1Y :=VsY +_ceee /2*_c .Sin (_cbf +_dcd /2);V2X :=VsX +_ceee /2*_c .Cos (_cbf +_dcd /2)+L *_c .Cos (_cbf );V2Y :=VsY +_ceee /2*_c .Sin (_cbf +_dcd /2)+L *_c .Sin (_cbf );V3X :=VsX +_ceee /2*_c .Cos (_cbf +_dcd /2)+L *_c .Cos (_cbf )+_ceee *_c .Cos (_cbf -_dcd /2);
V3Y :=VsY +_ceee /2*_c .Sin (_cbf +_dcd /2)+L *_c .Sin (_cbf )+_ceee *_c .Sin (_cbf -_dcd /2);V4X :=VsX +_ceee /2*_c .Cos (_cbf -_dcd /2);V4Y :=VsY +_ceee /2*_c .Sin (_cbf -_dcd /2);_degb :=NewPath ();_degb =_degb .AppendPoint (NewPoint (V1X ,V1Y ));_degb =_degb .AppendPoint (NewPoint (V2X ,V2Y ));
_degb =_degb .AppendPoint (NewPoint (V3X ,V3Y ));_degb =_degb .AppendPoint (NewPoint (V4X ,V4Y ));_cfb :=_feg .LineEndingStyle1 ;_bbg :=_feg .LineEndingStyle2 ;_cad :=3*_ceee ;_cac :=3*_ceee ;_bfe :=(_cac -_ceee )/2;if _bbg ==LineEndingStyleArrow {_egd :=_degb .GetPointNumber (2);
_fg :=NewVectorPolar (_cad ,_cbf +_dcd );_aad :=_egd .AddVector (_fg );_ggd :=NewVectorPolar (_cac /2,_cbf +_dcd /2);_bfg :=NewVectorPolar (_cad ,_cbf );_bfgf :=NewVectorPolar (_bfe ,_cbf +_dcd /2);_aaf :=_aad .AddVector (_bfgf );_bef :=_bfg .Add (_ggd .Flip ());
_edeb :=_aaf .AddVector (_bef );_bdg :=_ggd .Scale (2).Flip ().Add (_bef .Flip ());_bbf :=_edeb .AddVector (_bdg );_gc :=_aad .AddVector (NewVectorPolar (_ceee ,_cbf -_dcd /2));_cff :=NewPath ();_cff =_cff .AppendPoint (_degb .GetPointNumber (1));_cff =_cff .AppendPoint (_aad );
_cff =_cff .AppendPoint (_aaf );_cff =_cff .AppendPoint (_edeb );_cff =_cff .AppendPoint (_bbf );_cff =_cff .AppendPoint (_gc );_cff =_cff .AppendPoint (_degb .GetPointNumber (4));_degb =_cff ;};if _cfb ==LineEndingStyleArrow {_efc :=_degb .GetPointNumber (1);
_eba :=_degb .GetPointNumber (_degb .Length ());_ddc :=NewVectorPolar (_ceee /2,_cbf +_dcd +_dcd /2);_cbfa :=_efc .AddVector (_ddc );_dfd :=NewVectorPolar (_cad ,_cbf ).Add (NewVectorPolar (_cac /2,_cbf +_dcd /2));_gec :=_cbfa .AddVector (_dfd );_def :=NewVectorPolar (_bfe ,_cbf -_dcd /2);
_acg :=_gec .AddVector (_def );_gca :=NewVectorPolar (_cad ,_cbf );_cbee :=_eba .AddVector (_gca );_efg :=NewVectorPolar (_bfe ,_cbf +_dcd +_dcd /2);_gcf :=_cbee .AddVector (_efg );_eaf :=_cbfa ;_ga :=NewPath ();_ga =_ga .AppendPoint (_cbfa );_ga =_ga .AppendPoint (_gec );
_ga =_ga .AppendPoint (_acg );for _ ,_acd :=range _degb .Points [1:len (_degb .Points )-1]{_ga =_ga .AppendPoint (_acd );};_ga =_ga .AppendPoint (_cbee );_ga =_ga .AppendPoint (_gcf );_ga =_ga .AppendPoint (_eaf );_degb =_ga ;};_egda :=_gd .NewContentCreator ();
_egda .Add_q ().SetNonStrokingColor (_feg .LineColor );if len (gsName )> 1{_egda .Add_gs (_d .PdfObjectName (gsName ));};_degb =_degb .Offset (_feg .X1 ,_feg .Y1 );_efb :=_degb .GetBoundingBox ();DrawPathWithCreator (_degb ,_egda );if _feg .LineStyle ==LineStyleDashed {_egda .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_egda .Add_f ().Add_Q ();};return _egda .Bytes (),_efb .ToPdfRectangle (),nil ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_bcc :=Vector {};_bcc .Dx =dx ;_bcc .Dy =dy ;return _bcc };

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_ag BasicLine )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_fcf :=_ag .LineWidth ;_bad :=NewPath ();_bad =_bad .AppendPoint (NewPoint (_ag .X1 ,_ag .Y1 ));_bad =_bad .AppendPoint (NewPoint (_ag .X2 ,_ag .Y2 ));_ff :=_gd .NewContentCreator ();
_ddf :=_bad .GetBoundingBox ();DrawPathWithCreator (_bad ,_ff );if _ag .LineStyle ==LineStyleDashed {_ff .Add_d ([]int64 {1,1},0);};_ff .SetStrokingColor (_ag .LineColor ).Add_w (_fcf ).Add_S ().Add_Q ();return _ff .Bytes (),_ddf .ToPdfRectangle (),nil ;
};

// Add adds the specified vector to the current one and returns the result.
func (_ece Vector )Add (other Vector )Vector {_ece .Dx +=other .Dx ;_ece .Dy +=other .Dy ;return _ece };

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_cbd BoundingBox )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_cbd .X ,Lly :_cbd .Y ,Urx :_cbd .X +_cbd .Width ,Ury :_cbd .Y +_cbd .Height };};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_e :=CubicBezierCurve {};_e .P0 =NewPoint (x0 ,y0 );_e .P1 =NewPoint (x1 ,y1 );_e .P2 =NewPoint (x2 ,y2 );_e .P3 =NewPoint (x3 ,y3 );return _e ;};

// GetBoundingBox returns the bounding box of the path.
func (_bgc Path )GetBoundingBox ()BoundingBox {_gbg :=BoundingBox {};_gg :=0.0;_aae :=0.0;_bd :=0.0;_af :=0.0;for _cbe ,_fa :=range _bgc .Points {if _cbe ==0{_gg =_fa .X ;_aae =_fa .X ;_bd =_fa .Y ;_af =_fa .Y ;continue ;};if _fa .X < _gg {_gg =_fa .X ;
};if _fa .X > _aae {_aae =_fa .X ;};if _fa .Y < _bd {_bd =_fa .Y ;};if _fa .Y > _af {_af =_fa .Y ;};};_gbg .X =_gg ;_gbg .Y =_bd ;_gbg .Width =_aae -_gg ;_gbg .Height =_af -_bd ;return _gbg ;};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_fdf Circle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_ab :=_fdf .Width /2;_fcd :=_fdf .Height /2;if _fdf .BorderEnabled {_ab -=_fdf .BorderWidth /2;_fcd -=_fdf .BorderWidth /2;};_df :=0.551784;_abc :=_ab *_df ;_ba :=_fcd *_df ;_dde :=NewCubicBezierPath ();
_dde =_dde .AppendCurve (NewCubicBezierCurve (-_ab ,0,-_ab ,_ba ,-_abc ,_fcd ,0,_fcd ));_dde =_dde .AppendCurve (NewCubicBezierCurve (0,_fcd ,_abc ,_fcd ,_ab ,_ba ,_ab ,0));_dde =_dde .AppendCurve (NewCubicBezierCurve (_ab ,0,_ab ,-_ba ,_abc ,-_fcd ,0,-_fcd ));
_dde =_dde .AppendCurve (NewCubicBezierCurve (0,-_fcd ,-_abc ,-_fcd ,-_ab ,-_ba ,-_ab ,0));_dde =_dde .Offset (_ab ,_fcd );if _fdf .BorderEnabled {_dde =_dde .Offset (_fdf .BorderWidth /2,_fdf .BorderWidth /2);};if _fdf .X !=0||_fdf .Y !=0{_dde =_dde .Offset (_fdf .X ,_fdf .Y );
};_ddea :=_gd .NewContentCreator ();_ddea .Add_q ();if _fdf .FillEnabled {_ddea .SetNonStrokingColor (_fdf .FillColor );};if _fdf .BorderEnabled {_ddea .SetStrokingColor (_fdf .BorderColor );_ddea .Add_w (_fdf .BorderWidth );};if len (gsName )> 1{_ddea .Add_gs (_d .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_dde ,_ddea );_ddea .Add_h ();if _fdf .FillEnabled &&_fdf .BorderEnabled {_ddea .Add_B ();}else if _fdf .FillEnabled {_ddea .Add_f ();}else if _fdf .BorderEnabled {_ddea .Add_S ();};_ddea .Add_Q ();_ef :=_dde .GetBoundingBox ();
if _fdf .BorderEnabled {_ef .Height +=_fdf .BorderWidth ;_ef .Width +=_fdf .BorderWidth ;_ef .X -=_fdf .BorderWidth /2;_ef .Y -=_fdf .BorderWidth /2;};return _ddea .Bytes (),_ef .ToPdfRectangle (),nil ;};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_cg PolyBezierCurve )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _cg .BorderColor ==nil {_cg .BorderColor =_a .NewPdfColorDeviceRGB (0,0,0);};_cbdc :=NewCubicBezierPath ();for _ ,_aff :=range _cg .Curves {_cbdc =_cbdc .AppendCurve (_aff );
};_fcb :=_gd .NewContentCreator ();_fcb .Add_q ();_cg .FillEnabled =_cg .FillEnabled &&_cg .FillColor !=nil ;if _cg .FillEnabled {_fcb .SetNonStrokingColor (_cg .FillColor );};_fcb .SetStrokingColor (_cg .BorderColor );_fcb .Add_w (_cg .BorderWidth );if len (gsName )> 1{_fcb .Add_gs (_d .PdfObjectName (gsName ));
};for _gbga ,_ebf :=range _cbdc .Curves {if _gbga ==0{_fcb .Add_m (_ebf .P0 .X ,_ebf .P0 .Y );}else {_fcb .Add_l (_ebf .P0 .X ,_ebf .P0 .Y );};_fcb .Add_c (_ebf .P1 .X ,_ebf .P1 .Y ,_ebf .P2 .X ,_ebf .P2 .Y ,_ebf .P3 .X ,_ebf .P3 .Y );};if _cg .FillEnabled {_fcb .Add_h ();
_fcb .Add_B ();}else {_fcb .Add_S ();};_fcb .Add_Q ();return _fcb .Bytes (),_cbdc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_bea Path )GetPointNumber (number int )Point {if number < 1||number > len (_bea .Points ){return Point {};};return _bea .Points [number -1];};

// FlipY flips the sign of the Dy component of the vector.
func (_bfgb Vector )FlipY ()Vector {_bfgb .Dy =-_bfgb .Dy ;return _bfgb };

// Copy returns a clone of the Bezier path.
func (_fc CubicBezierPath )Copy ()CubicBezierPath {_dg :=CubicBezierPath {};_dg .Curves =append (_dg .Curves ,_fc .Curves ...);return _dg ;};

// Magnitude returns the magnitude of the vector.
func (_bee Vector )Magnitude ()float64 {return _c .Sqrt (_c .Pow (_bee .Dx ,2.0)+_c .Pow (_bee .Dy ,2.0))};

// Rotate rotates the vector by the specified angle.
func (_efa Vector )Rotate (phi float64 )Vector {_edac :=_efa .Magnitude ();_eaa :=_efa .GetPolarAngle ();return NewVectorPolar (_edac ,_eaa +phi );};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _a .PdfColor ;Opacity float64 ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_gdd CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_gdd .P0 .X +=offX ;_gdd .P1 .X +=offX ;_gdd .P2 .X +=offX ;_gdd .P3 .X +=offX ;_gdd .P0 .Y +=offY ;_gdd .P1 .Y +=offY ;_gdd .P2 .Y +=offY ;_gdd .P3 .Y +=offY ;return _gdd ;
};

// AddVector adds vector to a point.
func (_gfg Point )AddVector (v Vector )Point {_gfg .X +=v .Dx ;_gfg .Y +=v .Dy ;return _gfg };

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_cd CubicBezierCurve )GetBounds ()_a .PdfRectangle {_ec :=_cd .P0 .X ;_gf :=_cd .P0 .X ;_dc :=_cd .P0 .Y ;_aa :=_cd .P0 .Y ;for _ge :=0.0;_ge <=1.0;_ge +=0.001{Rx :=_cd .P0 .X *_c .Pow (1-_ge ,3)+_cd .P1 .X *3*_ge *_c .Pow (1-_ge ,2)+_cd .P2 .X *3*_c .Pow (_ge ,2)*(1-_ge )+_cd .P3 .X *_c .Pow (_ge ,3);
Ry :=_cd .P0 .Y *_c .Pow (1-_ge ,3)+_cd .P1 .Y *3*_ge *_c .Pow (1-_ge ,2)+_cd .P2 .Y *3*_c .Pow (_ge ,2)*(1-_ge )+_cd .P3 .Y *_c .Pow (_ge ,3);if Rx < _ec {_ec =Rx ;};if Rx > _gf {_gf =Rx ;};if Ry < _dc {_dc =Ry ;};if Ry > _aa {_aa =Ry ;};};_ed :=_a .PdfRectangle {};
_ed .Llx =_ec ;_ed .Lly =_dc ;_ed .Urx =_gf ;_ed .Ury =_aa ;return _ed ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_cee CurvePolygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_cfa :=_gd .NewContentCreator ();_cfa .Add_q ();_cee .FillEnabled =_cee .FillEnabled &&_cee .FillColor !=nil ;if _cee .FillEnabled {_cfa .SetNonStrokingColor (_cee .FillColor );
};_cee .BorderEnabled =_cee .BorderEnabled &&_cee .BorderColor !=nil ;if _cee .BorderEnabled {_cfa .SetStrokingColor (_cee .BorderColor );_cfa .Add_w (_cee .BorderWidth );};if len (gsName )> 1{_cfa .Add_gs (_d .PdfObjectName (gsName ));};_fb :=NewCubicBezierPath ();
for _ ,_fbc :=range _cee .Rings {for _cbc ,_bae :=range _fbc {if _cbc ==0{_cfa .Add_m (_bae .P0 .X ,_bae .P0 .Y );}else {_cfa .Add_l (_bae .P0 .X ,_bae .P0 .Y );};_cfa .Add_c (_bae .P1 .X ,_bae .P1 .Y ,_bae .P2 .X ,_bae .P2 .Y ,_bae .P3 .X ,_bae .P3 .Y );
_fb =_fb .AppendCurve (_bae );};_cfa .Add_h ();};if _cee .FillEnabled &&_cee .BorderEnabled {_cfa .Add_B ();}else if _cee .FillEnabled {_cfa .Add_f ();}else if _cee .BorderEnabled {_cfa .Add_S ();};_cfa .Add_Q ();return _cfa .Bytes (),_fb .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_ecf :=CubicBezierPath {};_ecf .Curves =[]CubicBezierCurve {};return _ecf ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_gd .ContentCreator ){for _acf ,_bec :=range bpath .Curves {if _acf ==0{creator .Add_m (_bec .P0 .X ,_bec .P0 .Y );};creator .Add_c (_bec .P1 .X ,_bec .P1 .Y ,_bec .P2 .X ,_bec .P2 .Y ,_bec .P3 .X ,_bec .P3 .Y );
};};

// Scale scales the vector by the specified factor.
func (_bce Vector )Scale (factor float64 )Vector {_bcec :=_bce .Magnitude ();_ae :=_bce .GetPolarAngle ();_bce .Dx =factor *_bcec *_c .Cos (_ae );_bce .Dy =factor *_bcec *_c .Sin (_ae );return _bce ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _a .PdfColor ;LineWidth float64 ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_cfg Point )Add (dx ,dy float64 )Point {_cfg .X +=dx ;_cfg .Y +=dy ;return _cfg };

// Copy returns a clone of the path.
func (_bc Path )Copy ()Path {_edef :=Path {};_edef .Points =append (_edef .Points ,_bc .Points ...);return _edef ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_ffe Polyline )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _ffe .LineColor ==nil {_ffe .LineColor =_a .NewPdfColorDeviceRGB (0,0,0);};_dgg :=NewPath ();for _ ,_gcg :=range _ffe .Points {_dgg =_dgg .AppendPoint (_gcg );};_fegd :=_gd .NewContentCreator ();
_fegd .Add_q ().SetStrokingColor (_ffe .LineColor ).Add_w (_ffe .LineWidth );if len (gsName )> 1{_fegd .Add_gs (_d .PdfObjectName (gsName ));};DrawPathWithCreator (_dgg ,_fegd );_fegd .Add_S ();_fegd .Add_Q ();return _fegd .Bytes (),_dgg .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Flip changes the sign of the vector: -vector.
func (_baeb Vector )Flip ()Vector {_dee :=_baeb .Magnitude ();_bde :=_baeb .GetPolarAngle ();_baeb .Dx =_dee *_c .Cos (_bde +_c .Pi );_baeb .Dy =_dee *_c .Sin (_bde +_c .Pi );return _baeb ;};

// Length returns the number of points in the path.
func (_eaed Path )Length ()int {return len (_eaed .Points )};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);func (_bcf Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_bcf .X ,_bcf .Y );};

// Draw draws the rectangle. Can specify a graphics state (gsName) for setting opacity etc.
// Otherwise leave empty (""). Returns the content stream as a byte array, bounding box and an error on failure.
func (_dcb Rectangle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_fec :=NewPath ();_fec =_fec .AppendPoint (NewPoint (0,0));_fec =_fec .AppendPoint (NewPoint (0,_dcb .Height ));_fec =_fec .AppendPoint (NewPoint (_dcb .Width ,_dcb .Height ));
_fec =_fec .AppendPoint (NewPoint (_dcb .Width ,0));_fec =_fec .AppendPoint (NewPoint (0,0));if _dcb .X !=0||_dcb .Y !=0{_fec =_fec .Offset (_dcb .X ,_dcb .Y );};_beb :=_gd .NewContentCreator ();_beb .Add_q ();if _dcb .FillEnabled {_beb .SetNonStrokingColor (_dcb .FillColor );
};if _dcb .BorderEnabled {_beb .SetStrokingColor (_dcb .BorderColor );_beb .Add_w (_dcb .BorderWidth );};if len (gsName )> 1{_beb .Add_gs (_d .PdfObjectName (gsName ));};DrawPathWithCreator (_fec ,_beb );_beb .Add_h ();if _dcb .FillEnabled &&_dcb .BorderEnabled {_beb .Add_B ();
}else if _dcb .FillEnabled {_beb .Add_f ();}else if _dcb .BorderEnabled {_beb .Add_S ();};_beb .Add_Q ();return _beb .Bytes (),_fec .GetBoundingBox ().ToPdfRectangle (),nil ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_ede CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_ede .Curves =append (_ede .Curves ,curve );return _ede ;};

// Offset shifts the Bezier path with the specified offsets.
func (_cf CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _edg ,_bf :=range _cf .Curves {_cf .Curves [_edg ]=_bf .AddOffsetXY (offX ,offY );};return _cf ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_ceb :=Vector {};_ceb .Dx =length *_c .Cos (theta );_ceb .Dy =length *_c .Sin (theta );return _ceb ;};

// FlipX flips the sign of the Dx component of the vector.
func (_aab Vector )FlipX ()Vector {_aab .Dx =-_aab .Dx ;return _aab };

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// AppendPoint adds the specified point to the path.
func (_cb Path )AppendPoint (point Point )Path {_cb .Points =append (_cb .Points ,point );return _cb };

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _a .PdfColor ;Opacity float64 ;};

// Offset shifts the path with the specified offsets.
func (_ce Path )Offset (offX ,offY float64 )Path {for _eb ,_fd :=range _ce .Points {_ce .Points [_eb ]=_fd .Add (offX ,offY );};return _ce ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_eda Rectangle )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_eda .X ,Lly :_eda .Y ,Urx :_eda .X +_eda .Width ,Ury :_eda .Y +_eda .Height };};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_dd CubicBezierPath )GetBoundingBox ()Rectangle {_ad :=Rectangle {};_be :=0.0;_ea :=0.0;_db :=0.0;_eae :=0.0;for _ca ,_bg :=range _dd .Curves {_de :=_bg .GetBounds ();if _ca ==0{_be =_de .Llx ;_ea =_de .Urx ;_db =_de .Lly ;_eae =_de .Ury ;continue ;
};if _de .Llx < _be {_be =_de .Llx ;};if _de .Urx > _ea {_ea =_de .Urx ;};if _de .Lly < _db {_db =_de .Lly ;};if _de .Ury > _eae {_eae =_de .Ury ;};};_ad .X =_be ;_ad .Y =_db ;_ad .Width =_ea -_be ;_ad .Height =_eae -_db ;return _ad ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_bdb Point )Rotate (theta float64 )Point {_gfga :=_b .NewPoint (_bdb .X ,_bdb .Y ).Rotate (theta );return NewPoint (_gfga .X ,_gfga .Y );};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;
);

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_fge Vector )GetPolarAngle ()float64 {return _c .Atan2 (_fge .Dy ,_fge .Dx )};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_fe Polygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_ebfb :=_gd .NewContentCreator ();_ebfb .Add_q ();_fe .FillEnabled =_fe .FillEnabled &&_fe .FillColor !=nil ;if _fe .FillEnabled {_ebfb .SetNonStrokingColor (_fe .FillColor );};
_fe .BorderEnabled =_fe .BorderEnabled &&_fe .BorderColor !=nil ;if _fe .BorderEnabled {_ebfb .SetStrokingColor (_fe .BorderColor );_ebfb .Add_w (_fe .BorderWidth );};if len (gsName )> 1{_ebfb .Add_gs (_d .PdfObjectName (gsName ));};_deg :=NewPath ();for _ ,_dcg :=range _fe .Points {for _ecb ,_bgb :=range _dcg {_deg =_deg .AppendPoint (_bgb );
if _ecb ==0{_ebfb .Add_m (_bgb .X ,_bgb .Y );}else {_ebfb .Add_l (_bgb .X ,_bgb .Y );};};_ebfb .Add_h ();};if _fe .FillEnabled &&_fe .BorderEnabled {_ebfb .Add_B ();}else if _fe .FillEnabled {_ebfb .Add_f ();}else if _fe .BorderEnabled {_ebfb .Add_S ();
};_ebfb .Add_Q ();return _ebfb .Bytes (),_deg .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_gd .ContentCreator ){for _afc ,_ebc :=range path .Points {if _afc ==0{creator .Add_m (_ebc .X ,_ebc .Y );}else {creator .Add_l (_ebc .X ,_ebc .Y );};};};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_adff :=Vector {};_adff .Dx =b .X -a .X ;_adff .Dy =b .Y -a .Y ;return _adff ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;