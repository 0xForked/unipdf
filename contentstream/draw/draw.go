//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_cf "fmt";_ba "github.com/unidoc/unipdf/v3/contentstream";_b "github.com/unidoc/unipdf/v3/core";_bag "github.com/unidoc/unipdf/v3/internal/transform";_f "github.com/unidoc/unipdf/v3/model";_g "math";);

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_bagc :=Vector {};_bagc .Dx =dx ;_bagc .Dy =dy ;return _bagc };

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _f .PdfColor ;Opacity float64 ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderColor _f .PdfColor ;BorderWidth float64 ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_gg CubicBezierPath )GetBoundingBox ()Rectangle {_aea :=Rectangle {};_bg :=0.0;_fa :=0.0;_aeb :=0.0;_ga :=0.0;for _bf ,_ebf :=range _gg .Curves {_ee :=_ebf .GetBounds ();if _bf ==0{_bg =_ee .Llx ;_fa =_ee .Urx ;_aeb =_ee .Lly ;_ga =_ee .Ury ;continue ;
};if _ee .Llx < _bg {_bg =_ee .Llx ;};if _ee .Urx > _fa {_fa =_ee .Urx ;};if _ee .Lly < _aeb {_aeb =_ee .Lly ;};if _ee .Ury > _ga {_ga =_ee .Ury ;};};_aea .X =_bg ;_aea .Y =_aeb ;_aea .Width =_fa -_bg ;_aea .Height =_ga -_aeb ;return _aea ;};

// Rotate rotates the vector by the specified angle.
func (_edf Vector )Rotate (phi float64 )Vector {_bedf :=_edf .Magnitude ();_gag :=_edf .GetPolarAngle ();return NewVectorPolar (_bedf ,_gag +phi );};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _f .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_a CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_a .P0 .X +=offX ;_a .P1 .X +=offX ;_a .P2 .X +=offX ;_a .P3 .X +=offX ;_a .P0 .Y +=offY ;_a .P1 .Y +=offY ;_a .P2 .Y +=offY ;_a .P3 .Y +=offY ;return _a ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_gfcg :=Vector {};_gfcg .Dx =b .X -a .X ;_gfcg .Dy =b .Y -a .Y ;return _gfcg ;};

// AppendPoint adds the specified point to the path.
func (_da Path )AppendPoint (point Point )Path {_da .Points =append (_da .Points ,point );return _da };

// AddVector adds vector to a point.
func (_adf Point )AddVector (v Vector )Point {_adf .X +=v .Dx ;_adf .Y +=v .Dy ;return _adf };

// Flip changes the sign of the vector: -vector.
func (_aga Vector )Flip ()Vector {_cd :=_aga .Magnitude ();_bbbgc :=_aga .GetPolarAngle ();_aga .Dx =_cd *_g .Cos (_bbbgc +_g .Pi );_aga .Dy =_cd *_g .Sin (_bbbgc +_g .Pi );return _aga ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_de Circle )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_bfa :=_de .Width /2;_edg :=_de .Height /2;if _de .BorderEnabled {_bfa -=_de .BorderWidth /2;_edg -=_de .BorderWidth /2;};_dc :=0.551784;_fab :=_bfa *_dc ;_ff :=_edg *_dc ;_fae :=NewCubicBezierPath ();
_fae =_fae .AppendCurve (NewCubicBezierCurve (-_bfa ,0,-_bfa ,_ff ,-_fab ,_edg ,0,_edg ));_fae =_fae .AppendCurve (NewCubicBezierCurve (0,_edg ,_fab ,_edg ,_bfa ,_ff ,_bfa ,0));_fae =_fae .AppendCurve (NewCubicBezierCurve (_bfa ,0,_bfa ,-_ff ,_fab ,-_edg ,0,-_edg ));
_fae =_fae .AppendCurve (NewCubicBezierCurve (0,-_edg ,-_fab ,-_edg ,-_bfa ,-_ff ,-_bfa ,0));_fae =_fae .Offset (_bfa ,_edg );if _de .BorderEnabled {_fae =_fae .Offset (_de .BorderWidth /2,_de .BorderWidth /2);};if _de .X !=0||_de .Y !=0{_fae =_fae .Offset (_de .X ,_de .Y );
};_gf :=_ba .NewContentCreator ();_gf .Add_q ();if _de .FillEnabled {_gf .SetNonStrokingColor (_de .FillColor );};if _de .BorderEnabled {_gf .SetStrokingColor (_de .BorderColor );_gf .Add_w (_de .BorderWidth );};if len (gsName )> 1{_gf .Add_gs (_b .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_fae ,_gf );_gf .Add_h ();if _de .FillEnabled &&_de .BorderEnabled {_gf .Add_B ();}else if _de .FillEnabled {_gf .Add_f ();}else if _de .BorderEnabled {_gf .Add_S ();};_gf .Add_Q ();_cac :=_fae .GetBoundingBox ();if _de .BorderEnabled {_cac .Height +=_de .BorderWidth ;
_cac .Width +=_de .BorderWidth ;_cac .X -=_de .BorderWidth /2;_cac .Y -=_de .BorderWidth /2;};return _gf .Bytes (),_cac .ToPdfRectangle (),nil ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_fb CubicBezierCurve )GetBounds ()_f .PdfRectangle {_e :=_fb .P0 .X ;_ae :=_fb .P0 .X ;_fg :=_fb .P0 .Y ;_fgc :=_fb .P0 .Y ;for _eb :=0.0;_eb <=1.0;_eb +=0.001{Rx :=_fb .P0 .X *_g .Pow (1-_eb ,3)+_fb .P1 .X *3*_eb *_g .Pow (1-_eb ,2)+_fb .P2 .X *3*_g .Pow (_eb ,2)*(1-_eb )+_fb .P3 .X *_g .Pow (_eb ,3);
Ry :=_fb .P0 .Y *_g .Pow (1-_eb ,3)+_fb .P1 .Y *3*_eb *_g .Pow (1-_eb ,2)+_fb .P2 .Y *3*_g .Pow (_eb ,2)*(1-_eb )+_fb .P3 .Y *_g .Pow (_eb ,3);if Rx < _e {_e =Rx ;};if Rx > _ae {_ae =Rx ;};if Ry < _fg {_fg =Ry ;};if Ry > _fgc {_fgc =Ry ;};};_bd :=_f .PdfRectangle {};
_bd .Llx =_e ;_bd .Lly =_fg ;_bd .Urx =_ae ;_bd .Ury =_fgc ;return _bd ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_aef CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_aef .Curves =append (_aef .Curves ,curve );return _aef ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_bff Vector )GetPolarAngle ()float64 {return _g .Atan2 (_bff .Dy ,_bff .Dx )};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_bb CurvePolygon )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_ada :=_ba .NewContentCreator ();_ada .Add_q ();_bb .FillEnabled =_bb .FillEnabled &&_bb .FillColor !=nil ;if _bb .FillEnabled {_ada .SetNonStrokingColor (_bb .FillColor );
};_bb .BorderEnabled =_bb .BorderEnabled &&_bb .BorderColor !=nil ;if _bb .BorderEnabled {_ada .SetStrokingColor (_bb .BorderColor );_ada .Add_w (_bb .BorderWidth );};if len (gsName )> 1{_ada .Add_gs (_b .PdfObjectName (gsName ));};_cff :=NewCubicBezierPath ();
for _ ,_edd :=range _bb .Rings {for _dac ,_dg :=range _edd {if _dac ==0{_ada .Add_m (_dg .P0 .X ,_dg .P0 .Y );}else {_ada .Add_l (_dg .P0 .X ,_dg .P0 .Y );};_ada .Add_c (_dg .P1 .X ,_dg .P1 .Y ,_dg .P2 .X ,_dg .P2 .Y ,_dg .P3 .X ,_dg .P3 .Y );_cff =_cff .AppendCurve (_dg );
};_ada .Add_h ();};if _bb .FillEnabled &&_bb .BorderEnabled {_ada .Add_B ();}else if _bb .FillEnabled {_ada .Add_f ();}else if _bb .BorderEnabled {_ada .Add_S ();};_ada .Add_Q ();return _ada .Bytes (),_cff .GetBoundingBox ().ToPdfRectangle (),nil ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_gb :=CubicBezierCurve {};_gb .P0 =NewPoint (x0 ,y0 );_gb .P1 =NewPoint (x1 ,y1 );_gb .P2 =NewPoint (x2 ,y2 );_gb .P3 =NewPoint (x3 ,y3 );return _gb ;};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// FlipX flips the sign of the Dx component of the vector.
func (_adg Vector )FlipX ()Vector {_adg .Dx =-_adg .Dx ;return _adg };

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _f .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_faf Point )Rotate (theta float64 )Point {_gc :=_bag .NewPoint (_faf .X ,_faf .Y ).Rotate (theta );return NewPoint (_gc .X ,_gc .Y );};

// GetBoundingBox returns the bounding box of the path.
func (_ad Path )GetBoundingBox ()BoundingBox {_gdg :=BoundingBox {};_ce :=0.0;_fe :=0.0;_cb :=0.0;_gdf :=0.0;for _ec ,_bed :=range _ad .Points {if _ec ==0{_ce =_bed .X ;_fe =_bed .X ;_cb =_bed .Y ;_gdf =_bed .Y ;continue ;};if _bed .X < _ce {_ce =_bed .X ;
};if _bed .X > _fe {_fe =_bed .X ;};if _bed .Y < _cb {_cb =_bed .Y ;};if _bed .Y > _gdf {_gdf =_bed .Y ;};};_gdg .X =_ce ;_gdg .Y =_cb ;_gdg .Width =_fe -_ce ;_gdg .Height =_gdf -_cb ;return _gdg ;};

// Offset shifts the Bezier path with the specified offsets.
func (_ef CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _gd ,_be :=range _ef .Curves {_ef .Curves [_gd ]=_be .AddOffsetXY (offX ,offY );};return _ef ;};

// FlipY flips the sign of the Dy component of the vector.
func (_dff Vector )FlipY ()Vector {_dff .Dy =-_dff .Dy ;return _dff };

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_gda BasicLine )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_gfb :=_gda .LineWidth ;_adee :=NewPath ();_adee =_adee .AppendPoint (NewPoint (_gda .X1 ,_gda .Y1 ));_adee =_adee .AppendPoint (NewPoint (_gda .X2 ,_gda .Y2 ));_aff :=_ba .NewContentCreator ();
_afc :=_adee .GetBoundingBox ();DrawPathWithCreator (_adee ,_aff );if _gda .LineStyle ==LineStyleDashed {_aff .Add_d ([]int64 {1,1},0);};_aff .SetStrokingColor (_gda .LineColor ).Add_w (_gfb ).Add_S ().Add_Q ();return _aff .Bytes (),_afc .ToPdfRectangle (),nil ;
};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_dd Line )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_gba ,_bee :=_dd .X1 ,_dd .X2 ;_ccd ,_cbf :=_dd .Y1 ,_dd .Y2 ;_fea :=_cbf -_ccd ;_caf :=_bee -_gba ;_bgg :=_g .Atan2 (_fea ,_caf );L :=_g .Sqrt (_g .Pow (_caf ,2.0)+_g .Pow (_fea ,2.0));
_fbga :=_dd .LineWidth ;_aca :=_g .Pi ;_ede :=1.0;if _caf < 0{_ede *=-1.0;};if _fea < 0{_ede *=-1.0;};VsX :=_ede *(-_fbga /2*_g .Cos (_bgg +_aca /2));VsY :=_ede *(-_fbga /2*_g .Sin (_bgg +_aca /2)+_fbga *_g .Sin (_bgg +_aca /2));V1X :=VsX +_fbga /2*_g .Cos (_bgg +_aca /2);
V1Y :=VsY +_fbga /2*_g .Sin (_bgg +_aca /2);V2X :=VsX +_fbga /2*_g .Cos (_bgg +_aca /2)+L *_g .Cos (_bgg );V2Y :=VsY +_fbga /2*_g .Sin (_bgg +_aca /2)+L *_g .Sin (_bgg );V3X :=VsX +_fbga /2*_g .Cos (_bgg +_aca /2)+L *_g .Cos (_bgg )+_fbga *_g .Cos (_bgg -_aca /2);
V3Y :=VsY +_fbga /2*_g .Sin (_bgg +_aca /2)+L *_g .Sin (_bgg )+_fbga *_g .Sin (_bgg -_aca /2);V4X :=VsX +_fbga /2*_g .Cos (_bgg -_aca /2);V4Y :=VsY +_fbga /2*_g .Sin (_bgg -_aca /2);_edgf :=NewPath ();_edgf =_edgf .AppendPoint (NewPoint (V1X ,V1Y ));_edgf =_edgf .AppendPoint (NewPoint (V2X ,V2Y ));
_edgf =_edgf .AppendPoint (NewPoint (V3X ,V3Y ));_edgf =_edgf .AppendPoint (NewPoint (V4X ,V4Y ));_df :=_dd .LineEndingStyle1 ;_eeb :=_dd .LineEndingStyle2 ;_bea :=3*_fbga ;_fc :=3*_fbga ;_dgb :=(_fc -_fbga )/2;if _eeb ==LineEndingStyleArrow {_bba :=_edgf .GetPointNumber (2);
_fbb :=NewVectorPolar (_bea ,_bgg +_aca );_edc :=_bba .AddVector (_fbb );_ffg :=NewVectorPolar (_fc /2,_bgg +_aca /2);_bca :=NewVectorPolar (_bea ,_bgg );_gcf :=NewVectorPolar (_dgb ,_bgg +_aca /2);_eda :=_edc .AddVector (_gcf );_bbb :=_bca .Add (_ffg .Flip ());
_bcc :=_eda .AddVector (_bbb );_ceg :=_ffg .Scale (2).Flip ().Add (_bbb .Flip ());_gac :=_bcc .AddVector (_ceg );_egf :=_edc .AddVector (NewVectorPolar (_fbga ,_bgg -_aca /2));_fd :=NewPath ();_fd =_fd .AppendPoint (_edgf .GetPointNumber (1));_fd =_fd .AppendPoint (_edc );
_fd =_fd .AppendPoint (_eda );_fd =_fd .AppendPoint (_bcc );_fd =_fd .AppendPoint (_gac );_fd =_fd .AppendPoint (_egf );_fd =_fd .AppendPoint (_edgf .GetPointNumber (4));_edgf =_fd ;};if _df ==LineEndingStyleArrow {_fff :=_edgf .GetPointNumber (1);_fag :=_edgf .GetPointNumber (_edgf .Length ());
_ffd :=NewVectorPolar (_fbga /2,_bgg +_aca +_aca /2);_fbf :=_fff .AddVector (_ffd );_eec :=NewVectorPolar (_bea ,_bgg ).Add (NewVectorPolar (_fc /2,_bgg +_aca /2));_cbeb :=_fbf .AddVector (_eec );_fce :=NewVectorPolar (_dgb ,_bgg -_aca /2);_acg :=_cbeb .AddVector (_fce );
_dbef :=NewVectorPolar (_bea ,_bgg );_bbbg :=_fag .AddVector (_dbef );_bfb :=NewVectorPolar (_dgb ,_bgg +_aca +_aca /2);_cea :=_bbbg .AddVector (_bfb );_ceb :=_fbf ;_bgc :=NewPath ();_bgc =_bgc .AppendPoint (_fbf );_bgc =_bgc .AppendPoint (_cbeb );_bgc =_bgc .AppendPoint (_acg );
for _ ,_aebe :=range _edgf .Points [1:len (_edgf .Points )-1]{_bgc =_bgc .AppendPoint (_aebe );};_bgc =_bgc .AppendPoint (_bbbg );_bgc =_bgc .AppendPoint (_cea );_bgc =_bgc .AppendPoint (_ceb );_edgf =_bgc ;};_cbef :=_ba .NewContentCreator ();_cbef .Add_q ().SetNonStrokingColor (_dd .LineColor );
if len (gsName )> 1{_cbef .Add_gs (_b .PdfObjectName (gsName ));};_edgf =_edgf .Offset (_dd .X1 ,_dd .Y1 );_eefe :=_edgf .GetBoundingBox ();DrawPathWithCreator (_edgf ,_cbef );if _dd .LineStyle ==LineStyleDashed {_cbef .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_cbef .Add_f ().Add_Q ();};return _cbef .Bytes (),_eefe .ToPdfRectangle (),nil ;};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_ba .ContentCreator ){for _fcg ,_dab :=range bpath .Curves {if _fcg ==0{creator .Add_m (_dab .P0 .X ,_dab .P0 .Y );};creator .Add_c (_dab .P1 .X ,_dab .P1 .Y ,_dab .P2 .X ,_dab .P2 .Y ,_dab .P3 .X ,_dab .P3 .Y );
};};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _f .PdfColor ;LineWidth float64 ;};

// Copy returns a clone of the path.
func (_ca Path )Copy ()Path {_aa :=Path {};_aa .Points =append (_aa .Points ,_ca .Points ...);return _aa ;};

// Offset shifts the path with the specified offsets.
func (_gbc Path )Offset (offX ,offY float64 )Path {for _db ,_ed :=range _gbc .Points {_gbc .Points [_db ]=_ed .Add (offX ,offY );};return _gbc ;};

// Add adds the specified vector to the current one and returns the result.
func (_bcd Vector )Add (other Vector )Vector {_bcd .Dx +=other .Dx ;_bcd .Dy +=other .Dy ;return _bcd };

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Length returns the number of points in the path.
func (_bc Path )Length ()int {return len (_bc .Points )};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_fga Point )Add (dx ,dy float64 )Point {_fga .X +=dx ;_fga .Y +=dy ;return _fga };

// Copy returns a clone of the Bezier path.
func (_d CubicBezierPath )Copy ()CubicBezierPath {_af :=CubicBezierPath {};_af .Curves =append (_af .Curves ,_d .Curves ...);return _af ;};

// Scale scales the vector by the specified factor.
func (_gff Vector )Scale (factor float64 )Vector {_dfc :=_gff .Magnitude ();_dec :=_gff .GetPolarAngle ();_gff .Dx =factor *_dfc *_g .Cos (_dec );_gff .Dy =factor *_dfc *_g .Sin (_dec );return _gff ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_eg BoundingBox )ToPdfRectangle ()*_f .PdfRectangle {return &_f .PdfRectangle {Llx :_eg .X ,Lly :_eg .Y ,Urx :_eg .X +_eg .Width ,Ury :_eg .Y +_eg .Height };};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_ba .ContentCreator ){for _aefa ,_efb :=range path .Points {if _aefa ==0{creator .Add_m (_efb .X ,_efb .Y );}else {creator .Add_l (_efb .X ,_efb .Y );};};};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _f .PdfColor ;FillEnabled bool ;FillColor _f .PdfColor ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _f .PdfColor ;Opacity float64 ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_eaa Polyline )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){if _eaa .LineColor ==nil {_eaa .LineColor =_f .NewPdfColorDeviceRGB (0,0,0);};_bec :=NewPath ();for _ ,_fgg :=range _eaa .Points {_bec =_bec .AppendPoint (_fgg );};_gfc :=_ba .NewContentCreator ();
_gfc .Add_q ().SetStrokingColor (_eaa .LineColor ).Add_w (_eaa .LineWidth );if len (gsName )> 1{_gfc .Add_gs (_b .PdfObjectName (gsName ));};DrawPathWithCreator (_bec ,_gfc );_gfc .Add_S ();_gfc .Add_Q ();return _gfc .Bytes (),_bec .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Magnitude returns the magnitude of the vector.
func (_agd Vector )Magnitude ()float64 {return _g .Sqrt (_g .Pow (_agd .Dx ,2.0)+_g .Pow (_agd .Dy ,2.0))};

// Draw draws the rectangle. Can specify a graphics state (gsName) for setting opacity etc.
// Otherwise leave empty (""). Returns the content stream as a byte array, bounding box and an error on failure.
func (_afg Rectangle )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_eef :=NewPath ();_eef =_eef .AppendPoint (NewPoint (0,0));_eef =_eef .AppendPoint (NewPoint (0,_afg .Height ));_eef =_eef .AppendPoint (NewPoint (_afg .Width ,_afg .Height ));
_eef =_eef .AppendPoint (NewPoint (_afg .Width ,0));_eef =_eef .AppendPoint (NewPoint (0,0));if _afg .X !=0||_afg .Y !=0{_eef =_eef .Offset (_afg .X ,_afg .Y );};_age :=_ba .NewContentCreator ();_age .Add_q ();if _afg .FillEnabled {_age .SetNonStrokingColor (_afg .FillColor );
};if _afg .BorderEnabled {_age .SetStrokingColor (_afg .BorderColor );_age .Add_w (_afg .BorderWidth );};if len (gsName )> 1{_age .Add_gs (_b .PdfObjectName (gsName ));};DrawPathWithCreator (_eef ,_age );_age .Add_h ();if _afg .FillEnabled &&_afg .BorderEnabled {_age .Add_B ();
}else if _afg .FillEnabled {_age .Add_f ();}else if _afg .BorderEnabled {_age .Add_S ();};_age .Add_Q ();return _age .Bytes (),_eef .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_fafb Polygon )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_eee :=_ba .NewContentCreator ();_eee .Add_q ();_fafb .FillEnabled =_fafb .FillEnabled &&_fafb .FillColor !=nil ;if _fafb .FillEnabled {_eee .SetNonStrokingColor (_fafb .FillColor );
};_fafb .BorderEnabled =_fafb .BorderEnabled &&_fafb .BorderColor !=nil ;if _fafb .BorderEnabled {_eee .SetStrokingColor (_fafb .BorderColor );_eee .Add_w (_fafb .BorderWidth );};if len (gsName )> 1{_eee .Add_gs (_b .PdfObjectName (gsName ));};_gbb :=NewPath ();
for _ ,_fbg :=range _fafb .Points {for _gfa ,_ced :=range _fbg {_gbb =_gbb .AppendPoint (_ced );if _gfa ==0{_eee .Add_m (_ced .X ,_ced .Y );}else {_eee .Add_l (_ced .X ,_ced .Y );};};_eee .Add_h ();};if _fafb .FillEnabled &&_fafb .BorderEnabled {_eee .Add_B ();
}else if _fafb .FillEnabled {_eee .Add_f ();}else if _fafb .BorderEnabled {_eee .Add_S ();};_eee .Add_Q ();return _eee .Bytes (),_gbb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_efe Path )GetPointNumber (number int )Point {if number < 1||number > len (_efe .Points ){return Point {};};return _efe .Points [number -1];};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_ea :=CubicBezierPath {};_ea .Curves =[]CubicBezierCurve {};return _ea ;};func (_aebc Point )String ()string {return _cf .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_aebc .X ,_aebc .Y );
};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;);

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderColor _f .PdfColor ;BorderWidth float64 ;};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_ag Path )RemovePoint (number int )Path {if number < 1||number > len (_ag .Points ){return _ag ;};_bdc :=number -1;_ag .Points =append (_ag .Points [:_bdc ],_ag .Points [_bdc +1:]...);return _ag ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_cc Rectangle )ToPdfRectangle ()*_f .PdfRectangle {return &_f .PdfRectangle {Llx :_cc .X ,Lly :_cc .Y ,Urx :_cc .X +_cc .Width ,Ury :_cc .Y +_cc .Height };};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_bfe PolyBezierCurve )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){if _bfe .BorderColor ==nil {_bfe .BorderColor =_f .NewPdfColorDeviceRGB (0,0,0);};_ac :=NewCubicBezierPath ();for _ ,_agb :=range _bfe .Curves {_ac =_ac .AppendCurve (_agb );
};_ade :=_ba .NewContentCreator ();_ade .Add_q ();_bfe .FillEnabled =_bfe .FillEnabled &&_bfe .FillColor !=nil ;if _bfe .FillEnabled {_ade .SetNonStrokingColor (_bfe .FillColor );};_ade .SetStrokingColor (_bfe .BorderColor );_ade .Add_w (_bfe .BorderWidth );
if len (gsName )> 1{_ade .Add_gs (_b .PdfObjectName (gsName ));};for _gce ,_cbe :=range _ac .Curves {if _gce ==0{_ade .Add_m (_cbe .P0 .X ,_cbe .P0 .Y );}else {_ade .Add_l (_cbe .P0 .X ,_cbe .P0 .Y );};_ade .Add_c (_cbe .P1 .X ,_cbe .P1 .Y ,_cbe .P2 .X ,_cbe .P2 .Y ,_cbe .P3 .X ,_cbe .P3 .Y );
};if _bfe .FillEnabled {_ade .Add_h ();_ade .Add_B ();}else {_ade .Add_S ();};_ade .Add_Q ();return _ade .Bytes (),_ac .GetBoundingBox ().ToPdfRectangle (),nil ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_ge :=Vector {};_ge .Dx =length *_g .Cos (theta );_ge .Dy =length *_g .Sin (theta );return _ge ;};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;