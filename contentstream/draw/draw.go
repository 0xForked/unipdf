//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_g "fmt";_d "github.com/unidoc/unipdf/v3/contentstream";_f "github.com/unidoc/unipdf/v3/core";_e "github.com/unidoc/unipdf/v3/internal/transform";_a "github.com/unidoc/unipdf/v3/model";_cg "math";);

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_dacc Polyline )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _dacc .LineColor ==nil {_dacc .LineColor =_a .NewPdfColorDeviceRGB (0,0,0);};_dfc :=NewPath ();for _ ,_dce :=range _dacc .Points {_dfc =_dfc .AppendPoint (_dce );};_de :=_d .NewContentCreator ();
_de .Add_q ().SetStrokingColor (_dacc .LineColor ).Add_w (_dacc .LineWidth );if len (gsName )> 1{_de .Add_gs (_f .PdfObjectName (gsName ));};DrawPathWithCreator (_dfc ,_de );_de .Add_S ();_de .Add_Q ();return _de .Bytes (),_dfc .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// AddVector adds vector to a point.
func (_gf Point )AddVector (v Vector )Point {_gf .X +=v .Dx ;_gf .Y +=v .Dy ;return _gf };

// Copy returns a clone of the Bezier path.
func (_ef CubicBezierPath )Copy ()CubicBezierPath {_fd :=CubicBezierPath {};_fd .Curves =append (_fd .Curves ,_ef .Curves ...);return _fd ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_d .ContentCreator ){for _gbea ,_fcg :=range path .Points {if _gbea ==0{creator .Add_m (_fcg .X ,_fcg .Y );}else {creator .Add_l (_fcg .X ,_fcg .Y );};};};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;
);

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Offset shifts the path with the specified offsets.
func (_acd Path )Offset (offX ,offY float64 )Path {for _bd ,_ga :=range _acd .Points {_acd .Points [_bd ]=_ga .Add (offX ,offY );};return _acd ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_ggg Polygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_abb :=_d .NewContentCreator ();_abb .Add_q ();_ggg .FillEnabled =_ggg .FillEnabled &&_ggg .FillColor !=nil ;if _ggg .FillEnabled {_abb .SetNonStrokingColor (_ggg .FillColor );
};_ggg .BorderEnabled =_ggg .BorderEnabled &&_ggg .BorderColor !=nil ;if _ggg .BorderEnabled {_abb .SetStrokingColor (_ggg .BorderColor );_abb .Add_w (_ggg .BorderWidth );};if len (gsName )> 1{_abb .Add_gs (_f .PdfObjectName (gsName ));};_feg :=NewPath ();
for _ ,_ebd :=range _ggg .Points {for _dag ,_fg :=range _ebd {_feg =_feg .AppendPoint (_fg );if _dag ==0{_abb .Add_m (_fg .X ,_fg .Y );}else {_abb .Add_l (_fg .X ,_fg .Y );};};_abb .Add_h ();};if _ggg .FillEnabled &&_ggg .BorderEnabled {_abb .Add_B ();
}else if _ggg .FillEnabled {_abb .Add_f ();}else if _ggg .BorderEnabled {_abb .Add_S ();};_abb .Add_Q ();return _abb .Bytes (),_feg .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_bde CurvePolygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_aab :=_d .NewContentCreator ();_aab .Add_q ();_bde .FillEnabled =_bde .FillEnabled &&_bde .FillColor !=nil ;if _bde .FillEnabled {_aab .SetNonStrokingColor (_bde .FillColor );
};_bde .BorderEnabled =_bde .BorderEnabled &&_bde .BorderColor !=nil ;if _bde .BorderEnabled {_aab .SetStrokingColor (_bde .BorderColor );_aab .Add_w (_bde .BorderWidth );};if len (gsName )> 1{_aab .Add_gs (_f .PdfObjectName (gsName ));};_dcb :=NewCubicBezierPath ();
for _ ,_cc :=range _bde .Rings {for _fbd ,_bbb :=range _cc {if _fbd ==0{_aab .Add_m (_bbb .P0 .X ,_bbb .P0 .Y );}else {_aab .Add_l (_bbb .P0 .X ,_bbb .P0 .Y );};_aab .Add_c (_bbb .P1 .X ,_bbb .P1 .Y ,_bbb .P2 .X ,_bbb .P2 .Y ,_bbb .P3 .X ,_bbb .P3 .Y );
_dcb =_dcb .AppendCurve (_bbb );};_aab .Add_h ();};if _bde .FillEnabled &&_bde .BorderEnabled {_aab .Add_B ();}else if _bde .FillEnabled {_aab .Add_f ();}else if _bde .BorderEnabled {_aab .Add_S ();};_aab .Add_Q ();return _aab .Bytes (),_dcb .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};func (_bdg Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_bdg .X ,_bdg .Y );};

// Flip changes the sign of the vector: -vector.
func (_eeb Vector )Flip ()Vector {_fae :=_eeb .Magnitude ();_cga :=_eeb .GetPolarAngle ();_eeb .Dx =_fae *_cg .Cos (_cga +_cg .Pi );_eeb .Dy =_fae *_cg .Sin (_cga +_cg .Pi );return _eeb ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_ggb Rectangle )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_ggb .X ,Lly :_ggb .Y ,Urx :_ggb .X +_ggb .Width ,Ury :_ggb .Y +_ggb .Height };};

// Scale scales the vector by the specified factor.
func (_cdc Vector )Scale (factor float64 )Vector {_dcf :=_cdc .Magnitude ();_cbc :=_cdc .GetPolarAngle ();_cdc .Dx =factor *_dcf *_cg .Cos (_cbc );_cdc .Dy =factor *_dcf *_cg .Sin (_cbc );return _cdc ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_dagb :=Vector {};_dagb .Dx =dx ;_dagb .Dy =dy ;return _dagb };

// Draw draws the rectangle. Can specify a graphics state (gsName) for setting opacity etc.
// Otherwise leave empty (""). Returns the content stream as a byte array, bounding box and an error on failure.
func (_ccf Rectangle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_aeb :=NewPath ();_aeb =_aeb .AppendPoint (NewPoint (0,0));_aeb =_aeb .AppendPoint (NewPoint (0,_ccf .Height ));_aeb =_aeb .AppendPoint (NewPoint (_ccf .Width ,_ccf .Height ));
_aeb =_aeb .AppendPoint (NewPoint (_ccf .Width ,0));_aeb =_aeb .AppendPoint (NewPoint (0,0));if _ccf .X !=0||_ccf .Y !=0{_aeb =_aeb .Offset (_ccf .X ,_ccf .Y );};_fge :=_d .NewContentCreator ();_fge .Add_q ();if _ccf .FillEnabled {_fge .SetNonStrokingColor (_ccf .FillColor );
};if _ccf .BorderEnabled {_fge .SetStrokingColor (_ccf .BorderColor );_fge .Add_w (_ccf .BorderWidth );};if len (gsName )> 1{_fge .Add_gs (_f .PdfObjectName (gsName ));};DrawPathWithCreator (_aeb ,_fge );_fge .Add_h ();if _ccf .FillEnabled &&_ccf .BorderEnabled {_fge .Add_B ();
}else if _ccf .FillEnabled {_fge .Add_f ();}else if _ccf .BorderEnabled {_fge .Add_S ();};_fge .Add_Q ();return _fge .Bytes (),_aeb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _a .PdfColor ;Opacity float64 ;};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_d .ContentCreator ){for _gfa ,_dbdg :=range bpath .Curves {if _gfa ==0{creator .Add_m (_dbdg .P0 .X ,_dbdg .P0 .Y );};creator .Add_c (_dbdg .P1 .X ,_dbdg .P1 .Y ,_dbdg .P2 .X ,_dbdg .P2 .Y ,_dbdg .P3 .X ,_dbdg .P3 .Y );
};};

// Length returns the number of points in the path.
func (_bg Path )Length ()int {return len (_bg .Points )};

// AppendPoint adds the specified point to the path.
func (_efe Path )AppendPoint (point Point )Path {_efe .Points =append (_efe .Points ,point );return _efe };

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_eg :=CubicBezierCurve {};_eg .P0 =NewPoint (x0 ,y0 );_eg .P1 =NewPoint (x1 ,y1 );_eg .P2 =NewPoint (x2 ,y2 );_eg .P3 =NewPoint (x3 ,y3 );return _eg ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_ecf Point )Rotate (theta float64 )Point {_ee :=_e .NewPoint (_ecf .X ,_ecf .Y ).Rotate (theta );return NewPoint (_ee .X ,_ee .Y );};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// GetBoundingBox returns the bounding box of the path.
func (_bc Path )GetBoundingBox ()BoundingBox {_acf :=BoundingBox {};_egae :=0.0;_ge :=0.0;_fbb :=0.0;_cb :=0.0;for _eca ,_agc :=range _bc .Points {if _eca ==0{_egae =_agc .X ;_ge =_agc .X ;_fbb =_agc .Y ;_cb =_agc .Y ;continue ;};if _agc .X < _egae {_egae =_agc .X ;
};if _agc .X > _ge {_ge =_agc .X ;};if _agc .Y < _fbb {_fbb =_agc .Y ;};if _agc .Y > _cb {_cb =_agc .Y ;};};_acf .X =_egae ;_acf .Y =_fbb ;_acf .Width =_ge -_egae ;_acf .Height =_cb -_fbb ;return _acf ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _a .PdfColor ;Opacity float64 ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_ab CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_ab .Curves =append (_ab .Curves ,curve );return _ab ;};

// Copy returns a clone of the path.
func (_gc Path )Copy ()Path {_cgg :=Path {};_cgg .Points =append (_cgg .Points ,_gc .Points ...);return _cgg ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_fbba :=Vector {};_fbba .Dx =b .X -a .X ;_fbba .Dy =b .Y -a .Y ;return _fbba ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_add BasicLine )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_bee :=_add .LineWidth ;_dcg :=NewPath ();_dcg =_dcg .AppendPoint (NewPoint (_add .X1 ,_add .Y1 ));_dcg =_dcg .AppendPoint (NewPoint (_add .X2 ,_add .Y2 ));_abf :=_d .NewContentCreator ();
_gfb :=_dcg .GetBoundingBox ();DrawPathWithCreator (_dcg ,_abf );if _add .LineStyle ==LineStyleDashed {_abf .Add_d ([]int64 {1,1},0);};_abf .SetStrokingColor (_add .LineColor ).Add_w (_bee ).Add_S ().Add_Q ();return _abf .Bytes (),_gfb .ToPdfRectangle (),nil ;
};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;);

// FlipY flips the sign of the Dy component of the vector.
func (_bgaf Vector )FlipY ()Vector {_bgaf .Dy =-_bgaf .Dy ;return _bgaf };

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_aad Vector )GetPolarAngle ()float64 {return _cg .Atan2 (_aad .Dy ,_aad .Dx )};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_fbe Line )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_dac ,_bf :=_fbe .X1 ,_fbe .X2 ;_ecd ,_aea :=_fbe .Y1 ,_fbe .Y2 ;_ebg :=_aea -_ecd ;_bfb :=_bf -_dac ;_ecc :=_cg .Atan2 (_ebg ,_bfb );L :=_cg .Sqrt (_cg .Pow (_bfb ,2.0)+_cg .Pow (_ebg ,2.0));
_eaf :=_fbe .LineWidth ;_agg :=_cg .Pi ;_egd :=1.0;if _bfb < 0{_egd *=-1.0;};if _ebg < 0{_egd *=-1.0;};VsX :=_egd *(-_eaf /2*_cg .Cos (_ecc +_agg /2));VsY :=_egd *(-_eaf /2*_cg .Sin (_ecc +_agg /2)+_eaf *_cg .Sin (_ecc +_agg /2));V1X :=VsX +_eaf /2*_cg .Cos (_ecc +_agg /2);
V1Y :=VsY +_eaf /2*_cg .Sin (_ecc +_agg /2);V2X :=VsX +_eaf /2*_cg .Cos (_ecc +_agg /2)+L *_cg .Cos (_ecc );V2Y :=VsY +_eaf /2*_cg .Sin (_ecc +_agg /2)+L *_cg .Sin (_ecc );V3X :=VsX +_eaf /2*_cg .Cos (_ecc +_agg /2)+L *_cg .Cos (_ecc )+_eaf *_cg .Cos (_ecc -_agg /2);
V3Y :=VsY +_eaf /2*_cg .Sin (_ecc +_agg /2)+L *_cg .Sin (_ecc )+_eaf *_cg .Sin (_ecc -_agg /2);V4X :=VsX +_eaf /2*_cg .Cos (_ecc -_agg /2);V4Y :=VsY +_eaf /2*_cg .Sin (_ecc -_agg /2);_gda :=NewPath ();_gda =_gda .AppendPoint (NewPoint (V1X ,V1Y ));_gda =_gda .AppendPoint (NewPoint (V2X ,V2Y ));
_gda =_gda .AppendPoint (NewPoint (V3X ,V3Y ));_gda =_gda .AppendPoint (NewPoint (V4X ,V4Y ));_aeg :=_fbe .LineEndingStyle1 ;_ca :=_fbe .LineEndingStyle2 ;_fc :=3*_eaf ;_eef :=3*_eaf ;_gdaf :=(_eef -_eaf )/2;if _ca ==LineEndingStyleArrow {_fbc :=_gda .GetPointNumber (2);
_eab :=NewVectorPolar (_fc ,_ecc +_agg );_bfbd :=_fbc .AddVector (_eab );_bbe :=NewVectorPolar (_eef /2,_ecc +_agg /2);_bdf :=NewVectorPolar (_fc ,_ecc );_dbd :=NewVectorPolar (_gdaf ,_ecc +_agg /2);_fec :=_bfbd .AddVector (_dbd );_cff :=_bdf .Add (_bbe .Flip ());
_edf :=_fec .AddVector (_cff );_ceb :=_bbe .Scale (2).Flip ().Add (_cff .Flip ());_fgc :=_edf .AddVector (_ceb );_ggd :=_bfbd .AddVector (NewVectorPolar (_eaf ,_ecc -_agg /2));_bfc :=NewPath ();_bfc =_bfc .AppendPoint (_gda .GetPointNumber (1));_bfc =_bfc .AppendPoint (_bfbd );
_bfc =_bfc .AppendPoint (_fec );_bfc =_bfc .AppendPoint (_edf );_bfc =_bfc .AppendPoint (_fgc );_bfc =_bfc .AppendPoint (_ggd );_bfc =_bfc .AppendPoint (_gda .GetPointNumber (4));_gda =_bfc ;};if _aeg ==LineEndingStyleArrow {_fgcg :=_gda .GetPointNumber (1);
_fcf :=_gda .GetPointNumber (_gda .Length ());_dbdf :=NewVectorPolar (_eaf /2,_ecc +_agg +_agg /2);_dgc :=_fgcg .AddVector (_dbdf );_cd :=NewVectorPolar (_fc ,_ecc ).Add (NewVectorPolar (_eef /2,_ecc +_agg /2));_dbg :=_dgc .AddVector (_cd );_caa :=NewVectorPolar (_gdaf ,_ecc -_agg /2);
_daee :=_dbg .AddVector (_caa );_fed :=NewVectorPolar (_fc ,_ecc );_eabc :=_fcf .AddVector (_fed );_dfb :=NewVectorPolar (_gdaf ,_ecc +_agg +_agg /2);_fac :=_eabc .AddVector (_dfb );_aae :=_dgc ;_gee :=NewPath ();_gee =_gee .AppendPoint (_dgc );_gee =_gee .AppendPoint (_dbg );
_gee =_gee .AppendPoint (_daee );for _ ,_ddf :=range _gda .Points [1:len (_gda .Points )-1]{_gee =_gee .AppendPoint (_ddf );};_gee =_gee .AppendPoint (_eabc );_gee =_gee .AppendPoint (_fac );_gee =_gee .AppendPoint (_aae );_gda =_gee ;};_fgd :=_d .NewContentCreator ();
_fgd .Add_q ().SetNonStrokingColor (_fbe .LineColor );if len (gsName )> 1{_fgd .Add_gs (_f .PdfObjectName (gsName ));};_gda =_gda .Offset (_fbe .X1 ,_fbe .Y1 );_cbgc :=_gda .GetBoundingBox ();DrawPathWithCreator (_gda ,_fgd );if _fbe .LineStyle ==LineStyleDashed {_fgd .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_fgd .Add_f ().Add_Q ();};return _fgd .Bytes (),_cbgc .ToPdfRectangle (),nil ;};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_adf Path )RemovePoint (number int )Path {if number < 1||number > len (_adf .Points ){return _adf ;};_ce :=number -1;_adf .Points =append (_adf .Points [:_ce ],_adf .Points [_ce +1:]...);return _adf ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_fdf :=Vector {};_fdf .Dx =length *_cg .Cos (theta );_fdf .Dy =length *_cg .Sin (theta );return _fdf ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_cba PolyBezierCurve )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _cba .BorderColor ==nil {_cba .BorderColor =_a .NewPdfColorDeviceRGB (0,0,0);};_dd :=NewCubicBezierPath ();for _ ,_bce :=range _cba .Curves {_dd =_dd .AppendCurve (_bce );
};_cbg :=_d .NewContentCreator ();_cbg .Add_q ();_cba .FillEnabled =_cba .FillEnabled &&_cba .FillColor !=nil ;if _cba .FillEnabled {_cbg .SetNonStrokingColor (_cba .FillColor );};_cbg .SetStrokingColor (_cba .BorderColor );_cbg .Add_w (_cba .BorderWidth );
if len (gsName )> 1{_cbg .Add_gs (_f .PdfObjectName (gsName ));};for _cfc ,_bbc :=range _dd .Curves {if _cfc ==0{_cbg .Add_m (_bbc .P0 .X ,_bbc .P0 .Y );}else {_cbg .Add_l (_bbc .P0 .X ,_bbc .P0 .Y );};_cbg .Add_c (_bbc .P1 .X ,_bbc .P1 .Y ,_bbc .P2 .X ,_bbc .P2 .Y ,_bbc .P3 .X ,_bbc .P3 .Y );
};if _cba .FillEnabled {_cbg .Add_h ();_cbg .Add_B ();}else {_cbg .Add_S ();};_cbg .Add_Q ();return _cbg .Bytes (),_dd .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Offset shifts the Bezier path with the specified offsets.
func (_ae CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _bb ,_da :=range _ae .Curves {_ae .Curves [_bb ]=_da .AddOffsetXY (offX ,offY );};return _ae ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _a .PdfColor ;LineWidth float64 ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_ac :=CubicBezierPath {};_ac .Curves =[]CubicBezierCurve {};return _ac ;};

// Rotate rotates the vector by the specified angle.
func (_cbf Vector )Rotate (phi float64 )Vector {_cdg :=_cbf .Magnitude ();_fda :=_cbf .GetPolarAngle ();return NewVectorPolar (_cdg ,_fda +phi );};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_edg Circle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_eff :=_edg .Width /2;_cgc :=_edg .Height /2;if _edg .BorderEnabled {_eff -=_edg .BorderWidth /2;_cgc -=_edg .BorderWidth /2;};_be :=0.551784;_ba :=_eff *_be ;_aa :=_cgc *_be ;
_fff :=NewCubicBezierPath ();_fff =_fff .AppendCurve (NewCubicBezierCurve (-_eff ,0,-_eff ,_aa ,-_ba ,_cgc ,0,_cgc ));_fff =_fff .AppendCurve (NewCubicBezierCurve (0,_cgc ,_ba ,_cgc ,_eff ,_aa ,_eff ,0));_fff =_fff .AppendCurve (NewCubicBezierCurve (_eff ,0,_eff ,-_aa ,_ba ,-_cgc ,0,-_cgc ));
_fff =_fff .AppendCurve (NewCubicBezierCurve (0,-_cgc ,-_ba ,-_cgc ,-_eff ,-_aa ,-_eff ,0));_fff =_fff .Offset (_eff ,_cgc );if _edg .BorderEnabled {_fff =_fff .Offset (_edg .BorderWidth /2,_edg .BorderWidth /2);};if _edg .X !=0||_edg .Y !=0{_fff =_fff .Offset (_edg .X ,_edg .Y );
};_gae :=_d .NewContentCreator ();_gae .Add_q ();if _edg .FillEnabled {_gae .SetNonStrokingColor (_edg .FillColor );};if _edg .BorderEnabled {_gae .SetStrokingColor (_edg .BorderColor );_gae .Add_w (_edg .BorderWidth );};if len (gsName )> 1{_gae .Add_gs (_f .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_fff ,_gae );_gae .Add_h ();if _edg .FillEnabled &&_edg .BorderEnabled {_gae .Add_B ();}else if _edg .FillEnabled {_gae .Add_f ();}else if _edg .BorderEnabled {_gae .Add_S ();};_gae .Add_Q ();_beb :=_fff .GetBoundingBox ();
if _edg .BorderEnabled {_beb .Height +=_edg .BorderWidth ;_beb .Width +=_edg .BorderWidth ;_beb .X -=_edg .BorderWidth /2;_beb .Y -=_edg .BorderWidth /2;};return _gae .Bytes (),_beb .ToPdfRectangle (),nil ;};

// Add adds the specified vector to the current one and returns the result.
func (_bga Vector )Add (other Vector )Vector {_bga .Dx +=other .Dx ;_bga .Dy +=other .Dy ;return _bga };

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_gbe Point )Add (dx ,dy float64 )Point {_gbe .X +=dx ;_gbe .Y +=dy ;return _gbe };

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _a .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_df CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_df .P0 .X +=offX ;_df .P1 .X +=offX ;_df .P2 .X +=offX ;_df .P3 .X +=offX ;_df .P0 .Y +=offY ;_df .P1 .Y +=offY ;_df .P2 .Y +=offY ;_df .P3 .Y +=offY ;return _df ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_gb BoundingBox )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_gb .X ,Lly :_gb .Y ,Urx :_gb .X +_gb .Width ,Ury :_gb .Y +_gb .Height };};

// GetBounds returns the bounding box of the Bezier curve.
func (_ff CubicBezierCurve )GetBounds ()_a .PdfRectangle {_ec :=_ff .P0 .X ;_ea :=_ff .P0 .X ;_ed :=_ff .P0 .Y ;_b :=_ff .P0 .Y ;for _ega :=0.0;_ega <=1.0;_ega +=0.001{Rx :=_ff .P0 .X *_cg .Pow (1-_ega ,3)+_ff .P1 .X *3*_ega *_cg .Pow (1-_ega ,2)+_ff .P2 .X *3*_cg .Pow (_ega ,2)*(1-_ega )+_ff .P3 .X *_cg .Pow (_ega ,3);
Ry :=_ff .P0 .Y *_cg .Pow (1-_ega ,3)+_ff .P1 .Y *3*_ega *_cg .Pow (1-_ega ,2)+_ff .P2 .Y *3*_cg .Pow (_ega ,2)*(1-_ega )+_ff .P3 .Y *_cg .Pow (_ega ,3);if Rx < _ec {_ec =Rx ;};if Rx > _ea {_ea =Rx ;};if Ry < _ed {_ed =Ry ;};if Ry > _b {_b =Ry ;};};_db :=_a .PdfRectangle {};
_db .Llx =_ec ;_db .Lly =_ed ;_db .Urx =_ea ;_db .Ury =_b ;return _db ;};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _a .PdfColor ;BorderEnabled bool ;BorderColor _a .PdfColor ;BorderWidth float64 ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_cf CubicBezierPath )GetBoundingBox ()Rectangle {_eb :=Rectangle {};_daf :=0.0;_ad :=0.0;_dc :=0.0;_dae :=0.0;for _fe ,_fb :=range _cf .Curves {_ag :=_fb .GetBounds ();if _fe ==0{_daf =_ag .Llx ;_ad =_ag .Urx ;_dc =_ag .Lly ;_dae =_ag .Ury ;continue ;
};if _ag .Llx < _daf {_daf =_ag .Llx ;};if _ag .Urx > _ad {_ad =_ag .Urx ;};if _ag .Lly < _dc {_dc =_ag .Lly ;};if _ag .Ury > _dae {_dae =_ag .Ury ;};};_eb .X =_daf ;_eb .Y =_dc ;_eb .Width =_ad -_daf ;_eb .Height =_dae -_dc ;return _eb ;};

// Magnitude returns the magnitude of the vector.
func (_gdg Vector )Magnitude ()float64 {return _cg .Sqrt (_cg .Pow (_gdg .Dx ,2.0)+_cg .Pow (_gdg .Dy ,2.0));};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_gg Path )GetPointNumber (number int )Point {if number < 1||number > len (_gg .Points ){return Point {};};return _gg .Points [number -1];};

// FlipX flips the sign of the Dx component of the vector.
func (_cfd Vector )FlipX ()Vector {_cfd .Dx =-_cfd .Dx ;return _cfd };

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _a .PdfColor ;FillEnabled bool ;FillColor _a .PdfColor ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};