//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_gf "fmt";_d "github.com/unidoc/unipdf/v3/contentstream";_c "github.com/unidoc/unipdf/v3/core";_a "github.com/unidoc/unipdf/v3/internal/transform";_f "github.com/unidoc/unipdf/v3/model";_b "math";);

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// FlipY flips the sign of the Dy component of the vector.
func (_deba Vector )FlipY ()Vector {_deba .Dy =-_deba .Dy ;return _deba };

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_ff CurvePolygon )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_ccf :=_d .NewContentCreator ();_ccf .Add_q ();_ff .FillEnabled =_ff .FillEnabled &&_ff .FillColor !=nil ;if _ff .FillEnabled {_ccf .SetNonStrokingColor (_ff .FillColor );
};_ff .BorderEnabled =_ff .BorderEnabled &&_ff .BorderColor !=nil ;if _ff .BorderEnabled {_ccf .SetStrokingColor (_ff .BorderColor );_ccf .Add_w (_ff .BorderWidth );};if len (gsName )> 1{_ccf .Add_gs (_c .PdfObjectName (gsName ));};_fba :=NewCubicBezierPath ();
for _ ,_dcb :=range _ff .Rings {for _cggg ,_eefg :=range _dcb {if _cggg ==0{_ccf .Add_m (_eefg .P0 .X ,_eefg .P0 .Y );}else {_ccf .Add_l (_eefg .P0 .X ,_eefg .P0 .Y );};_ccf .Add_c (_eefg .P1 .X ,_eefg .P1 .Y ,_eefg .P2 .X ,_eefg .P2 .Y ,_eefg .P3 .X ,_eefg .P3 .Y );
_fba =_fba .AppendCurve (_eefg );};_ccf .Add_h ();};if _ff .FillEnabled &&_ff .BorderEnabled {_ccf .Add_B ();}else if _ff .FillEnabled {_ccf .Add_f ();}else if _ff .BorderEnabled {_ccf .Add_S ();};_ccf .Add_Q ();return _ccf .Bytes (),_fba .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Copy returns a clone of the path.
func (_gee Path )Copy ()Path {_cec :=Path {};_cec .Points =append (_cec .Points ,_gee .Points ...);return _cec ;};

// Copy returns a clone of the Bezier path.
func (_bfg CubicBezierPath )Copy ()CubicBezierPath {_dg :=CubicBezierPath {};_dg .Curves =append (_dg .Curves ,_bfg .Curves ...);return _dg ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderColor _f .PdfColor ;BorderWidth float64 ;};

// GetBoundingBox returns the bounding box of the path.
func (_ec Path )GetBoundingBox ()BoundingBox {_eg :=BoundingBox {};_aa :=0.0;_gc :=0.0;_fa :=0.0;_cg :=0.0;for _cgg ,_gfa :=range _ec .Points {if _cgg ==0{_aa =_gfa .X ;_gc =_gfa .X ;_fa =_gfa .Y ;_cg =_gfa .Y ;continue ;};if _gfa .X < _aa {_aa =_gfa .X ;
};if _gfa .X > _gc {_gc =_gfa .X ;};if _gfa .Y < _fa {_fa =_gfa .Y ;};if _gfa .Y > _cg {_cg =_gfa .Y ;};};_eg .X =_aa ;_eg .Y =_fa ;_eg .Width =_gc -_aa ;_eg .Height =_cg -_fa ;return _eg ;};

// Magnitude returns the magnitude of the vector.
func (_aafd Vector )Magnitude ()float64 {return _b .Sqrt (_b .Pow (_aafd .Dx ,2.0)+_b .Pow (_aafd .Dy ,2.0));};

// Length returns the number of points in the path.
func (_db Path )Length ()int {return len (_db .Points )};

// GetBounds returns the bounding box of the Bezier curve.
func (_be CubicBezierCurve )GetBounds ()_f .PdfRectangle {_ee :=_be .P0 .X ;_bac :=_be .P0 .X ;_ce :=_be .P0 .Y ;_ge :=_be .P0 .Y ;for _bd :=0.0;_bd <=1.0;_bd +=0.001{Rx :=_be .P0 .X *_b .Pow (1-_bd ,3)+_be .P1 .X *3*_bd *_b .Pow (1-_bd ,2)+_be .P2 .X *3*_b .Pow (_bd ,2)*(1-_bd )+_be .P3 .X *_b .Pow (_bd ,3);
Ry :=_be .P0 .Y *_b .Pow (1-_bd ,3)+_be .P1 .Y *3*_bd *_b .Pow (1-_bd ,2)+_be .P2 .Y *3*_b .Pow (_bd ,2)*(1-_bd )+_be .P3 .Y *_b .Pow (_bd ,3);if Rx < _ee {_ee =Rx ;};if Rx > _bac {_bac =Rx ;};if Ry < _ce {_ce =Ry ;};if Ry > _ge {_ge =Ry ;};};_bf :=_f .PdfRectangle {};
_bf .Llx =_ee ;_bf .Lly =_ce ;_bf .Urx =_bac ;_bf .Ury =_ge ;return _bf ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _f .PdfColor ;Opacity float64 ;};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;
LineEndingStyleButt LineEndingStyle =2;);

// Scale scales the vector by the specified factor.
func (_fe Vector )Scale (factor float64 )Vector {_fag :=_fe .Magnitude ();_fge :=_fe .GetPolarAngle ();_fe .Dx =factor *_fag *_b .Cos (_fge );_fe .Dy =factor *_fag *_b .Sin (_fge );return _fe ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_ega BoundingBox )ToPdfRectangle ()*_f .PdfRectangle {return &_f .PdfRectangle {Llx :_ega .X ,Lly :_ega .Y ,Urx :_ega .X +_ega .Width ,Ury :_ega .Y +_ega .Height };};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_gg Circle )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_egbd :=_gg .Width /2;_bdc :=_gg .Height /2;if _gg .BorderEnabled {_egbd -=_gg .BorderWidth /2;_bdc -=_gg .BorderWidth /2;};_ed :=0.551784;_gbg :=_egbd *_ed ;_aabb :=_bdc *_ed ;
_ad :=NewCubicBezierPath ();_ad =_ad .AppendCurve (NewCubicBezierCurve (-_egbd ,0,-_egbd ,_aabb ,-_gbg ,_bdc ,0,_bdc ));_ad =_ad .AppendCurve (NewCubicBezierCurve (0,_bdc ,_gbg ,_bdc ,_egbd ,_aabb ,_egbd ,0));_ad =_ad .AppendCurve (NewCubicBezierCurve (_egbd ,0,_egbd ,-_aabb ,_gbg ,-_bdc ,0,-_bdc ));
_ad =_ad .AppendCurve (NewCubicBezierCurve (0,-_bdc ,-_gbg ,-_bdc ,-_egbd ,-_aabb ,-_egbd ,0));_ad =_ad .Offset (_egbd ,_bdc );if _gg .BorderEnabled {_ad =_ad .Offset (_gg .BorderWidth /2,_gg .BorderWidth /2);};if _gg .X !=0||_gg .Y !=0{_ad =_ad .Offset (_gg .X ,_gg .Y );
};_cdf :=_d .NewContentCreator ();_cdf .Add_q ();if _gg .FillEnabled {_cdf .SetNonStrokingColor (_gg .FillColor );};if _gg .BorderEnabled {_cdf .SetStrokingColor (_gg .BorderColor );_cdf .Add_w (_gg .BorderWidth );};if len (gsName )> 1{_cdf .Add_gs (_c .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_ad ,_cdf );_cdf .Add_h ();if _gg .FillEnabled &&_gg .BorderEnabled {_cdf .Add_B ();}else if _gg .FillEnabled {_cdf .Add_f ();}else if _gg .BorderEnabled {_cdf .Add_S ();};_cdf .Add_Q ();_geff :=_ad .GetBoundingBox ();if _gg .BorderEnabled {_geff .Height +=_gg .BorderWidth ;
_geff .Width +=_gg .BorderWidth ;_geff .X -=_gg .BorderWidth /2;_geff .Y -=_gg .BorderWidth /2;};return _cdf .Bytes (),_geff .ToPdfRectangle (),nil ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_ea CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_ea .Curves =append (_ea .Curves ,curve );return _ea ;};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_ba CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_ba .P0 .X +=offX ;_ba .P1 .X +=offX ;_ba .P2 .X +=offX ;_ba .P3 .X +=offX ;_ba .P0 .Y +=offY ;_ba .P1 .Y +=offY ;_ba .P2 .Y +=offY ;_ba .P3 .Y +=offY ;return _ba ;};

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_gde Rectangle )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_cf :=_d .NewContentCreator ();_cf .Add_q ();if _gde .FillEnabled {_cf .SetNonStrokingColor (_gde .FillColor );};if _gde .BorderEnabled {_cf .SetStrokingColor (_gde .BorderColor );
_cf .Add_w (_gde .BorderWidth );};if len (gsName )> 1{_cf .Add_gs (_c .PdfObjectName (gsName ));};var (_cae ,_fgg =_gde .X ,_gde .Y ;_gbc ,_gdg =_gde .Width ,_gde .Height ;_bc =_b .Abs (_gde .BorderRadiusTopLeft );_gfb =_b .Abs (_gde .BorderRadiusTopRight );
_aad =_b .Abs (_gde .BorderRadiusBottomLeft );_ae =_b .Abs (_gde .BorderRadiusBottomRight );_gab =0.4477;);_caf :=Path {Points :[]Point {{X :_cae +_gbc -_ae ,Y :_fgg },{X :_cae +_gbc ,Y :_fgg +_gdg -_gfb },{X :_cae +_bc ,Y :_fgg +_gdg },{X :_cae ,Y :_fgg +_aad }}};
_bgf :=[][7]float64 {{_ae ,_cae +_gbc -_ae *_gab ,_fgg ,_cae +_gbc ,_fgg +_ae *_gab ,_cae +_gbc ,_fgg +_ae },{_gfb ,_cae +_gbc ,_fgg +_gdg -_gfb *_gab ,_cae +_gbc -_gfb *_gab ,_fgg +_gdg ,_cae +_gbc -_gfb ,_fgg +_gdg },{_bc ,_cae +_bc *_gab ,_fgg +_gdg ,_cae ,_fgg +_gdg -_bc *_gab ,_cae ,_fgg +_gdg -_bc },{_aad ,_cae ,_fgg +_aad *_gab ,_cae +_aad *_gab ,_fgg ,_cae +_aad ,_fgg }};
_cf .Add_m (_cae +_aad ,_fgg );for _bb :=0;_bb < 4;_bb ++{_ffe :=_caf .Points [_bb ];_cf .Add_l (_ffe .X ,_ffe .Y );_gcg :=_bgf [_bb ];if _ade :=_gcg [0];_ade !=0{_cf .Add_c (_gcg [1],_gcg [2],_gcg [3],_gcg [4],_gcg [5],_gcg [6]);};};_cf .Add_h ();if _gde .FillEnabled &&_gde .BorderEnabled {_cf .Add_B ();
}else if _gde .FillEnabled {_cf .Add_f ();}else if _gde .BorderEnabled {_cf .Add_S ();};_cf .Add_Q ();return _cf .Bytes (),_caf .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_dab Polyline )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){if _dab .LineColor ==nil {_dab .LineColor =_f .NewPdfColorDeviceRGB (0,0,0);};_def :=NewPath ();for _ ,_ffg :=range _dab .Points {_def =_def .AppendPoint (_ffg );};_aef :=_d .NewContentCreator ();
_aef .Add_q ().SetStrokingColor (_dab .LineColor ).Add_w (_dab .LineWidth );if len (gsName )> 1{_aef .Add_gs (_c .PdfObjectName (gsName ));};DrawPathWithCreator (_def ,_aef );_aef .Add_S ();_aef .Add_Q ();return _aef .Bytes (),_def .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_df Rectangle )ToPdfRectangle ()*_f .PdfRectangle {return &_f .PdfRectangle {Llx :_df .X ,Lly :_df .Y ,Urx :_df .X +_df .Width ,Ury :_df .Y +_df .Height };};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_gfae :=Vector {};_gfae .Dx =b .X -a .X ;_gfae .Dy =b .Y -a .Y ;return _gfae ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_gebc :=Vector {};_gebc .Dx =dx ;_gebc .Dy =dy ;return _gebc };

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_d .ContentCreator ){for _gea ,_bfc :=range bpath .Curves {if _gea ==0{creator .Add_m (_bfc .P0 .X ,_bfc .P0 .Y );};creator .Add_c (_bfc .P1 .X ,_bfc .P1 .Y ,_bfc .P2 .X ,_bfc .P2 .Y ,_bfc .P3 .X ,_bfc .P3 .Y );
};};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _f .PdfColor ;LineWidth float64 ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _f .PdfColor ;BorderEnabled bool ;BorderColor _f .PdfColor ;BorderWidth float64 ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _f .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;DashArray []int64 ;DashPhase int64 ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _f .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// Rotate rotates the vector by the specified angle.
func (_ccgc Vector )Rotate (phi float64 )Vector {_deb :=_ccgc .Magnitude ();_bdf :=_ccgc .GetPolarAngle ();return NewVectorPolar (_deb ,_bdf +phi );};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_ca Path )RemovePoint (number int )Path {if number < 1||number > len (_ca .Points ){return _ca ;};_dc :=number -1;_ca .Points =append (_ca .Points [:_dc ],_ca .Points [_dc +1:]...);return _ca ;};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_cgf Line )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_gba ,_dd :=_cgf .X1 ,_cgf .X2 ;_dag ,_bef :=_cgf .Y1 ,_cgf .Y2 ;_fff :=_bef -_dag ;_fdb :=_dd -_gba ;_gdgc :=_b .Atan2 (_fff ,_fdb );L :=_b .Sqrt (_b .Pow (_fdb ,2.0)+_b .Pow (_fff ,2.0));
_gcd :=_cgf .LineWidth ;_cga :=_b .Pi ;_gac :=1.0;if _fdb < 0{_gac *=-1.0;};if _fff < 0{_gac *=-1.0;};VsX :=_gac *(-_gcd /2*_b .Cos (_gdgc +_cga /2));VsY :=_gac *(-_gcd /2*_b .Sin (_gdgc +_cga /2)+_gcd *_b .Sin (_gdgc +_cga /2));V1X :=VsX +_gcd /2*_b .Cos (_gdgc +_cga /2);
V1Y :=VsY +_gcd /2*_b .Sin (_gdgc +_cga /2);V2X :=VsX +_gcd /2*_b .Cos (_gdgc +_cga /2)+L *_b .Cos (_gdgc );V2Y :=VsY +_gcd /2*_b .Sin (_gdgc +_cga /2)+L *_b .Sin (_gdgc );V3X :=VsX +_gcd /2*_b .Cos (_gdgc +_cga /2)+L *_b .Cos (_gdgc )+_gcd *_b .Cos (_gdgc -_cga /2);
V3Y :=VsY +_gcd /2*_b .Sin (_gdgc +_cga /2)+L *_b .Sin (_gdgc )+_gcd *_b .Sin (_gdgc -_cga /2);V4X :=VsX +_gcd /2*_b .Cos (_gdgc -_cga /2);V4Y :=VsY +_gcd /2*_b .Sin (_gdgc -_cga /2);_aaf :=NewPath ();_aaf =_aaf .AppendPoint (NewPoint (V1X ,V1Y ));_aaf =_aaf .AppendPoint (NewPoint (V2X ,V2Y ));
_aaf =_aaf .AppendPoint (NewPoint (V3X ,V3Y ));_aaf =_aaf .AppendPoint (NewPoint (V4X ,V4Y ));_fgc :=_cgf .LineEndingStyle1 ;_caea :=_cgf .LineEndingStyle2 ;_fc :=3*_gcd ;_cdd :=3*_gcd ;_fdc :=(_cdd -_gcd )/2;if _caea ==LineEndingStyleArrow {_gcb :=_aaf .GetPointNumber (2);
_cgga :=NewVectorPolar (_fc ,_gdgc +_cga );_cedf :=_gcb .AddVector (_cgga );_dda :=NewVectorPolar (_cdd /2,_gdgc +_cga /2);_bbf :=NewVectorPolar (_fc ,_gdgc );_fcf :=NewVectorPolar (_fdc ,_gdgc +_cga /2);_bae :=_cedf .AddVector (_fcf );_de :=_bbf .Add (_dda .Flip ());
_bge :=_bae .AddVector (_de );_bdg :=_dda .Scale (2).Flip ().Add (_de .Flip ());_cb :=_bge .AddVector (_bdg );_ebd :=_cedf .AddVector (NewVectorPolar (_gcd ,_gdgc -_cga /2));_fce :=NewPath ();_fce =_fce .AppendPoint (_aaf .GetPointNumber (1));_fce =_fce .AppendPoint (_cedf );
_fce =_fce .AppendPoint (_bae );_fce =_fce .AppendPoint (_bge );_fce =_fce .AppendPoint (_cb );_fce =_fce .AppendPoint (_ebd );_fce =_fce .AppendPoint (_aaf .GetPointNumber (4));_aaf =_fce ;};if _fgc ==LineEndingStyleArrow {_gabd :=_aaf .GetPointNumber (1);
_abea :=_aaf .GetPointNumber (_aaf .Length ());_ecb :=NewVectorPolar (_gcd /2,_gdgc +_cga +_cga /2);_cdg :=_gabd .AddVector (_ecb );_geffb :=NewVectorPolar (_fc ,_gdgc ).Add (NewVectorPolar (_cdd /2,_gdgc +_cga /2));_ccg :=_cdg .AddVector (_geffb );_bgg :=NewVectorPolar (_fdc ,_gdgc -_cga /2);
_afa :=_ccg .AddVector (_bgg );_dfb :=NewVectorPolar (_fc ,_gdgc );_baec :=_abea .AddVector (_dfb );_cee :=NewVectorPolar (_fdc ,_gdgc +_cga +_cga /2);_cdb :=_baec .AddVector (_cee );_ggf :=_cdg ;_edg :=NewPath ();_edg =_edg .AppendPoint (_cdg );_edg =_edg .AppendPoint (_ccg );
_edg =_edg .AppendPoint (_afa );for _ ,_bcc :=range _aaf .Points [1:len (_aaf .Points )-1]{_edg =_edg .AppendPoint (_bcc );};_edg =_edg .AppendPoint (_baec );_edg =_edg .AppendPoint (_cdb );_edg =_edg .AppendPoint (_ggf );_aaf =_edg ;};_bcf :=_d .NewContentCreator ();
_bcf .Add_q ().SetNonStrokingColor (_cgf .LineColor );if len (gsName )> 1{_bcf .Add_gs (_c .PdfObjectName (gsName ));};_aaf =_aaf .Offset (_cgf .X1 ,_cgf .Y1 );_ac :=_aaf .GetBoundingBox ();DrawPathWithCreator (_aaf ,_bcf );if _cgf .LineStyle ==LineStyleDashed {_bcf .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_bcf .Add_f ().Add_Q ();};return _bcf .Bytes (),_ac .ToPdfRectangle (),nil ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_da :=CubicBezierPath {};_da .Curves =[]CubicBezierCurve {};return _da ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Offset shifts the path with the specified offsets.
func (_cd Path )Offset (offX ,offY float64 )Path {for _abf ,_efe :=range _cd .Points {_cd .Points [_abf ]=_efe .Add (offX ,offY );};return _cd ;};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_gef Point )Rotate (theta float64 )Point {_dae :=_a .NewPoint (_gef .X ,_gef .Y ).Rotate (theta );return NewPoint (_dae .X ,_dae .Y );};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _f .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _f .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// AppendPoint adds the specified point to the path.
func (_bga Path )AppendPoint (point Point )Path {_bga .Points =append (_bga .Points ,point );return _bga };

// AddVector adds vector to a point.
func (_eb Point )AddVector (v Vector )Point {_eb .X +=v .Dx ;_eb .Y +=v .Dy ;return _eb };

// Offset shifts the Bezier path with the specified offsets.
func (_ab CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _gb ,_fg :=range _ab .Curves {_ab .Curves [_gb ]=_fg .AddOffsetXY (offX ,offY );};return _ab ;};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_baf PolyBezierCurve )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){if _baf .BorderColor ==nil {_baf .BorderColor =_f .NewPdfColorDeviceRGB (0,0,0);};_cea :=NewCubicBezierPath ();for _ ,_abe :=range _baf .Curves {_cea =_cea .AppendCurve (_abe );
};_cda :=_d .NewContentCreator ();_cda .Add_q ();_baf .FillEnabled =_baf .FillEnabled &&_baf .FillColor !=nil ;if _baf .FillEnabled {_cda .SetNonStrokingColor (_baf .FillColor );};_cda .SetStrokingColor (_baf .BorderColor );_cda .Add_w (_baf .BorderWidth );
if len (gsName )> 1{_cda .Add_gs (_c .PdfObjectName (gsName ));};for _af ,_gfdf :=range _cea .Curves {if _af ==0{_cda .Add_m (_gfdf .P0 .X ,_gfdf .P0 .Y );}else {_cda .Add_l (_gfdf .P0 .X ,_gfdf .P0 .Y );};_cda .Add_c (_gfdf .P1 .X ,_gfdf .P1 .Y ,_gfdf .P2 .X ,_gfdf .P2 .Y ,_gfdf .P3 .X ,_gfdf .P3 .Y );
};if _baf .FillEnabled {_cda .Add_h ();_cda .Add_B ();}else {_cda .Add_S ();};_cda .Add_Q ();return _cda .Bytes (),_cea .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Add adds the specified vector to the current one and returns the result.
func (_dbe Vector )Add (other Vector )Vector {_dbe .Dx +=other .Dx ;_dbe .Dy +=other .Dy ;return _dbe };

// Flip changes the sign of the vector: -vector.
func (_bacd Vector )Flip ()Vector {_aea :=_bacd .Magnitude ();_geed :=_bacd .GetPolarAngle ();_bacd .Dx =_aea *_b .Cos (_geed +_b .Pi );_bacd .Dy =_aea *_b .Sin (_geed +_b .Pi );return _bacd ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_ef Path )GetPointNumber (number int )Point {if number < 1||number > len (_ef .Points ){return Point {};};return _ef .Points [number -1];};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_ebc Polygon )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_gd :=_d .NewContentCreator ();_gd .Add_q ();_ebc .FillEnabled =_ebc .FillEnabled &&_ebc .FillColor !=nil ;if _ebc .FillEnabled {_gd .SetNonStrokingColor (_ebc .FillColor );};
_ebc .BorderEnabled =_ebc .BorderEnabled &&_ebc .BorderColor !=nil ;if _ebc .BorderEnabled {_gd .SetStrokingColor (_ebc .BorderColor );_gd .Add_w (_ebc .BorderWidth );};if len (gsName )> 1{_gd .Add_gs (_c .PdfObjectName (gsName ));};_eef :=NewPath ();for _ ,_ced :=range _ebc .Points {for _afc ,_egbf :=range _ced {_eef =_eef .AppendPoint (_egbf );
if _afc ==0{_gd .Add_m (_egbf .X ,_egbf .Y );}else {_gd .Add_l (_egbf .X ,_egbf .Y );};};_gd .Add_h ();};if _ebc .FillEnabled &&_ebc .BorderEnabled {_gd .Add_B ();}else if _ebc .FillEnabled {_gd .Add_f ();}else if _ebc .BorderEnabled {_gd .Add_S ();};_gd .Add_Q ();
return _gd .Bytes (),_eef .GetBoundingBox ().ToPdfRectangle (),nil ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_e :=CubicBezierCurve {};_e .P0 =NewPoint (x0 ,y0 );_e .P1 =NewPoint (x1 ,y1 );_e .P2 =NewPoint (x2 ,y2 );_e .P3 =NewPoint (x3 ,y3 );return _e ;};

// FlipX flips the sign of the Dx component of the vector.
func (_aae Vector )FlipX ()Vector {_aae .Dx =-_aae .Dx ;return _aae };

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_bgb :=Vector {};_bgb .Dx =length *_b .Cos (theta );_bgb .Dy =length *_b .Sin (theta );return _bgb ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_cgfe Vector )GetPolarAngle ()float64 {return _b .Atan2 (_cgfe .Dy ,_cgfe .Dx )};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_d .ContentCreator ){for _cafd ,_fbg :=range path .Points {if _cafd ==0{creator .Add_m (_fbg .X ,_fbg .Y );}else {creator .Add_l (_fbg .X ,_fbg .Y );};};};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _f .PdfColor ;FillEnabled bool ;FillColor _f .PdfColor ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;func (_aab Point )String ()string {return _gf .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_aab .X ,_aab .Y );};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_fb CubicBezierPath )GetBoundingBox ()Rectangle {_geb :=Rectangle {};_ga :=0.0;_cc :=0.0;_bg :=0.0;_fd :=0.0;for _bfb ,_gfd :=range _fb .Curves {_fgd :=_gfd .GetBounds ();if _bfb ==0{_ga =_fgd .Llx ;_cc =_fgd .Urx ;_bg =_fgd .Lly ;_fd =_fgd .Ury ;
continue ;};if _fgd .Llx < _ga {_ga =_fgd .Llx ;};if _fgd .Urx > _cc {_cc =_fgd .Urx ;};if _fgd .Lly < _bg {_bg =_fgd .Lly ;};if _fgd .Ury > _fd {_fd =_fgd .Ury ;};};_geb .X =_ga ;_geb .Y =_bg ;_geb .Width =_cc -_ga ;_geb .Height =_fd -_bg ;return _geb ;
};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_ebf BasicLine )Draw (gsName string )([]byte ,*_f .PdfRectangle ,error ){_baea :=NewPath ();_baea =_baea .AppendPoint (NewPoint (_ebf .X1 ,_ebf .Y1 ));_baea =_baea .AppendPoint (NewPoint (_ebf .X2 ,_ebf .Y2 ));_fdf :=_d .NewContentCreator ();_fdf .Add_q ().Add_w (_ebf .LineWidth ).SetStrokingColor (_ebf .LineColor );
if _ebf .LineStyle ==LineStyleDashed {if _ebf .DashArray ==nil {_ebf .DashArray =[]int64 {1,1};};_fdf .Add_d (_ebf .DashArray ,_ebf .DashPhase );};if len (gsName )> 1{_fdf .Add_gs (_c .PdfObjectName (gsName ));};DrawPathWithCreator (_baea ,_fdf );_fdf .Add_S ().Add_Q ();
return _fdf .Bytes (),_baea .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_egb Point )Add (dx ,dy float64 )Point {_egb .X +=dx ;_egb .Y +=dy ;return _egb };